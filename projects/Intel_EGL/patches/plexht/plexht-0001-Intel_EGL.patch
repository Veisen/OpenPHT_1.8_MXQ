From 6bb215fa99613d19425aa29861a97961fa632374 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 31 May 2015 17:36:21 +0200
Subject: [PATCH 01/41] renderer: promote interface up to BaseRenderer

---
 xbmc/cores/VideoRenderers/BaseRenderer.h      | 48 +++++++++++++++--------
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp | 56 +++++++++++++++------------
 xbmc/cores/VideoRenderers/LinuxRendererGL.h   | 42 +++++++-------------
 xbmc/cores/VideoRenderers/RenderManager.cpp   | 29 ++++----------
 xbmc/cores/VideoRenderers/RenderManager.h     | 12 +-----
 5 files changed, 86 insertions(+), 101 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.h b/xbmc/cores/VideoRenderers/BaseRenderer.h
index 86f8aed68a..db2e008c15 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.h
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.h
@@ -57,6 +57,7 @@ typedef void (*RenderUpdateCallBackFn)(const void *ctx, const CRect &SrcRect, co
 typedef void (*RenderFeaturesCallBackFn)(const void *ctx, Features &renderFeatures);
 
 struct DVDVideoPicture;
+class CRenderCapture;
 
 class CBaseRenderer
 {
@@ -64,6 +65,37 @@ public:
   CBaseRenderer();
   virtual ~CBaseRenderer();
 
+  // Player functions
+  virtual bool Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, float fps, unsigned flags, ERenderFormat format, unsigned extended_formatl, unsigned int orientation) = 0;
+  virtual bool IsConfigured() = 0;
+  virtual int GetImage(YV12Image *image, int source = -1, bool readonly = false) = 0;
+  virtual void ReleaseImage(int source, bool preserve = false) = 0;
+  virtual bool AddVideoPicture(DVDVideoPicture* picture, int index) { return false; }
+  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index) = 0;
+  virtual void FlipPage(int source) = 0;
+  virtual unsigned int PreInit() = 0;
+  virtual void UnInit() = 0;
+  virtual void Reset() = 0;
+  virtual void Flush() {};
+  virtual void SetBufferSize(int numBuffers) { }
+  virtual void ReleaseBuffer(int idx) { }
+  virtual bool NeedBufferForRef(int idx) { return false; }
+  virtual bool IsGuiLayer() { return true; }
+  // Render info, can be called before configure
+  virtual CRenderInfo GetRenderInfo() { return CRenderInfo(); }
+  virtual void Update() = 0;
+  virtual void RenderUpdate(bool clear, unsigned int flags = 0, unsigned int alpha = 255) = 0;
+  virtual void SetupScreenshot() = 0;
+  virtual bool RenderCapture(CRenderCapture* capture) = 0;
+  virtual EINTERLACEMETHOD AutoInterlaceMethod() = 0;
+
+  // Feature support
+  virtual bool SupportsMultiPassRendering() = 0;
+  virtual bool Supports(ERENDERFEATURE feature) { return false; };
+  virtual bool Supports(EDEINTERLACEMODE mode) = 0;
+  virtual bool Supports(EINTERLACEMETHOD method) = 0;
+  virtual bool Supports(ESCALINGMETHOD method) = 0;
+
   void SetViewMode(int viewMode);
   RESOLUTION GetResolution() const;
 
@@ -75,22 +107,6 @@ public:
   void GetVideoRect(CRect &source, CRect &dest, CRect &view);
   float GetAspectRatio() const;
 
-  virtual bool AddVideoPicture(DVDVideoPicture* picture, int index) { return false; }
-  virtual void Flush() {};
-
-  /**
-   * Returns number of references a single buffer can retain when rendering a single frame
-   */
-  virtual void         SetBufferSize(int numBuffers) { }
-  virtual void         ReleaseBuffer(int idx) { }
-  virtual bool         NeedBufferForRef(int idx) { return false; }
-  virtual bool         IsGuiLayer() { return true; }
-
-  virtual bool Supports(ERENDERFEATURE feature) { return false; }
-
-  // Render info, can be called before configure
-  virtual CRenderInfo GetRenderInfo() { return CRenderInfo(); }
-
   virtual void RegisterRenderUpdateCallBack(const void *ctx, RenderUpdateCallBackFn fn);
   virtual void RegisterRenderFeaturesCallBack(const void *ctx, RenderFeaturesCallBackFn fn);
 
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index caceca88ee..29f3a8d6f3 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -3471,36 +3471,42 @@ CRenderInfo CLinuxRendererGL::GetRenderInfo()
   return info;
 }
 
-#ifdef HAVE_LIBVDPAU
-void CLinuxRendererGL::AddProcessor(VDPAU::CVdpauRenderPicture *vdpau, int index)
+void CLinuxRendererGL::AddVideoPictureHW(DVDVideoPicture &picture, int index)
 {
-  YUVBUFFER &buf = m_buffers[index];
-  VDPAU::CVdpauRenderPicture *pic = vdpau->Acquire();
-  SAFE_RELEASE(buf.vdpau);
-  buf.vdpau = pic;
-}
+  if (picture.format == RENDER_FMT_VDPAU ||
+      picture.format == RENDER_FMT_VDPAU_420)
+  {
+#ifdef HAVE_LIBVDPAU
+    VDPAU::CVdpauRenderPicture *vdpau = picture.vdpau;
+    YUVBUFFER &buf = m_buffers[index];
+    VDPAU::CVdpauRenderPicture *pic = vdpau->Acquire();
+    SAFE_RELEASE(buf.vdpau);
+    buf.vdpau = pic;
 #endif
-
+  }
+  else if (picture.format == RENDER_FMT_VAAPI ||
+           picture.format == RENDER_FMT_VAAPINV12)
+  {
 #ifdef HAVE_LIBVA
-void CLinuxRendererGL::AddProcessor(VAAPI::CVaapiRenderPicture *vaapi, int index)
-{
-  YUVBUFFER &buf = m_buffers[index];
-  VAAPI::CVaapiRenderPicture *pic = vaapi->Acquire();
-  SAFE_RELEASE(buf.vaapi);
-  buf.vaapi = pic;
-}
+    VAAPI::CVaapiRenderPicture *vaapi = picture.vaapi;
+    YUVBUFFER &buf = m_buffers[index];
+    VAAPI::CVaapiRenderPicture *pic = vaapi->Acquire();
+    SAFE_RELEASE(buf.vaapi);
+    buf.vaapi = pic;
 #endif
-
+  }
+  else if (picture.format == RENDER_FMT_CVBREF)
+  {
 #ifdef TARGET_DARWIN
-void CLinuxRendererGL::AddProcessor(struct __CVBuffer *cvBufferRef, int index)
-{
-  YUVBUFFER &buf = m_buffers[index];
-  if (buf.cvBufferRef)
-    CVBufferRelease(buf.cvBufferRef);
-  buf.cvBufferRef = cvBufferRef;
-  // retain another reference, this way dvdplayer and renderer can issue releases.
-  CVBufferRetain(buf.cvBufferRef);
-}
+    struct __CVBuffer *cvBufferRef = picture.cvBufferRef;
+    YUVBUFFER &buf = m_buffers[index];
+    if (buf.cvBufferRef)
+       CVBufferRelease(buf.cvBufferRef);
+    buf.cvBufferRef = cvBufferRef;
+    // retain another reference, this way dvdplayer and renderer can issue releases.
+    CVBufferRetain(buf.cvBufferRef);
 #endif
+  }
+}
 
 #endif
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.h b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
index 79e1a2b39a..e71e7d2678 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
@@ -117,35 +117,25 @@ public:
   CLinuxRendererGL();
   virtual ~CLinuxRendererGL();
 
-  virtual void Update();
-  virtual void SetupScreenshot() {};
-
-  bool RenderCapture(CRenderCapture* capture);
-
   // Player functions
   virtual bool Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, float fps, unsigned flags, ERenderFormat format, unsigned extended_formatl, unsigned int orientation);
   virtual bool IsConfigured() { return m_bConfigured; }
-  virtual int          GetImage(YV12Image *image, int source = AUTOSOURCE, bool readonly = false);
-  virtual void         ReleaseImage(int source, bool preserve = false);
-  virtual void         FlipPage(int source);
+  virtual int GetImage(YV12Image *image, int source = AUTOSOURCE, bool readonly = false);
+  virtual void ReleaseImage(int source, bool preserve = false);
+  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index);
+  virtual void FlipPage(int source);
   virtual unsigned int PreInit();
-  virtual void         UnInit();
-  virtual void         Reset(); /* resets renderer after seek for example */
-  virtual void         Flush();
-  virtual void         ReleaseBuffer(int idx);
-  virtual void         SetBufferSize(int numBuffers) { m_NumYV12Buffers = numBuffers; }
-
-#ifdef HAVE_LIBVDPAU
-  virtual void         AddProcessor(VDPAU::CVdpauRenderPicture* vdpau, int index);
-#endif
-#ifdef HAVE_LIBVA
-  virtual void         AddProcessor(VAAPI::CVaapiRenderPicture* vaapi, int index);
-#endif
-#ifdef TARGET_DARWIN
-  virtual void         AddProcessor(struct __CVBuffer *cvBufferRef, int index);
-#endif
-
+  virtual void UnInit();
+  virtual void Reset(); /* resets renderer after seek for example */
+  virtual void Flush();
+  virtual void ReleaseBuffer(int idx);
+  virtual void SetBufferSize(int numBuffers) { m_NumYV12Buffers = numBuffers; }
   virtual void RenderUpdate(bool clear, DWORD flags = 0, DWORD alpha = 255);
+  virtual void Update();
+  virtual void SetupScreenshot() {};
+  virtual bool RenderCapture(CRenderCapture* capture);
+  virtual EINTERLACEMETHOD AutoInterlaceMethod();
+  virtual CRenderInfo GetRenderInfo();
 
   // Feature support
   virtual bool SupportsMultiPassRendering();
@@ -154,10 +144,6 @@ public:
   virtual bool Supports(EINTERLACEMETHOD method);
   virtual bool Supports(ESCALINGMETHOD method);
 
-  virtual EINTERLACEMETHOD AutoInterlaceMethod();
-
-  virtual CRenderInfo GetRenderInfo();
-
 protected:
   virtual void Render(DWORD flags, int renderBuffer);
   void         ClearBackBuffer();
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index ef4ab184af..03bd487126 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -969,6 +969,7 @@ int CXBMCRenderManager::AddVideoPicture(DVDVideoPicture& pic)
     index = m_free.front();
   }
 
+  // TODO: this is a Windows onl thing and should go away
   if(m_pRenderer->AddVideoPicture(&pic, index))
     return 1;
 
@@ -995,32 +996,18 @@ int CXBMCRenderManager::AddVideoPicture(DVDVideoPicture& pic)
   {
     CDVDCodecUtils::CopyDXVA2Picture(&image, &pic);
   }
-#ifdef HAVE_LIBVDPAU
   else if(pic.format == RENDER_FMT_VDPAU
-       || pic.format == RENDER_FMT_VDPAU_420)
-    m_pRenderer->AddProcessor(pic.vdpau, index);
-#endif
-#ifdef HAVE_LIBOPENMAX
-  else if(pic.format == RENDER_FMT_OMXEGL)
-    m_pRenderer->AddProcessor(pic.openMax, &pic, index);
-#endif
-#ifdef TARGET_DARWIN
-  else if(pic.format == RENDER_FMT_CVBREF)
-    m_pRenderer->AddProcessor(pic.cvBufferRef, index);
-#endif
-#ifdef HAVE_LIBVA
-  else if(pic.format == RENDER_FMT_VAAPI)
-    m_pRenderer->AddProcessor(pic.vaapi, index);
+       || pic.format == RENDER_FMT_VDPAU_420
+       || pic.format == RENDER_FMT_OMXEGL
+       || pic.format == RENDER_FMT_CVBREF
+       || pic.format == RENDER_FMT_VAAPI
+       || pic.format == RENDER_FMT_MMAL)
+    m_pRenderer->AddVideoPictureHW(pic, index);
   else if(pic.format == RENDER_FMT_VAAPINV12)
   {
-    m_pRenderer->AddProcessor(pic.vaapi, index);
+    m_pRenderer->AddVideoPictureHW(pic, index);
     CDVDCodecUtils::CopyNV12Picture(&image, &pic.vaapi->DVDPic);
   }
-#endif
-#ifdef HAS_MMAL
-  else if(pic.format == RENDER_FMT_MMAL)
-    m_pRenderer->AddProcessor(pic.MMALBuffer, index);
-#endif
 
   m_pRenderer->ReleaseImage(index, false);
 
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index c20070d461..8f14264105 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -150,17 +150,7 @@ public:
 
   void UpdateResolution();
 
-#ifdef HAS_GL
-  CLinuxRendererGL    *m_pRenderer;
-#elif defined(HAS_MMAL)
-  CMMALRenderer       *m_pRenderer;
-#elif HAS_GLES == 2
-  CLinuxRendererGLES  *m_pRenderer;
-#elif defined(HAS_DX)
-  CWinRenderer        *m_pRenderer;
-#elif defined(HAS_SDL)
-  CLinuxRenderer      *m_pRenderer;
-#endif
+  CBaseRenderer *m_pRenderer;
 
   // Get renderer info, can be called before configure
   CRenderInfo GetRenderInfo();

From 06c68354f3794d526d7b4b529765019a51980891 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Mon, 1 Jun 2015 13:56:29 +0200
Subject: [PATCH 02/41] renderer: refactor RenderManager and LinuxRendererGL

---
 xbmc/Application.cpp                               |    2 +-
 xbmc/cores/VideoRenderers/BaseRenderer.h           |    9 +-
 xbmc/cores/VideoRenderers/CMakeLists.txt           |    1 +
 .../VideoRenderers/HwDecRender/CMakeLists.txt      |    7 +
 .../VideoRenderers/{ => HwDecRender}/DXVA.cpp      |    0
 xbmc/cores/VideoRenderers/{ => HwDecRender}/DXVA.h |    0
 .../VideoRenderers/{ => HwDecRender}/DXVAHD.cpp    |    0
 .../VideoRenderers/{ => HwDecRender}/DXVAHD.h      |    0
 .../{ => HwDecRender}/MMALRenderer.cpp             |    0
 .../{ => HwDecRender}/MMALRenderer.h               |    0
 .../VideoRenderers/HwDecRender/RendererVAAPI.cpp   |  264 +++++
 .../VideoRenderers/HwDecRender/RendererVAAPI.h     |   56 ++
 .../VideoRenderers/HwDecRender/RendererVDA.cpp     |  174 ++++
 .../cores/VideoRenderers/HwDecRender/RendererVDA.h |   54 +
 .../VideoRenderers/HwDecRender/RendererVDPAU.cpp   |  418 ++++++++
 .../VideoRenderers/HwDecRender/RendererVDPAU.h     |   64 ++
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp      | 1030 +++++---------------
 xbmc/cores/VideoRenderers/LinuxRendererGL.h        |   46 +-
 xbmc/cores/VideoRenderers/RenderManager.cpp        |  385 +++++---
 xbmc/cores/VideoRenderers/RenderManager.h          |  102 +-
 xbmc/cores/VideoRenderers/WinRenderer.cpp          |   21 +-
 xbmc/cores/VideoRenderers/WinRenderer.h            |    6 +-
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp            |  123 +--
 xbmc/cores/dvdplayer/DVDPlayerVideo.h              |   17 -
 xbmc/guilib/GUIVideoControl.cpp                    |    4 +-
 25 files changed, 1627 insertions(+), 1156 deletions(-)
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/CMakeLists.txt
 rename xbmc/cores/VideoRenderers/{ => HwDecRender}/DXVA.cpp (100%)
 rename xbmc/cores/VideoRenderers/{ => HwDecRender}/DXVA.h (100%)
 rename xbmc/cores/VideoRenderers/{ => HwDecRender}/DXVAHD.cpp (100%)
 rename xbmc/cores/VideoRenderers/{ => HwDecRender}/DXVAHD.h (100%)
 rename xbmc/cores/VideoRenderers/{ => HwDecRender}/MMALRenderer.cpp (100%)
 rename xbmc/cores/VideoRenderers/{ => HwDecRender}/MMALRenderer.h (100%)
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.h
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/RendererVDA.cpp
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/RendererVDA.h
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp
 create mode 100644 xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.h

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 8fd6af4313..55267edbd9 100755
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -4254,7 +4254,7 @@ bool CApplication::PlayFile(const CFileItem& item_, bool bRestart)
     else if(m_pPlayer->IsPlayingVideo())
     {
       // if player didn't manange to switch to fullscreen by itself do it here
-      if (options.fullscreen && g_renderManager.IsStarted() &&
+      if (options.fullscreen && g_renderManager.IsConfigured() &&
           g_windowManager.GetActiveWindow() != WINDOW_FULLSCREEN_VIDEO )
        SwitchToFullScreen();
     }
diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.h b/xbmc/cores/VideoRenderers/BaseRenderer.h
index db2e008c15..b4de0a95b9 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.h
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.h
@@ -27,6 +27,7 @@
 #include "guilib/Geometry.h"
 #include "RenderFormats.h"
 #include "RenderFeatures.h"
+#include "settings/VideoSettings.h"
 
 #define MAX_PLANES 3
 #define MAX_FIELDS 3
@@ -71,9 +72,9 @@ public:
   virtual int GetImage(YV12Image *image, int source = -1, bool readonly = false) = 0;
   virtual void ReleaseImage(int source, bool preserve = false) = 0;
   virtual bool AddVideoPicture(DVDVideoPicture* picture, int index) { return false; }
-  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index) = 0;
+  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index) {};
   virtual void FlipPage(int source) = 0;
-  virtual unsigned int PreInit() = 0;
+  virtual void PreInit() = 0;
   virtual void UnInit() = 0;
   virtual void Reset() = 0;
   virtual void Flush() {};
@@ -96,6 +97,8 @@ public:
   virtual bool Supports(EINTERLACEMETHOD method) = 0;
   virtual bool Supports(ESCALINGMETHOD method) = 0;
 
+  ERenderFormat GetRenderFormat() { return m_format; }
+
   void SetViewMode(int viewMode);
   RESOLUTION GetResolution() const;
 
@@ -123,7 +126,7 @@ protected:
   virtual void       ReorderDrawPoints();//might be overwritten (by egl e.x.)
   void       saveRotatedCoords();//saves the current state of m_rotatedDestCoords
   void       syncDestRectToRotatedPoints();//sync any changes of m_destRect to m_rotatedDestCoords
-  void       restoreRotatedCoords();//restore the current state of m_rotatedDestCoords from saveRotatedCoords 
+  void       restoreRotatedCoords();//restore the current state of m_rotatedDestCoords from saveRotatedCoords
   void       MarkDirty();
 
   RESOLUTION m_resolution;    // the resolution we're running in
diff --git a/xbmc/cores/VideoRenderers/CMakeLists.txt b/xbmc/cores/VideoRenderers/CMakeLists.txt
index f18703eca3..774c8c903c 100644
--- a/xbmc/cores/VideoRenderers/CMakeLists.txt
+++ b/xbmc/cores/VideoRenderers/CMakeLists.txt
@@ -1,3 +1,4 @@
+add_subdirectory(HwDecRender)
 add_subdirectory(VideoShaders)
 find_all_sources(. videorenderers_SRCS)
 
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/CMakeLists.txt b/xbmc/cores/VideoRenderers/HwDecRender/CMakeLists.txt
new file mode 100644
index 0000000000..158381d7bf
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/CMakeLists.txt
@@ -0,0 +1,7 @@
+find_all_sources(. hwdecrender_SRCS)
+
+if(NOT TARGET_RPI)
+  list(REMOVE_ITEM hwdecrender_SRCS ./MMALRenderer.cpp)
+endif()
+
+add_sources(${hwdecrender_SRCS})
diff --git a/xbmc/cores/VideoRenderers/DXVA.cpp b/xbmc/cores/VideoRenderers/HwDecRender/DXVA.cpp
similarity index 100%
rename from xbmc/cores/VideoRenderers/DXVA.cpp
rename to xbmc/cores/VideoRenderers/HwDecRender/DXVA.cpp
diff --git a/xbmc/cores/VideoRenderers/DXVA.h b/xbmc/cores/VideoRenderers/HwDecRender/DXVA.h
similarity index 100%
rename from xbmc/cores/VideoRenderers/DXVA.h
rename to xbmc/cores/VideoRenderers/HwDecRender/DXVA.h
diff --git a/xbmc/cores/VideoRenderers/DXVAHD.cpp b/xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.cpp
similarity index 100%
rename from xbmc/cores/VideoRenderers/DXVAHD.cpp
rename to xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.cpp
diff --git a/xbmc/cores/VideoRenderers/DXVAHD.h b/xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.h
similarity index 100%
rename from xbmc/cores/VideoRenderers/DXVAHD.h
rename to xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.h
diff --git a/xbmc/cores/VideoRenderers/MMALRenderer.cpp b/xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.cpp
similarity index 100%
rename from xbmc/cores/VideoRenderers/MMALRenderer.cpp
rename to xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.cpp
diff --git a/xbmc/cores/VideoRenderers/MMALRenderer.h b/xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.h
similarity index 100%
rename from xbmc/cores/VideoRenderers/MMALRenderer.h
rename to xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.h
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp b/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
new file mode 100644
index 0000000000..053ccd3c6c
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
@@ -0,0 +1,264 @@
+/*
+ *      Copyright (C) 2007-2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "RendererVAAPI.h"
+
+#ifdef HAVE_LIBVA
+
+#include "cores/dvdplayer/DVDCodecs/Video/VAAPI.h"
+#include "cores/dvdplayer/DVDCodecs/DVDCodecUtils.h"
+#include "settings/GUISettings.h"
+#include "settings/AdvancedSettings.h"
+#include "utils/log.h"
+
+CRendererVAAPI::CRendererVAAPI()
+{
+
+}
+
+CRendererVAAPI::~CRendererVAAPI()
+{
+  for (int i = 0; i < NUM_BUFFERS; ++i)
+  {
+    DeleteTexture(i);
+  }
+}
+
+void CRendererVAAPI::AddVideoPictureHW(DVDVideoPicture &picture, int index)
+{
+  VAAPI::CVaapiRenderPicture *vaapi = picture.vaapi;
+  YUVBUFFER &buf = m_buffers[index];
+  VAAPI::CVaapiRenderPicture *pic = vaapi->Acquire();
+  if (buf.hwDec)
+    ((VAAPI::CVaapiRenderPicture*)buf.hwDec)->Release();
+  buf.hwDec = pic;
+
+  if (m_format == RENDER_FMT_VAAPINV12)
+  {
+    YV12Image &im = m_buffers[index].image;
+    CDVDCodecUtils::CopyNV12Picture(&im, &vaapi->DVDPic);
+  }
+}
+
+void CRendererVAAPI::ReleaseBuffer(int idx)
+{
+  YUVBUFFER &buf = m_buffers[idx];
+  if (buf.hwDec)
+    ((VAAPI::CVaapiRenderPicture*)buf.hwDec)->Release();
+  buf.hwDec = NULL;
+}
+
+CRenderInfo CRendererVAAPI::GetRenderInfo()
+{
+  CRenderInfo info;
+  info.formats = m_formats;
+  info.max_buffer_size = NUM_BUFFERS;
+  if (m_format == RENDER_FMT_VAAPINV12)
+    info.optimal_buffer_size = 3;
+  else
+    info.optimal_buffer_size = 5;
+  return info;
+}
+
+bool CRendererVAAPI::Supports(ERENDERFEATURE feature)
+{
+  if (m_format == RENDER_FMT_VAAPINV12)
+    return CLinuxRendererGL::Supports(feature);
+
+  if (feature == RENDERFEATURE_STRETCH         ||
+      feature == RENDERFEATURE_ZOOM            ||
+      feature == RENDERFEATURE_VERTICAL_SHIFT  ||
+      feature == RENDERFEATURE_PIXEL_RATIO     ||
+      feature == RENDERFEATURE_POSTPROCESS     ||
+      feature == RENDERFEATURE_ROTATION        ||
+      feature == RENDERFEATURE_NONLINSTRETCH)
+    return true;
+
+  return false;
+}
+
+bool CRendererVAAPI::Supports(EINTERLACEMETHOD method)
+{
+  VAAPI::CVaapiRenderPicture *vaapiPic = (VAAPI::CVaapiRenderPicture*)m_buffers[m_iYV12RenderBuffer].hwDec;
+  if(vaapiPic && vaapiPic->vaapi)
+    return vaapiPic->vaapi->Supports(method);
+  return false;
+}
+
+bool CRendererVAAPI::Supports(ESCALINGMETHOD method)
+{
+  if (m_format == RENDER_FMT_VAAPINV12)
+    return CLinuxRendererGL::Supports(method);
+
+  //nearest neighbor doesn't work on YUY2 and UYVY
+  if (method == VS_SCALINGMETHOD_NEAREST &&
+      m_format != RENDER_FMT_YUYV422 &&
+      m_format != RENDER_FMT_UYVY422)
+    return true;
+
+  if(method == VS_SCALINGMETHOD_LINEAR
+  || method == VS_SCALINGMETHOD_AUTO)
+    return true;
+
+  if(method == VS_SCALINGMETHOD_CUBIC
+  || method == VS_SCALINGMETHOD_LANCZOS2
+  || method == VS_SCALINGMETHOD_SPLINE36_FAST
+  || method == VS_SCALINGMETHOD_LANCZOS3_FAST
+  || method == VS_SCALINGMETHOD_SPLINE36
+  || method == VS_SCALINGMETHOD_LANCZOS3)
+  {
+    // if scaling is below level, avoid hq scaling
+    float scaleX = fabs(((float)m_sourceWidth - m_destRect.Width())/m_sourceWidth)*100;
+    float scaleY = fabs(((float)m_sourceHeight - m_destRect.Height())/m_sourceHeight)*100;
+    int minScale = g_guiSettings.GetInt("videoplayer.hqscalers");
+    if (scaleX < minScale && scaleY < minScale)
+      return false;
+
+    // spline36 and lanczos3 are only allowed through advancedsettings.xml
+    if(method != VS_SCALINGMETHOD_SPLINE36
+        && method != VS_SCALINGMETHOD_LANCZOS3)
+      return true;
+    else
+      return g_advancedSettings.m_videoEnableHighQualityHwScalers;
+  }
+
+  return false;
+}
+
+bool CRendererVAAPI::LoadShadersHook()
+{
+  if (m_format == RENDER_FMT_VAAPINV12)
+    return false;
+
+  CLog::Log(LOGNOTICE, "GL: Using VAAPI render method");
+  m_renderMethod = RENDER_VAAPI;
+  return true;
+}
+
+bool CRendererVAAPI::RenderHook(int idx)
+{
+  if (m_format == RENDER_FMT_VAAPINV12)
+    return false;
+
+  UpdateVideoFilter();
+  RenderRGB(idx, m_currentField);
+  YUVBUFFER &buf = m_buffers[idx];
+  if (buf.hwDec)
+  {
+    ((VAAPI::CVaapiRenderPicture*)buf.hwDec)->Sync();
+  }
+  return true;
+}
+
+bool CRendererVAAPI::CreateTexture(int index)
+{
+  if (m_format == RENDER_FMT_VAAPINV12)
+  {
+    return CreateNV12Texture(index);
+  }
+
+  YV12Image &im     = m_buffers[index].image;
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE  &plane  = fields[0][0];
+
+  DeleteTexture(index);
+
+  memset(&im    , 0, sizeof(im));
+  memset(&fields, 0, sizeof(fields));
+  im.height = m_sourceHeight;
+  im.width  = m_sourceWidth;
+
+  plane.texwidth  = im.width;
+  plane.texheight = im.height;
+
+  plane.pixpertex_x = 1;
+  plane.pixpertex_y = 1;
+
+  plane.id = 1;
+
+  return true;
+}
+
+void CRendererVAAPI::DeleteTexture(int index)
+{
+  if (m_format == RENDER_FMT_VAAPINV12)
+  {
+    DeleteNV12Texture(index);
+    return;
+  }
+
+  YUVPLANE &plane = m_buffers[index].fields[FIELD_FULL][0];
+  if (m_buffers[index].hwDec)
+    ((VAAPI::CVaapiRenderPicture*)m_buffers[index].hwDec)->Release();
+  m_buffers[index].hwDec = NULL;
+  plane.id = 0;
+}
+
+bool CRendererVAAPI::UploadTexture(int index)
+{
+  if (m_format == RENDER_FMT_VAAPINV12)
+  {
+    return UploadNV12Texture(index);
+  }
+
+  VAAPI::CVaapiRenderPicture *vaapi = (VAAPI::CVaapiRenderPicture*)m_buffers[index].hwDec;
+
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE &plane = fields[FIELD_FULL][0];
+
+  if (!vaapi || !vaapi->valid)
+  {
+    return false;
+  }
+
+  if (!vaapi->CopyGlx())
+    return false;
+
+  plane.id = vaapi->texture;
+
+  // in stereoscopic mode sourceRect may only
+  // be a part of the source video surface
+  plane.rect = m_sourceRect;
+
+  // clip rect
+  if (vaapi->crop.x1 > plane.rect.x1)
+    plane.rect.x1 = vaapi->crop.x1;
+  if (vaapi->crop.x2 < plane.rect.x2)
+    plane.rect.x2 = vaapi->crop.x2;
+  if (vaapi->crop.y1 > plane.rect.y1)
+    plane.rect.y1 = vaapi->crop.y1;
+  if (vaapi->crop.y2 < plane.rect.y2)
+    plane.rect.y2 = vaapi->crop.y2;
+
+  plane.texheight = vaapi->texHeight;
+  plane.texwidth  = vaapi->texWidth;
+
+  if (m_textureTarget == GL_TEXTURE_2D)
+  {
+    plane.rect.y1 /= plane.texheight;
+    plane.rect.y2 /= plane.texheight;
+    plane.rect.x1 /= plane.texwidth;
+    plane.rect.x2 /= plane.texwidth;
+  }
+  return true;
+}
+
+
+#endif
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.h b/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.h
new file mode 100644
index 0000000000..c6d0615ae7
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.h
@@ -0,0 +1,56 @@
+/*
+ *      Copyright (C) 2007-2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include "system.h"
+
+#ifdef HAVE_LIBVA
+
+#include "cores/VideoRenderers/LinuxRendererGL.h"
+
+class CRendererVAAPI : public CLinuxRendererGL
+{
+public:
+  CRendererVAAPI();
+  virtual ~CRendererVAAPI();
+
+  // Player functions
+  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index);
+  virtual void ReleaseBuffer(int idx);
+  virtual CRenderInfo GetRenderInfo();
+
+  // Feature support
+  virtual bool Supports(ERENDERFEATURE feature);
+  virtual bool Supports(EINTERLACEMETHOD method);
+  virtual bool Supports(ESCALINGMETHOD method);
+
+protected:
+  virtual bool LoadShadersHook();
+  virtual bool RenderHook(int idx);
+
+  // textures
+  virtual bool UploadTexture(int index);
+  virtual void DeleteTexture(int index);
+  virtual bool CreateTexture(int index);
+};
+
+#endif
+
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVDA.cpp b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDA.cpp
new file mode 100644
index 0000000000..41c9add383
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDA.cpp
@@ -0,0 +1,174 @@
+/*
+ *      Copyright (C) 2007-2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "RendererVDA.h"
+
+#if defined(TARGET_DARWIN_OSX)
+
+#include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
+#include "cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "utils/log.h"
+#include "osx/CocoaInterface.h"
+#include <CoreVideo/CoreVideo.h>
+#include <OpenGL/CGLIOSurface.h>
+#include "windowing/WindowingFactory.h"
+
+CRendererVDA::CRendererVDA()
+{
+
+}
+
+CRendererVDA::~CRendererVDA()
+{
+
+}
+
+void CRendererVDA::AddVideoPictureHW(DVDVideoPicture &picture, int index)
+{
+  YUVBUFFER &buf = m_buffers[index];
+  if (buf.hwDec)
+    CVBufferRelease((struct __CVBuffer *)buf.hwDec);
+  buf.hwDec = picture.cvBufferRef;
+  // retain another reference, this way dvdplayer and renderer can issue releases.
+  CVBufferRetain(picture.cvBufferRef);
+}
+
+void CRendererVDA::ReleaseBuffer(int idx)
+{
+  YUVBUFFER &buf = m_buffers[idx];
+  if (buf.hwDec)
+    CVBufferRelease((struct __CVBuffer *)buf.hwDec);
+  buf.hwDec = NULL;
+}
+
+
+bool CRendererVDA::Supports(EINTERLACEMETHOD method)
+{
+  return false;
+}
+
+bool CRendererVDA::Supports(EDEINTERLACEMODE mode)
+{
+  return false;
+}
+
+EINTERLACEMETHOD CRendererVDA::AutoInterlaceMethod()
+{
+  return VS_INTERLACEMETHOD_NONE;
+}
+
+bool CRendererVDA::LoadShadersHook()
+{
+  CLog::Log(LOGNOTICE, "GL: Using CVBREF render method");
+  // m_renderMethod = RENDER_CVREF;
+  m_textureTarget = GL_TEXTURE_RECTANGLE_ARB;
+  return false;
+}
+
+bool CRendererVDA::CreateTexture(int index)
+{
+  YV12Image &im     = m_buffers[index].image;
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE  &plane  = fields[0][0];
+
+  DeleteTexture(index);
+
+  memset(&im    , 0, sizeof(im));
+  memset(&fields, 0, sizeof(fields));
+
+  im.bpp    = 1;
+  im.width  = m_sourceWidth;
+  im.height = m_sourceHeight;
+  im.cshift_x = 0;
+  im.cshift_y = 0;
+
+  plane.pixpertex_x = 2;
+  plane.pixpertex_y = 1;
+  plane.texwidth    = im.width  / plane.pixpertex_x;
+  plane.texheight   = im.height / plane.pixpertex_y;
+
+  if(m_renderMethod & RENDER_POT)
+  {
+    plane.texwidth  = NP2(plane.texwidth);
+    plane.texheight = NP2(plane.texheight);
+  }
+
+  glEnable(m_textureTarget);
+  glGenTextures(1, &plane.id);
+  glDisable(m_textureTarget);
+
+  return true;
+}
+
+void CRendererVDA::DeleteTexture(int index)
+{
+  YUVPLANE  &plane = m_buffers[index].fields[0][0];
+
+  if (m_buffers[index].hwDec)
+    CVBufferRelease((struct __CVBuffer *)m_buffers[index].hwDec);
+  m_buffers[index].hwDec = NULL;
+
+  if (plane.id && glIsTexture(plane.id))
+    glDeleteTextures(1, &plane.id), plane.id = 0;
+}
+
+bool CRendererVDA::UploadTexture(int index)
+{
+  YUVBUFFER &buf    = m_buffers[index];
+  YUVFIELDS &fields = buf.fields;
+
+  CVBufferRef cvBufferRef = (struct __CVBuffer *)m_buffers[index].hwDec;
+
+  glEnable(m_textureTarget);
+
+  if (cvBufferRef && fields[m_currentField][0].flipindex != buf.flipindex)
+  {
+
+    // It is the fastest way to render a CVPixelBuffer backed
+    // with an IOSurface as there is no CPU -> GPU upload.
+    CGLContextObj cgl_ctx  = (CGLContextObj)g_Windowing.GetCGLContextObj();
+    IOSurfaceRef	surface  = CVPixelBufferGetIOSurface(cvBufferRef);
+    GLsizei       texWidth = IOSurfaceGetWidth(surface);
+    GLsizei       texHeight= IOSurfaceGetHeight(surface);
+    OSType        format_type = IOSurfaceGetPixelFormat(surface);
+
+    glBindTexture(m_textureTarget, fields[FIELD_FULL][0].id);
+
+    if (format_type == kCVPixelFormatType_422YpCbCr8)
+      CGLTexImageIOSurface2D(cgl_ctx, m_textureTarget, GL_RGBA8,
+                             texWidth / 2, texHeight, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, surface, 0);
+    else if (format_type == kCVPixelFormatType_32BGRA)
+      CGLTexImageIOSurface2D(cgl_ctx, m_textureTarget, GL_RGBA8,
+                             texWidth, texHeight, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, surface, 0);
+
+    glBindTexture(m_textureTarget, 0);
+    fields[FIELD_FULL][0].flipindex = buf.flipindex;
+
+  }
+
+
+  CalculateTextureSourceRects(index, 3);
+  glDisable(m_textureTarget);
+
+  return true;
+}
+
+#endif
\ No newline at end of file
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVDA.h b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDA.h
new file mode 100644
index 0000000000..a170dd66a2
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDA.h
@@ -0,0 +1,54 @@
+/*
+ *      Copyright (C) 2007-2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include "system.h"
+
+#if defined(TARGET_DARWIN_OSX)
+
+#include "cores/VideoRenderers/LinuxRendererGL.h"
+
+class CRendererVDA : public CLinuxRendererGL
+{
+public:
+  CRendererVDA();
+  virtual ~CRendererVDA();
+
+  // Player functions
+  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index);
+  virtual void ReleaseBuffer(int idx);
+
+  // Feature support
+  virtual bool Supports(EINTERLACEMETHOD method);
+  virtual bool Supports(EDEINTERLACEMODE mode);
+
+  virtual EINTERLACEMETHOD AutoInterlaceMethod();
+
+protected:
+  virtual bool LoadShadersHook();
+
+  // textures
+  virtual bool UploadTexture(int index);
+  virtual void DeleteTexture(int index);
+  virtual bool CreateTexture(int index);
+};
+
+#endif
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp
new file mode 100644
index 0000000000..1162b49201
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp
@@ -0,0 +1,418 @@
+/*
+ *      Copyright (C) 2007-2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "RendererVDPAU.h"
+
+#ifdef HAVE_LIBVDPAU
+
+#include "cores/dvdplayer/DVDCodecs/Video/VDPAU.h"
+#include "settings/GUISettings.h"
+#include "settings/AdvancedSettings.h"
+#include "utils/log.h"
+#include "utils/GLUtils.h"
+
+CRendererVDPAU::CRendererVDPAU()
+{
+
+}
+
+CRendererVDPAU::~CRendererVDPAU()
+{
+  for (int i = 0; i < NUM_BUFFERS; ++i)
+  {
+    DeleteTexture(i);
+  }
+}
+
+void CRendererVDPAU::AddVideoPictureHW(DVDVideoPicture &picture, int index)
+{
+  VDPAU::CVdpauRenderPicture *vdpau = picture.vdpau;
+  YUVBUFFER &buf = m_buffers[index];
+  VDPAU::CVdpauRenderPicture *pic = vdpau->Acquire();
+  if (buf.hwDec)
+    ((VDPAU::CVdpauRenderPicture*)buf.hwDec)->Release();
+  buf.hwDec = pic;
+}
+
+void CRendererVDPAU::ReleaseBuffer(int idx)
+{
+  YUVBUFFER &buf = m_buffers[idx];
+  if (buf.hwDec)
+    ((VDPAU::CVdpauRenderPicture*)buf.hwDec)->Release();
+  buf.hwDec = NULL;
+}
+
+CRenderInfo CRendererVDPAU::GetRenderInfo()
+{
+  CRenderInfo info;
+  info.formats = m_formats;
+  info.max_buffer_size = NUM_BUFFERS;
+  info.optimal_buffer_size = 5;
+  return info;
+}
+
+bool CRendererVDPAU::Supports(ERENDERFEATURE feature)
+{
+  if(feature == RENDERFEATURE_BRIGHTNESS ||
+     feature == RENDERFEATURE_CONTRAST)
+  {
+    if ((m_renderMethod & RENDER_VDPAU) && !g_guiSettings.GetBool("videoscreen.limitedrange"))
+      return true;
+
+    return (m_renderMethod & RENDER_GLSL)
+        || (m_renderMethod & RENDER_ARB)
+        || ((m_renderMethod & RENDER_SW) && glewIsSupported("GL_ARB_imaging") == GL_TRUE);
+  }
+  else if (feature == RENDERFEATURE_NOISE ||
+           feature == RENDERFEATURE_SHARPNESS)
+  {
+    if (m_format == RENDER_FMT_VDPAU)
+      return true;
+  }
+  else if (feature == RENDERFEATURE_STRETCH         ||
+           feature == RENDERFEATURE_ZOOM            ||
+           feature == RENDERFEATURE_VERTICAL_SHIFT  ||
+           feature == RENDERFEATURE_PIXEL_RATIO     ||
+           feature == RENDERFEATURE_POSTPROCESS     ||
+           feature == RENDERFEATURE_ROTATION        ||
+           feature == RENDERFEATURE_NONLINSTRETCH)
+    return true;
+
+  return false;
+}
+
+bool CRendererVDPAU::Supports(EINTERLACEMETHOD method)
+{
+  VDPAU::CVdpauRenderPicture *VDPAUPic = (VDPAU::CVdpauRenderPicture*)m_buffers[m_iYV12RenderBuffer].hwDec;
+  if(VDPAUPic && VDPAUPic->vdpau)
+    return VDPAUPic->vdpau->Supports(method);
+  return false;
+}
+
+bool CRendererVDPAU::Supports(ESCALINGMETHOD method)
+{
+  if (m_format == RENDER_FMT_VDPAU_420)
+    return CLinuxRendererGL::Supports(method);
+
+  //nearest neighbor doesn't work on YUY2 and UYVY
+  if (method == VS_SCALINGMETHOD_NEAREST &&
+      m_format != RENDER_FMT_YUYV422 &&
+      m_format != RENDER_FMT_UYVY422)
+    return true;
+
+  if(method == VS_SCALINGMETHOD_LINEAR
+  || method == VS_SCALINGMETHOD_AUTO)
+    return true;
+
+  if(method == VS_SCALINGMETHOD_CUBIC
+  || method == VS_SCALINGMETHOD_LANCZOS2
+  || method == VS_SCALINGMETHOD_SPLINE36_FAST
+  || method == VS_SCALINGMETHOD_LANCZOS3_FAST
+  || method == VS_SCALINGMETHOD_SPLINE36
+  || method == VS_SCALINGMETHOD_LANCZOS3)
+  {
+    // if scaling is below level, avoid hq scaling
+    float scaleX = fabs(((float)m_sourceWidth - m_destRect.Width())/m_sourceWidth)*100;
+    float scaleY = fabs(((float)m_sourceHeight - m_destRect.Height())/m_sourceHeight)*100;
+    int minScale = g_guiSettings.GetInt("videoplayer.hqscalers");
+    if (scaleX < minScale && scaleY < minScale)
+      return false;
+
+    // spline36 and lanczos3 are only allowed through advancedsettings.xml
+    if(method != VS_SCALINGMETHOD_SPLINE36
+        && method != VS_SCALINGMETHOD_LANCZOS3)
+      return true;
+    else
+      return g_advancedSettings.m_videoEnableHighQualityHwScalers;
+  }
+
+  return false;
+}
+
+bool CRendererVDPAU::LoadShadersHook()
+{
+  if (m_format == RENDER_FMT_VDPAU)
+  {
+    CLog::Log(LOGNOTICE, "GL: Using VDPAU render method");
+    m_renderMethod = RENDER_VDPAU;
+    return true;
+  }
+  return false;
+}
+
+bool CRendererVDPAU::RenderHook(int idx)
+{
+  UpdateVideoFilter();
+
+  if (m_format == RENDER_FMT_VDPAU_420)
+  {
+    switch(m_renderQuality)
+    {
+    case RQ_LOW:
+    case RQ_SINGLEPASS:
+      if (m_currentField == FIELD_FULL)
+        RenderProgressiveWeave(idx, m_currentField);
+      else
+        RenderSinglePass(idx, m_currentField);
+      VerifyGLState();
+      break;
+
+    case RQ_MULTIPASS:
+      if (m_currentField == FIELD_FULL)
+        RenderProgressiveWeave(idx, m_currentField);
+      else
+      {
+        RenderToFBO(idx, m_currentField);
+        RenderFromFBO();
+      }
+      VerifyGLState();
+      break;
+    }
+  }
+  else
+  {
+    RenderRGB(idx, m_currentField);
+  }
+
+  YUVBUFFER &buf = m_buffers[idx];
+  if (buf.hwDec)
+  {
+    ((VDPAU::CVdpauRenderPicture*)buf.hwDec)->Sync();
+  }
+  return true;
+}
+
+bool CRendererVDPAU::CreateTexture(int index)
+{
+  if (m_format == RENDER_FMT_VDPAU)
+    return CreateVDPAUTexture(index);
+  else if (m_format == RENDER_FMT_VDPAU_420)
+    return CreateVDPAUTexture420(index);
+  else
+    return false;
+}
+
+void CRendererVDPAU::DeleteTexture(int index)
+{
+  if (m_format == RENDER_FMT_VDPAU)
+    DeleteVDPAUTexture(index);
+  else if (m_format == RENDER_FMT_VDPAU_420)
+    DeleteVDPAUTexture420(index);
+}
+
+bool CRendererVDPAU::UploadTexture(int index)
+{
+  if (m_format == RENDER_FMT_VDPAU)
+    return UploadVDPAUTexture(index);
+  else if (m_format == RENDER_FMT_VDPAU_420)
+    return UploadVDPAUTexture420(index);
+  else
+    return false;
+}
+
+bool CRendererVDPAU::CreateVDPAUTexture(int index)
+{
+  YV12Image &im     = m_buffers[index].image;
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE  &plane  = fields[FIELD_FULL][0];
+
+  DeleteVDPAUTexture(index);
+
+  memset(&im    , 0, sizeof(im));
+  memset(&fields, 0, sizeof(fields));
+  im.height = m_sourceHeight;
+  im.width  = m_sourceWidth;
+
+  plane.texwidth  = im.width;
+  plane.texheight = im.height;
+
+  plane.pixpertex_x = 1;
+  plane.pixpertex_y = 1;
+
+  plane.id = 1;
+  return true;
+}
+
+void CRendererVDPAU::DeleteVDPAUTexture(int index)
+{
+  YUVPLANE &plane = m_buffers[index].fields[FIELD_FULL][0];
+
+  if (m_buffers[index].hwDec)
+    ((VDPAU::CVdpauRenderPicture*)m_buffers[index].hwDec)->Release();
+  m_buffers[index].hwDec = NULL;
+
+  plane.id = 0;
+}
+
+bool CRendererVDPAU::UploadVDPAUTexture(int index)
+{
+  VDPAU::CVdpauRenderPicture *vdpau = (VDPAU::CVdpauRenderPicture*)m_buffers[index].hwDec;
+
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE &plane = fields[FIELD_FULL][0];
+
+  if (!vdpau || !vdpau->valid)
+  {
+    return false;
+  }
+
+  plane.id = vdpau->texture[0];
+
+  // in stereoscopic mode sourceRect may only
+  // be a part of the source video surface
+  plane.rect = m_sourceRect;
+
+  // clip rect
+  if (vdpau->crop.x1 > plane.rect.x1)
+    plane.rect.x1 = vdpau->crop.x1;
+  if (vdpau->crop.x2 < plane.rect.x2)
+    plane.rect.x2 = vdpau->crop.x2;
+  if (vdpau->crop.y1 > plane.rect.y1)
+    plane.rect.y1 = vdpau->crop.y1;
+  if (vdpau->crop.y2 < plane.rect.y2)
+    plane.rect.y2 = vdpau->crop.y2;
+
+  plane.texheight = vdpau->texHeight;
+  plane.texwidth  = vdpau->texWidth;
+
+  if (m_textureTarget == GL_TEXTURE_2D)
+  {
+    plane.rect.y1 /= plane.texheight;
+    plane.rect.y2 /= plane.texheight;
+    plane.rect.x1 /= plane.texwidth;
+    plane.rect.x2 /= plane.texwidth;
+  }
+
+  return true;
+}
+
+bool CRendererVDPAU::CreateVDPAUTexture420(int index)
+{
+  YV12Image &im     = m_buffers[index].image;
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE &plane = fields[0][0];
+  GLuint    *pbo    = m_buffers[index].pbo;
+
+  DeleteVDPAUTexture420(index);
+
+  memset(&im    , 0, sizeof(im));
+  memset(&fields, 0, sizeof(fields));
+
+  im.cshift_x = 1;
+  im.cshift_y = 1;
+
+  im.plane[0] = NULL;
+  im.plane[1] = NULL;
+  im.plane[2] = NULL;
+
+  for(int p=0; p<3; p++)
+  {
+    pbo[p] = None;
+  }
+
+  plane.id = 1;
+
+  return true;
+}
+
+void CRendererVDPAU::DeleteVDPAUTexture420(int index)
+{
+  YUVFIELDS &fields = m_buffers[index].fields;
+
+  if (m_buffers[index].hwDec)
+    ((VDPAU::CVdpauRenderPicture*)m_buffers[index].hwDec)->Release();
+  m_buffers[index].hwDec = NULL;
+
+  fields[0][0].id = 0;
+  fields[1][0].id = 0;
+  fields[1][1].id = 0;
+  fields[2][0].id = 0;
+  fields[2][1].id = 0;
+}
+
+bool CRendererVDPAU::UploadVDPAUTexture420(int index)
+{
+  VDPAU::CVdpauRenderPicture *vdpau = (VDPAU::CVdpauRenderPicture*)m_buffers[index].hwDec;
+  YV12Image &im = m_buffers[index].image;
+
+  YUVFIELDS &fields = m_buffers[index].fields;
+
+  if (!vdpau || !vdpau->valid)
+  {
+    return false;
+  }
+
+  im.height = vdpau->texHeight;
+  im.width  = vdpau->texWidth;
+
+  // YUV
+  for (int f = FIELD_TOP; f<=FIELD_BOT ; f++)
+  {
+    YUVPLANES &planes = fields[f];
+
+    planes[0].texwidth  = im.width;
+    planes[0].texheight = im.height >> 1;
+
+    planes[1].texwidth  = planes[0].texwidth  >> im.cshift_x;
+    planes[1].texheight = planes[0].texheight >> im.cshift_y;
+    planes[2].texwidth  = planes[1].texwidth;
+    planes[2].texheight = planes[1].texheight;
+
+    for (int p = 0; p < 3; p++)
+    {
+      planes[p].pixpertex_x = 1;
+      planes[p].pixpertex_y = 1;
+    }
+  }
+  // crop
+//  m_sourceRect.x1 += vdpau->crop.x1;
+//  m_sourceRect.x2 -= vdpau->crop.x2;
+//  m_sourceRect.y1 += vdpau->crop.y1;
+//  m_sourceRect.y2 -= vdpau->crop.y2;
+
+  // set textures
+  fields[1][0].id = vdpau->texture[0];
+  fields[1][1].id = vdpau->texture[2];
+  fields[1][2].id = vdpau->texture[2];
+  fields[2][0].id = vdpau->texture[1];
+  fields[2][1].id = vdpau->texture[3];
+  fields[2][2].id = vdpau->texture[3];
+
+  glEnable(m_textureTarget);
+  for (int f = FIELD_TOP; f <= FIELD_BOT; f++)
+  {
+    for (int p=0; p<2; p++)
+    {
+      glBindTexture(m_textureTarget,fields[f][p].id);
+      glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+      glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+
+      glBindTexture(m_textureTarget,0);
+      VerifyGLState();
+    }
+  }
+  CalculateTextureSourceRects(index, 3);
+  glDisable(m_textureTarget);
+  return true;
+}
+
+#endif
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.h b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.h
new file mode 100644
index 0000000000..55ab570993
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.h
@@ -0,0 +1,64 @@
+/*
+ *      Copyright (C) 2007-2015 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include "system.h"
+
+#ifdef HAVE_LIBVDPAU
+
+#include "cores/VideoRenderers/LinuxRendererGL.h"
+
+class CRendererVDPAU : public CLinuxRendererGL
+{
+public:
+  CRendererVDPAU();
+  virtual ~CRendererVDPAU();
+
+  // Player functions
+  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index);
+  virtual void ReleaseBuffer(int idx);
+  virtual CRenderInfo GetRenderInfo();
+
+  // Feature support
+  virtual bool Supports(ERENDERFEATURE feature);
+  virtual bool Supports(EINTERLACEMETHOD method);
+  virtual bool Supports(ESCALINGMETHOD method);
+
+protected:
+  virtual bool LoadShadersHook();
+  virtual bool RenderHook(int idx);
+
+  // textures
+  virtual bool UploadTexture(int index);
+  virtual void DeleteTexture(int index);
+  virtual bool CreateTexture(int index);
+
+  bool CreateVDPAUTexture(int index);
+  void DeleteVDPAUTexture(int index);
+  bool UploadVDPAUTexture(int index);
+
+  bool CreateVDPAUTexture420(int index);
+  void DeleteVDPAUTexture420(int index);
+  bool UploadVDPAUTexture420(int index);
+};
+
+#endif
+
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 29f3a8d6f3..be9df52dab 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -53,20 +53,11 @@ extern "C" {
 #include "libswscale/swscale.h"
 }
 
-#ifdef HAVE_LIBVDPAU
-#include "cores/dvdplayer/DVDCodecs/Video/VDPAU.h"
-#endif
-#ifdef HAVE_LIBVA
-#include "cores/dvdplayer/DVDCodecs/Video/VAAPI.h"
-#endif
-
-#ifdef TARGET_DARWIN
-  #include "osx/CocoaInterface.h"
-  #include <CoreVideo/CoreVideo.h>
-  #include <OpenGL/CGLIOSurface.h>
-  #ifdef TARGET_DARWIN_OSX
-    #include "osx/DarwinUtils.h"
-  #endif
+#ifdef TARGET_DARWIN_OSX
+#include "osx/CocoaInterface.h"
+#include <CoreVideo/CoreVideo.h>
+#include <OpenGL/CGLIOSurface.h>
+#include "osx/DarwinUtils.h"
 #endif
 
 //due to a bug on osx nvidia, using gltexsubimage2d with a pbo bound and a null pointer
@@ -118,23 +109,12 @@ CLinuxRendererGL::YUVBUFFER::YUVBUFFER()
   memset(&image , 0, sizeof(image));
   memset(&pbo   , 0, sizeof(pbo));
   flipindex = 0;
-#ifdef HAVE_LIBVDPAU
-  vdpau = NULL;
-#endif
-#ifdef HAVE_LIBVA
-  vaapi = NULL;
-#endif
-#ifdef TARGET_DARWIN_OSX
-  cvBufferRef = NULL;
-#endif
+  hwDec = NULL;
 }
 
 CLinuxRendererGL::YUVBUFFER::~YUVBUFFER()
 {
-#ifdef TARGET_DARWIN_OSX
-  if (cvBufferRef)
-    CVBufferRelease(cvBufferRef);
-#endif
+
 }
 
 CLinuxRendererGL::CLinuxRendererGL()
@@ -155,11 +135,6 @@ CLinuxRendererGL::CLinuxRendererGL()
   m_scalingMethod = VS_SCALINGMETHOD_LINEAR;
   m_scalingMethodGui = (ESCALINGMETHOD)-1;
 
-  // default texture handlers to YUV
-  m_textureUpload = &CLinuxRendererGL::UploadYV12Texture;
-  m_textureCreate = &CLinuxRendererGL::CreateYV12Texture;
-  m_textureDelete = &CLinuxRendererGL::DeleteYV12Texture;
-
   m_rgbBuffer = NULL;
   m_rgbBufferSize = 0;
   m_context = NULL;
@@ -223,7 +198,7 @@ bool CLinuxRendererGL::ValidateRenderer()
     return false;
 
   int index = m_iYV12RenderBuffer;
-  YUVBUFFER& buf =  m_buffers[index];
+  YUVBUFFER& buf = m_buffers[index];
 
   if (!buf.fields[FIELD_FULL][0].id)
     return false;
@@ -238,20 +213,16 @@ bool CLinuxRendererGL::ValidateRenderTarget()
 {
   if (!m_bValidated)
   {
-    if ((m_format == RENDER_FMT_CVBREF) ||
-        (!glewIsSupported("GL_ARB_texture_non_power_of_two") && glewIsSupported("GL_ARB_texture_rectangle")))
+    if (!glewIsSupported("GL_ARB_texture_non_power_of_two") && glewIsSupported("GL_ARB_texture_rectangle"))
     {
-      CLog::Log(LOGNOTICE,"Using GL_TEXTURE_RECTANGLE_ARB");
       m_textureTarget = GL_TEXTURE_RECTANGLE_ARB;
     }
-    else
-      CLog::Log(LOGNOTICE,"Using GL_TEXTURE_2D");
 
     // function pointer for texture might change in
     // call to LoadShaders
     glFinish();
     for (int i = 0 ; i < NUM_BUFFERS ; i++)
-      (this->*m_textureDelete)(i);
+      DeleteTexture(i);
 
     // trigger update of video filters
     m_scalingMethodGui = (ESCALINGMETHOD)-1;
@@ -259,8 +230,13 @@ bool CLinuxRendererGL::ValidateRenderTarget()
      // create the yuv textures
     LoadShaders();
 
+    if (m_textureTarget == GL_TEXTURE_RECTANGLE_ARB)
+      CLog::Log(LOGNOTICE,"Using GL_TEXTURE_RECTANGLE_ARB");
+    else
+      CLog::Log(LOGNOTICE,"Using GL_TEXTURE_2D");
+
     for (int i = 0 ; i < m_NumYV12Buffers ; i++)
-      (this->*m_textureCreate)(i);
+      CreateTexture(i);
 
     m_bValidated = true;
     return true;
@@ -327,8 +303,11 @@ int CLinuxRendererGL::NextYV12Texture()
 
 int CLinuxRendererGL::GetImage(YV12Image *image, int source, bool readonly)
 {
-  if (!image) return -1;
-  if (!m_bValidated) return -1;
+  if (!image)
+    return -1;
+
+  if (!m_bValidated)
+    return -1;
 
   /* take next available buffer */
   if( source == AUTOSOURCE )
@@ -538,7 +517,7 @@ void CLinuxRendererGL::Flush()
   glFinish();
 
   for (int i = 0 ; i < m_NumYV12Buffers ; i++)
-    (this->*m_textureDelete)(i);
+    DeleteTexture(i);
 
   glFinish();
   m_bValidated = false;
@@ -546,24 +525,6 @@ void CLinuxRendererGL::Flush()
   m_iYV12RenderBuffer = 0;
 }
 
-void CLinuxRendererGL::ReleaseBuffer(int idx)
-{
-#if defined(HAVE_LIBVDPAU) || defined(HAVE_LIBVA) || defined(TARGET_DARWIN)
-  YUVBUFFER &buf = m_buffers[idx];
-#endif
-#ifdef HAVE_LIBVDPAU
-  SAFE_RELEASE(buf.vdpau);
-#endif
-#ifdef HAVE_LIBVA
-  SAFE_RELEASE(buf.vaapi);
-#endif
-#ifdef TARGET_DARWIN
-  if (buf.cvBufferRef)
-    CVBufferRelease(buf.cvBufferRef);
-  buf.cvBufferRef = NULL;
-#endif
-}
-
 void CLinuxRendererGL::Update()
 {
   if (!m_bConfigured) return;
@@ -712,7 +673,7 @@ void CLinuxRendererGL::FlipPage(int source)
   return;
 }
 
-unsigned int CLinuxRendererGL::PreInit()
+void CLinuxRendererGL::PreInit()
 {
   CSingleLock lock(g_graphicsContext);
   m_bConfigured = false;
@@ -754,14 +715,9 @@ unsigned int CLinuxRendererGL::PreInit()
   m_formats.push_back(RENDER_FMT_NV12);
   m_formats.push_back(RENDER_FMT_YUYV422);
   m_formats.push_back(RENDER_FMT_UYVY422);
-#ifdef TARGET_DARWIN
-  m_formats.push_back(RENDER_FMT_CVBREF);
-#endif
 
   // setup the background colour
   m_clearColour = (float)(g_advancedSettings.m_videoBlackBarColour & 0xff) / 0xff;
-
-  return true;
 }
 
 void CLinuxRendererGL::UpdateVideoFilter()
@@ -833,7 +789,7 @@ void CLinuxRendererGL::UpdateVideoFilter()
   case VS_SCALINGMETHOD_LINEAR:
     SetTextureFilter(m_scalingMethod == VS_SCALINGMETHOD_NEAREST ? GL_NEAREST : GL_LINEAR);
     m_renderQuality = RQ_SINGLEPASS;
-    if (((m_renderMethod & RENDER_VDPAU) || (m_renderMethod & RENDER_VAAPI)) && m_nonLinStretch)
+    if (Supports(RENDERFEATURE_NONLINSTRETCH) && m_nonLinStretch)
     {
       m_pVideoFilterShader = new StretchFilterShader();
       if (!m_pVideoFilterShader->CompileAndLink())
@@ -912,17 +868,7 @@ void CLinuxRendererGL::UpdateVideoFilter()
 
 void CLinuxRendererGL::LoadShaders(int field)
 {
-  if (m_format == RENDER_FMT_VDPAU)
-  {
-    CLog::Log(LOGNOTICE, "GL: Using VDPAU render method");
-    m_renderMethod = RENDER_VDPAU;
-  }
-  else if (m_format == RENDER_FMT_VAAPI)
-  {
-    CLog::Log(LOGNOTICE, "GL: Using VAAPI render method");
-    m_renderMethod = RENDER_VAAPI;
-  }
-  else
+  if (!LoadShadersHook())
   {
     int requestedMethod = g_guiSettings.GetInt("videoplayer.rendermethod");
     CLog::Log(LOGDEBUG, "GL: Requested render method: %d", requestedMethod);
@@ -1006,13 +952,6 @@ void CLinuxRendererGL::LoadShaders(int field)
     }
   }
 
-  /* cvbref format piggy back on normal glsl */
-  if (m_format == RENDER_FMT_CVBREF)
-  {
-    CLog::Log(LOGNOTICE, "GL: Using CVBREF render method");
-    m_renderMethod |= RENDER_CVREF;
-  }
-
   // determine whether GPU supports NPOT textures
   if (!glewIsSupported("GL_ARB_texture_non_power_of_two"))
   {
@@ -1038,57 +977,6 @@ void CLinuxRendererGL::LoadShaders(int field)
   }
   else
     m_pboUsed = false;
-
-  // Now that we now the render method, setup texture function handlers
-  if (m_format == RENDER_FMT_NV12 ||
-      m_format == RENDER_FMT_VAAPINV12)
-  {
-    m_textureUpload = &CLinuxRendererGL::UploadNV12Texture;
-    m_textureCreate = &CLinuxRendererGL::CreateNV12Texture;
-    m_textureDelete = &CLinuxRendererGL::DeleteNV12Texture;
-  }
-  else if (m_format == RENDER_FMT_YUYV422 ||
-           m_format == RENDER_FMT_UYVY422)
-  {
-    m_textureUpload = &CLinuxRendererGL::UploadYUV422PackedTexture;
-    m_textureCreate = &CLinuxRendererGL::CreateYUV422PackedTexture;
-    m_textureDelete = &CLinuxRendererGL::DeleteYUV422PackedTexture;
-  }
-  else if (m_format == RENDER_FMT_VDPAU)
-  {
-    m_textureUpload = &CLinuxRendererGL::UploadVDPAUTexture;
-    m_textureCreate = &CLinuxRendererGL::CreateVDPAUTexture;
-    m_textureDelete = &CLinuxRendererGL::DeleteVDPAUTexture;
-  }
-  else if (m_format == RENDER_FMT_VDPAU_420)
-  {
-    m_textureUpload = &CLinuxRendererGL::UploadVDPAUTexture420;
-    m_textureCreate = &CLinuxRendererGL::CreateVDPAUTexture420;
-    m_textureDelete = &CLinuxRendererGL::DeleteVDPAUTexture420;
-  }
-  else if (m_format == RENDER_FMT_VAAPI)
-  {
-    m_textureUpload = &CLinuxRendererGL::UploadVAAPITexture;
-    m_textureCreate = &CLinuxRendererGL::CreateVAAPITexture;
-    m_textureDelete = &CLinuxRendererGL::DeleteVAAPITexture;
-  }
-  else if (m_format == RENDER_FMT_CVBREF)
-  {
-    m_textureUpload = &CLinuxRendererGL::UploadCVRefTexture;
-    m_textureCreate = &CLinuxRendererGL::CreateCVRefTexture;
-    m_textureDelete = &CLinuxRendererGL::DeleteCVRefTexture;
-  }
-  else
-  {
-    // setup default YV12 texture handlers
-    m_textureUpload = &CLinuxRendererGL::UploadYV12Texture;
-    m_textureCreate = &CLinuxRendererGL::CreateYV12Texture;
-    m_textureDelete = &CLinuxRendererGL::DeleteYV12Texture;
-  }
-
-  //in case of software colorspace conversion, all formats are handled by the same method
-  if (m_renderMethod & RENDER_SW)
-    m_textureUpload = &CLinuxRendererGL::UploadRGBTexture;
 }
 
 void CLinuxRendererGL::UnInit()
@@ -1120,8 +1008,7 @@ void CLinuxRendererGL::UnInit()
   // YV12 textures
   for (int i = 0; i < NUM_BUFFERS; ++i)
   {
-    (this->*m_textureDelete)(i);
-    DeleteVAAPITexture(i);
+    DeleteTexture(i);
   }
 
   // cleanup framebuffer object if it was in use
@@ -1144,31 +1031,25 @@ void CLinuxRendererGL::Render(DWORD flags, int renderBuffer)
     m_currentField = FIELD_FULL;
 
   // call texture load function
-  if (!(this->*m_textureUpload)(renderBuffer))
+  if (!UploadTexture(renderBuffer))
     return;
 
-  if (m_renderMethod & RENDER_GLSL)
+  if (RenderHook(renderBuffer))
+    ;
+  else if (m_renderMethod & RENDER_GLSL)
   {
     UpdateVideoFilter();
     switch(m_renderQuality)
     {
     case RQ_LOW:
     case RQ_SINGLEPASS:
-      if (m_format == RENDER_FMT_VDPAU_420 && m_currentField == FIELD_FULL)
-        RenderProgressiveWeave(renderBuffer, m_currentField);
-      else
-        RenderSinglePass(renderBuffer, m_currentField);
+      RenderSinglePass(renderBuffer, m_currentField);
       VerifyGLState();
       break;
 
     case RQ_MULTIPASS:
-      if (m_format == RENDER_FMT_VDPAU_420 && m_currentField == FIELD_FULL)
-        RenderProgressiveWeave(renderBuffer, m_currentField);
-      else
-      {
-        RenderToFBO(renderBuffer, m_currentField);
-        RenderFromFBO();
-      }
+      RenderToFBO(renderBuffer, m_currentField);
+      RenderFromFBO();
       VerifyGLState();
       break;
     }
@@ -1177,46 +1058,11 @@ void CLinuxRendererGL::Render(DWORD flags, int renderBuffer)
   {
     RenderSinglePass(renderBuffer, m_currentField);
   }
-#ifdef HAVE_LIBVDPAU
-  else if (m_renderMethod & RENDER_VDPAU)
-  {
-    UpdateVideoFilter();
-    RenderRGB(renderBuffer, m_currentField);
-  }
-#endif
-#ifdef HAVE_LIBVA
-  else if (m_renderMethod & RENDER_VAAPI)
-  {
-    UpdateVideoFilter();
-    RenderRGB(renderBuffer, m_currentField);
-  }
-#endif
   else
   {
     RenderSoftware(renderBuffer, m_currentField);
     VerifyGLState();
   }
-
-#ifdef HAVE_LIBVDPAU
-  if (m_format == RENDER_FMT_VDPAU || m_format == RENDER_FMT_VDPAU_420)
-  {
-    YUVBUFFER &buf = m_buffers[renderBuffer];
-    if (buf.vdpau)
-    {
-      buf.vdpau->Sync();
-    }
-  }
-#endif
-#ifdef HAVE_LIBVA
-  if (m_format == RENDER_FMT_VAAPI)
-  {
-    YUVBUFFER &buf = m_buffers[renderBuffer];
-    if (buf.vaapi)
-    {
-      buf.vaapi->Sync();
-    }
-  }
-#endif
 }
 
 void CLinuxRendererGL::RenderSinglePass(int index, int field)
@@ -1556,7 +1402,6 @@ void CLinuxRendererGL::RenderProgressiveWeave(int index, int field)
 
 void CLinuxRendererGL::RenderRGB(int index, int field)
 {
-#if defined(HAVE_LIBVDPAU) || defined(HAVE_LIBVA)
   YUVPLANE &plane = m_buffers[index].fields[FIELD_FULL][0];
 
   glEnable(m_textureTarget);
@@ -1625,7 +1470,6 @@ void CLinuxRendererGL::RenderRGB(int index, int field)
 
   glBindTexture (m_textureTarget, 0);
   glDisable(m_textureTarget);
-#endif
 }
 
 void CLinuxRendererGL::RenderSoftware(int index, int field)
@@ -1704,132 +1548,6 @@ bool CLinuxRendererGL::RenderCapture(CRenderCapture* capture)
   return true;
 }
 
-//********************************************************************************************************
-// YV12 Texture creation, deletion, copying + clearing
-//********************************************************************************************************
-bool CLinuxRendererGL::UploadYV12Texture(int source)
-{
-  YUVBUFFER& buf    =  m_buffers[source];
-  YV12Image* im     = &buf.image;
-  YUVFIELDS& fields =  buf.fields;
-
-  if (!(im->flags&IMAGE_FLAG_READY))
-    return false;
-  bool deinterlacing;
-  if (m_currentField == FIELD_FULL)
-    deinterlacing = false;
-  else
-    deinterlacing = true;
-
-  glEnable(m_textureTarget);
-  VerifyGLState();
-
-  glPixelStorei(GL_UNPACK_ALIGNMENT,1);
-
-  if (deinterlacing)
-  {
-    // Load Even Y Field
-    LoadPlane( fields[FIELD_TOP][0] , GL_LUMINANCE, buf.flipindex
-             , im->width, im->height >> 1
-             , im->stride[0]*2, im->bpp, im->plane[0] );
-
-    //load Odd Y Field
-    LoadPlane( fields[FIELD_BOT][0], GL_LUMINANCE, buf.flipindex
-             , im->width, im->height >> 1
-             , im->stride[0]*2, im->bpp, im->plane[0] + im->stride[0]) ;
-
-    // Load Even U & V Fields
-    LoadPlane( fields[FIELD_TOP][1], GL_LUMINANCE, buf.flipindex
-             , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
-             , im->stride[1]*2, im->bpp, im->plane[1] );
-
-    LoadPlane( fields[FIELD_TOP][2], GL_ALPHA, buf.flipindex
-             , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
-             , im->stride[2]*2, im->bpp, im->plane[2] );
-
-    // Load Odd U & V Fields
-    LoadPlane( fields[FIELD_BOT][1], GL_LUMINANCE, buf.flipindex
-             , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
-             , im->stride[1]*2, im->bpp, im->plane[1] + im->stride[1] );
-
-    LoadPlane( fields[FIELD_BOT][2], GL_ALPHA, buf.flipindex
-             , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
-             , im->stride[2]*2, im->bpp, im->plane[2] + im->stride[2] );
-  }
-  else
-  {
-    //Load Y plane
-    LoadPlane( fields[FIELD_FULL][0], GL_LUMINANCE, buf.flipindex
-             , im->width, im->height
-             , im->stride[0], im->bpp, im->plane[0] );
-
-    //load U plane
-    LoadPlane( fields[FIELD_FULL][1], GL_LUMINANCE, buf.flipindex
-             , im->width >> im->cshift_x, im->height >> im->cshift_y
-             , im->stride[1], im->bpp, im->plane[1] );
-
-    //load V plane
-    LoadPlane( fields[FIELD_FULL][2], GL_ALPHA, buf.flipindex
-             , im->width >> im->cshift_x, im->height >> im->cshift_y
-             , im->stride[2], im->bpp, im->plane[2] );
-  }
-
-  VerifyGLState();
-
-  CalculateTextureSourceRects(source, 3);
-
-  glDisable(m_textureTarget);
-  return true;
-}
-
-void CLinuxRendererGL::DeleteYV12Texture(int index)
-{
-  YV12Image &im     = m_buffers[index].image;
-  YUVFIELDS &fields = m_buffers[index].fields;
-  GLuint    *pbo    = m_buffers[index].pbo;
-
-  if( fields[FIELD_FULL][0].id == 0 ) return;
-
-  /* finish up all textures, and delete them */
-  g_graphicsContext.BeginPaint();  //FIXME
-  for(int f = 0;f<MAX_FIELDS;f++)
-  {
-    for(int p = 0;p<MAX_PLANES;p++)
-    {
-      if( fields[f][p].id )
-      {
-        if (glIsTexture(fields[f][p].id))
-          glDeleteTextures(1, &fields[f][p].id);
-        fields[f][p].id = 0;
-      }
-    }
-  }
-  g_graphicsContext.EndPaint();
-
-  for(int p = 0;p<MAX_PLANES;p++)
-  {
-    if (pbo[p])
-    {
-      if (im.plane[p])
-      {
-        glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, pbo[p]);
-        glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB);
-        im.plane[p] = NULL;
-        glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0);
-      }
-      glDeleteBuffersARB(1, pbo + p);
-      pbo[p] = 0;
-    }
-    else
-    {
-      if (im.plane[p])
-      {
-        delete[] im.plane[p];
-        im.plane[p] = NULL;
-      }
-    }
-  }
-}
 
 static GLint GetInternalFormat(GLint format, int bpp)
 {
@@ -1850,6 +1568,52 @@ static GLint GetInternalFormat(GLint format, int bpp)
     return format;
 }
 
+//-----------------------------------------------------------------------------
+// Textures
+//-----------------------------------------------------------------------------
+
+bool CLinuxRendererGL::CreateTexture(int index)
+{
+  if (m_format == RENDER_FMT_NV12)
+    return CreateNV12Texture(index);
+  else if (m_format == RENDER_FMT_YUYV422 ||
+           m_format == RENDER_FMT_UYVY422)
+    return CreateYUV422PackedTexture(index);
+  else
+    return CreateYV12Texture(index);
+}
+
+void CLinuxRendererGL::DeleteTexture(int index)
+{
+  if (m_format == RENDER_FMT_NV12)
+    DeleteNV12Texture(index);
+  else if (m_format == RENDER_FMT_YUYV422 ||
+           m_format == RENDER_FMT_UYVY422)
+    DeleteYUV422PackedTexture(index);
+  else
+    DeleteYV12Texture(index);
+}
+
+bool CLinuxRendererGL::UploadTexture(int index)
+{
+  if (m_format == RENDER_FMT_NV12)
+    return UploadNV12Texture(index);
+  else if (m_format == RENDER_FMT_YUYV422 ||
+           m_format == RENDER_FMT_UYVY422)
+    return UploadYUV422PackedTexture(index);
+  //in case of software colorspace conversion, all formats are handled by the same method
+  else if (m_renderMethod & RENDER_SW)
+    return UploadRGBTexture(index);
+  else
+    return UploadYV12Texture(index);
+
+  return false;
+}
+
+//********************************************************************************************************
+// YV12 Texture creation, deletion, copying + clearing
+//********************************************************************************************************
+
 bool CLinuxRendererGL::CreateYV12Texture(int index)
 {
   /* since we also want the field textures, pitch must be texture aligned */
@@ -2013,16 +1777,13 @@ bool CLinuxRendererGL::CreateYV12Texture(int index)
   return true;
 }
 
-//********************************************************************************************************
-// NV12 Texture loading, creation and deletion
-//********************************************************************************************************
-bool CLinuxRendererGL::UploadNV12Texture(int source)
+bool CLinuxRendererGL::UploadYV12Texture(int source)
 {
   YUVBUFFER& buf    =  m_buffers[source];
   YV12Image* im     = &buf.image;
   YUVFIELDS& fields =  buf.fields;
 
-  if (!(im->flags & IMAGE_FLAG_READY))
+  if (!(im->flags&IMAGE_FLAG_READY))
     return false;
   bool deinterlacing;
   if (m_currentField == FIELD_FULL)
@@ -2033,29 +1794,156 @@ bool CLinuxRendererGL::UploadNV12Texture(int source)
   glEnable(m_textureTarget);
   VerifyGLState();
 
-  glPixelStorei(GL_UNPACK_ALIGNMENT, im->bpp);
+  glPixelStorei(GL_UNPACK_ALIGNMENT,1);
 
   if (deinterlacing)
   {
-    // Load Odd Y field
+    // Load Even Y Field
     LoadPlane( fields[FIELD_TOP][0] , GL_LUMINANCE, buf.flipindex
              , im->width, im->height >> 1
              , im->stride[0]*2, im->bpp, im->plane[0] );
 
-    // Load Even Y field
+    //load Odd Y Field
     LoadPlane( fields[FIELD_BOT][0], GL_LUMINANCE, buf.flipindex
              , im->width, im->height >> 1
              , im->stride[0]*2, im->bpp, im->plane[0] + im->stride[0]) ;
 
-    // Load Odd UV Fields
-    LoadPlane( fields[FIELD_TOP][1], GL_LUMINANCE_ALPHA, buf.flipindex
+    // Load Even U & V Fields
+    LoadPlane( fields[FIELD_TOP][1], GL_LUMINANCE, buf.flipindex
              , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
              , im->stride[1]*2, im->bpp, im->plane[1] );
 
-    // Load Even UV Fields
-    LoadPlane( fields[FIELD_BOT][1], GL_LUMINANCE_ALPHA, buf.flipindex
+    LoadPlane( fields[FIELD_TOP][2], GL_ALPHA, buf.flipindex
              , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
-             , im->stride[1]*2, im->bpp, im->plane[1] + im->stride[1] );
+             , im->stride[2]*2, im->bpp, im->plane[2] );
+
+    // Load Odd U & V Fields
+    LoadPlane( fields[FIELD_BOT][1], GL_LUMINANCE, buf.flipindex
+             , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
+             , im->stride[1]*2, im->bpp, im->plane[1] + im->stride[1] );
+
+    LoadPlane( fields[FIELD_BOT][2], GL_ALPHA, buf.flipindex
+             , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
+             , im->stride[2]*2, im->bpp, im->plane[2] + im->stride[2] );
+  }
+  else
+  {
+    //Load Y plane
+    LoadPlane( fields[FIELD_FULL][0], GL_LUMINANCE, buf.flipindex
+             , im->width, im->height
+             , im->stride[0], im->bpp, im->plane[0] );
+
+    //load U plane
+    LoadPlane( fields[FIELD_FULL][1], GL_LUMINANCE, buf.flipindex
+             , im->width >> im->cshift_x, im->height >> im->cshift_y
+             , im->stride[1], im->bpp, im->plane[1] );
+
+    //load V plane
+    LoadPlane( fields[FIELD_FULL][2], GL_ALPHA, buf.flipindex
+             , im->width >> im->cshift_x, im->height >> im->cshift_y
+             , im->stride[2], im->bpp, im->plane[2] );
+  }
+
+  VerifyGLState();
+
+  CalculateTextureSourceRects(source, 3);
+
+  glDisable(m_textureTarget);
+  return true;
+}
+
+void CLinuxRendererGL::DeleteYV12Texture(int index)
+{
+  YV12Image &im     = m_buffers[index].image;
+  YUVFIELDS &fields = m_buffers[index].fields;
+  GLuint    *pbo    = m_buffers[index].pbo;
+
+  if( fields[FIELD_FULL][0].id == 0 ) return;
+
+  /* finish up all textures, and delete them */
+  g_graphicsContext.BeginPaint();  //FIXME
+  for(int f = 0;f<MAX_FIELDS;f++)
+  {
+    for(int p = 0;p<MAX_PLANES;p++)
+    {
+      if( fields[f][p].id )
+      {
+        if (glIsTexture(fields[f][p].id))
+          glDeleteTextures(1, &fields[f][p].id);
+        fields[f][p].id = 0;
+      }
+    }
+  }
+  g_graphicsContext.EndPaint();
+
+  for(int p = 0;p<MAX_PLANES;p++)
+  {
+    if (pbo[p])
+    {
+      if (im.plane[p])
+      {
+        glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, pbo[p]);
+        glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB);
+        im.plane[p] = NULL;
+        glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0);
+      }
+      glDeleteBuffersARB(1, pbo + p);
+      pbo[p] = 0;
+    }
+    else
+    {
+      if (im.plane[p])
+      {
+        delete[] im.plane[p];
+        im.plane[p] = NULL;
+      }
+    }
+  }
+}
+
+//********************************************************************************************************
+// NV12 Texture loading, creation and deletion
+//********************************************************************************************************
+bool CLinuxRendererGL::UploadNV12Texture(int source)
+{
+  YUVBUFFER& buf    =  m_buffers[source];
+  YV12Image* im     = &buf.image;
+  YUVFIELDS& fields =  buf.fields;
+
+  if (!(im->flags & IMAGE_FLAG_READY))
+    return false;
+  bool deinterlacing;
+  if (m_currentField == FIELD_FULL)
+    deinterlacing = false;
+  else
+    deinterlacing = true;
+
+  glEnable(m_textureTarget);
+  VerifyGLState();
+
+  glPixelStorei(GL_UNPACK_ALIGNMENT, im->bpp);
+
+  if (deinterlacing)
+  {
+    // Load Odd Y field
+    LoadPlane( fields[FIELD_TOP][0] , GL_LUMINANCE, buf.flipindex
+             , im->width, im->height >> 1
+             , im->stride[0]*2, im->bpp, im->plane[0] );
+
+    // Load Even Y field
+    LoadPlane( fields[FIELD_BOT][0], GL_LUMINANCE, buf.flipindex
+             , im->width, im->height >> 1
+             , im->stride[0]*2, im->bpp, im->plane[0] + im->stride[0]) ;
+
+    // Load Odd UV Fields
+    LoadPlane( fields[FIELD_TOP][1], GL_LUMINANCE_ALPHA, buf.flipindex
+             , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
+             , im->stride[1]*2, im->bpp, im->plane[1] );
+
+    // Load Even UV Fields
+    LoadPlane( fields[FIELD_BOT][1], GL_LUMINANCE_ALPHA, buf.flipindex
+             , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
+             , im->stride[1]*2, im->bpp, im->plane[1] + im->stride[1] );
 
   }
   else
@@ -2290,384 +2178,6 @@ void CLinuxRendererGL::DeleteNV12Texture(int index)
   }
 }
 
-void CLinuxRendererGL::DeleteVDPAUTexture(int index)
-{
-#ifdef HAVE_LIBVDPAU
-  YUVPLANE &plane = m_buffers[index].fields[FIELD_FULL][0];
-
-  SAFE_RELEASE(m_buffers[index].vdpau);
-
-  plane.id = 0;
-#endif
-}
-
-bool CLinuxRendererGL::CreateVDPAUTexture(int index)
-{
-#ifdef HAVE_LIBVDPAU
-  YV12Image &im     = m_buffers[index].image;
-  YUVFIELDS &fields = m_buffers[index].fields;
-  YUVPLANE  &plane  = fields[FIELD_FULL][0];
-
-  DeleteVDPAUTexture(index);
-
-  memset(&im    , 0, sizeof(im));
-  memset(&fields, 0, sizeof(fields));
-  im.height = m_sourceHeight;
-  im.width  = m_sourceWidth;
-
-  plane.texwidth  = im.width;
-  plane.texheight = im.height;
-
-  plane.pixpertex_x = 1;
-  plane.pixpertex_y = 1;
-
-  plane.id = 1;
-
-#endif
-  return true;
-}
-
-bool CLinuxRendererGL::UploadVDPAUTexture(int index)
-{
-#ifdef HAVE_LIBVDPAU
-  VDPAU::CVdpauRenderPicture *vdpau = m_buffers[index].vdpau;
-
-  YUVFIELDS &fields = m_buffers[index].fields;
-  YUVPLANE &plane = fields[FIELD_FULL][0];
-
-  if (!vdpau || !vdpau->valid)
-  {
-    return false;
-  }
-
-  plane.id = vdpau->texture[0];
-
-  // in stereoscopic mode sourceRect may only
-  // be a part of the source video surface
-  plane.rect = m_sourceRect;
-
-  // clip rect
-  if (vdpau->crop.x1 > plane.rect.x1)
-    plane.rect.x1 = vdpau->crop.x1;
-  if (vdpau->crop.x2 < plane.rect.x2)
-    plane.rect.x2 = vdpau->crop.x2;
-  if (vdpau->crop.y1 > plane.rect.y1)
-    plane.rect.y1 = vdpau->crop.y1;
-  if (vdpau->crop.y2 < plane.rect.y2)
-    plane.rect.y2 = vdpau->crop.y2;
-
-  plane.texheight = vdpau->texHeight;
-  plane.texwidth  = vdpau->texWidth;
-
-  if (m_textureTarget == GL_TEXTURE_2D)
-  {
-    plane.rect.y1 /= plane.texheight;
-    plane.rect.y2 /= plane.texheight;
-    plane.rect.x1 /= plane.texwidth;
-    plane.rect.x2 /= plane.texwidth;
-  }
-
-#endif
-  return true;
-}
-
-void CLinuxRendererGL::DeleteVDPAUTexture420(int index)
-{
-#ifdef HAVE_LIBVDPAU
-  YUVFIELDS &fields = m_buffers[index].fields;
-
-  SAFE_RELEASE(m_buffers[index].vdpau);
-
-  fields[0][0].id = 0;
-  fields[1][0].id = 0;
-  fields[1][1].id = 0;
-  fields[2][0].id = 0;
-  fields[2][1].id = 0;
-
-#endif
-}
-
-bool CLinuxRendererGL::CreateVDPAUTexture420(int index)
-{
-#ifdef HAVE_LIBVDPAU
-  YV12Image &im     = m_buffers[index].image;
-  YUVFIELDS &fields = m_buffers[index].fields;
-  YUVPLANE &plane = fields[0][0];
-  GLuint    *pbo    = m_buffers[index].pbo;
-
-  DeleteVDPAUTexture420(index);
-
-  memset(&im    , 0, sizeof(im));
-  memset(&fields, 0, sizeof(fields));
-
-  im.cshift_x = 1;
-  im.cshift_y = 1;
-
-  im.plane[0] = NULL;
-  im.plane[1] = NULL;
-  im.plane[2] = NULL;
-
-  for(int p=0; p<3; p++)
-  {
-    pbo[p] = None;
-  }
-
-  plane.id = 1;
-
-#endif
-  return true;
-}
-
-bool CLinuxRendererGL::UploadVDPAUTexture420(int index)
-{
-#ifdef HAVE_LIBVDPAU
-  VDPAU::CVdpauRenderPicture *vdpau = m_buffers[index].vdpau;
-  YV12Image &im = m_buffers[index].image;
-
-  YUVFIELDS &fields = m_buffers[index].fields;
-
-  if (!vdpau || !vdpau->valid)
-  {
-    return false;
-  }
-
-  im.height = vdpau->texHeight;
-  im.width  = vdpau->texWidth;
-
-  // YUV
-  for (int f = FIELD_TOP; f<=FIELD_BOT ; f++)
-  {
-    YUVPLANES &planes = fields[f];
-
-    planes[0].texwidth  = im.width;
-    planes[0].texheight = im.height >> 1;
-
-    planes[1].texwidth  = planes[0].texwidth  >> im.cshift_x;
-    planes[1].texheight = planes[0].texheight >> im.cshift_y;
-    planes[2].texwidth  = planes[1].texwidth;
-    planes[2].texheight = planes[1].texheight;
-
-    for (int p = 0; p < 3; p++)
-    {
-      planes[p].pixpertex_x = 1;
-      planes[p].pixpertex_y = 1;
-    }
-  }
-  // crop
-//  m_sourceRect.x1 += vdpau->crop.x1;
-//  m_sourceRect.x2 -= vdpau->crop.x2;
-//  m_sourceRect.y1 += vdpau->crop.y1;
-//  m_sourceRect.y2 -= vdpau->crop.y2;
-
-  // set textures
-  fields[1][0].id = vdpau->texture[0];
-  fields[1][1].id = vdpau->texture[2];
-  fields[1][2].id = vdpau->texture[2];
-  fields[2][0].id = vdpau->texture[1];
-  fields[2][1].id = vdpau->texture[3];
-  fields[2][2].id = vdpau->texture[3];
-
-  glEnable(m_textureTarget);
-  for (int f = FIELD_TOP; f <= FIELD_BOT; f++)
-  {
-    for (int p=0; p<2; p++)
-    {
-      glBindTexture(m_textureTarget,fields[f][p].id);
-      glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-      glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-      glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-      glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-
-      glBindTexture(m_textureTarget,0);
-      VerifyGLState();
-    }
-  }
-  CalculateTextureSourceRects(index, 3);
-  glDisable(m_textureTarget);
-
-#endif
-  return true;
-}
-
-void CLinuxRendererGL::DeleteVAAPITexture(int index)
-{
-#ifdef HAVE_LIBVA
-  YUVPLANE &plane = m_buffers[index].fields[FIELD_FULL][0];
-  SAFE_RELEASE(m_buffers[index].vaapi);
-  plane.id = 0;
-#endif
-}
-
-bool CLinuxRendererGL::CreateVAAPITexture(int index)
-{
-#ifdef HAVE_LIBVA
-  YV12Image &im     = m_buffers[index].image;
-  YUVFIELDS &fields = m_buffers[index].fields;
-  YUVPLANE  &plane  = fields[0][0];
-
-  DeleteVAAPITexture(index);
-
-  memset(&im    , 0, sizeof(im));
-  memset(&fields, 0, sizeof(fields));
-  im.height = m_sourceHeight;
-  im.width  = m_sourceWidth;
-
-  plane.texwidth  = im.width;
-  plane.texheight = im.height;
-
-  plane.pixpertex_x = 1;
-  plane.pixpertex_y = 1;
-
-  plane.id = 1;
-
-#endif
-  return true;
-}
-
-bool CLinuxRendererGL::UploadVAAPITexture(int index)
-{
-#ifdef HAVE_LIBVA
-  VAAPI::CVaapiRenderPicture *vaapi = m_buffers[index].vaapi;
-
-  YUVFIELDS &fields = m_buffers[index].fields;
-  YUVPLANE &plane = fields[FIELD_FULL][0];
-
-  if (!vaapi || !vaapi->valid)
-  {
-    return false;
-  }
-
-  if (!vaapi->CopyGlx())
-    return false;
-
-  plane.id = vaapi->texture;
-
-  // in stereoscopic mode sourceRect may only
-  // be a part of the source video surface
-  plane.rect = m_sourceRect;
-
-  // clip rect
-  if (vaapi->crop.x1 > plane.rect.x1)
-    plane.rect.x1 = vaapi->crop.x1;
-  if (vaapi->crop.x2 < plane.rect.x2)
-    plane.rect.x2 = vaapi->crop.x2;
-  if (vaapi->crop.y1 > plane.rect.y1)
-    plane.rect.y1 = vaapi->crop.y1;
-  if (vaapi->crop.y2 < plane.rect.y2)
-    plane.rect.y2 = vaapi->crop.y2;
-
-  plane.texheight = vaapi->texHeight;
-  plane.texwidth  = vaapi->texWidth;
-
-  if (m_textureTarget == GL_TEXTURE_2D)
-  {
-    plane.rect.y1 /= plane.texheight;
-    plane.rect.y2 /= plane.texheight;
-    plane.rect.x1 /= plane.texwidth;
-    plane.rect.x2 /= plane.texwidth;
-  }
-
-#endif
-  return true;
-}
-
-//********************************************************************************************************
-// CoreVideoRef Texture creation, deletion, copying + clearing
-//********************************************************************************************************
-bool CLinuxRendererGL::UploadCVRefTexture(int index)
-{
-#ifdef TARGET_DARWIN
-  YUVBUFFER &buf    = m_buffers[index];
-  YUVFIELDS &fields = buf.fields;
-
-  CVBufferRef cvBufferRef = m_buffers[index].cvBufferRef;
-
-  glEnable(m_textureTarget);
-
-  if (cvBufferRef && fields[m_currentField][0].flipindex != buf.flipindex)
-  {
-
-    // It is the fastest way to render a CVPixelBuffer backed
-    // with an IOSurface as there is no CPU -> GPU upload.
-    CGLContextObj cgl_ctx  = (CGLContextObj)g_Windowing.GetCGLContextObj();
-    IOSurfaceRef	surface  = CVPixelBufferGetIOSurface(cvBufferRef);
-    GLsizei       texWidth = IOSurfaceGetWidth(surface);
-    GLsizei       texHeight= IOSurfaceGetHeight(surface);
-    OSType        format_type = IOSurfaceGetPixelFormat(surface);
-
-    glBindTexture(m_textureTarget, fields[FIELD_FULL][0].id);
-
-    if (format_type == kCVPixelFormatType_422YpCbCr8)
-      CGLTexImageIOSurface2D(cgl_ctx, m_textureTarget, GL_RGBA8,
-        texWidth / 2, texHeight, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, surface, 0);
-    else if (format_type == kCVPixelFormatType_32BGRA)
-      CGLTexImageIOSurface2D(cgl_ctx, m_textureTarget, GL_RGBA8,
-        texWidth, texHeight, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, surface, 0);
-
-    glBindTexture(m_textureTarget, 0);
-    fields[FIELD_FULL][0].flipindex = buf.flipindex;
-
-  }
-
-
-  CalculateTextureSourceRects(index, 3);
-  glDisable(m_textureTarget);
-
-#endif
-  return true;
-}
-
-void CLinuxRendererGL::DeleteCVRefTexture(int index)
-{
-#ifdef TARGET_DARWIN
-  YUVPLANE  &plane = m_buffers[index].fields[0][0];
-
-  if (m_buffers[index].cvBufferRef)
-    CVBufferRelease(m_buffers[index].cvBufferRef);
-  m_buffers[index].cvBufferRef = NULL;
-
-  if (plane.id && glIsTexture(plane.id))
-    glDeleteTextures(1, &plane.id), plane.id = 0;
-#endif
-}
-
-bool CLinuxRendererGL::CreateCVRefTexture(int index)
-{
-#ifdef TARGET_DARWIN
-  YV12Image &im     = m_buffers[index].image;
-  YUVFIELDS &fields = m_buffers[index].fields;
-  YUVPLANE  &plane  = fields[0][0];
-
-  DeleteCVRefTexture(index);
-
-  memset(&im    , 0, sizeof(im));
-  memset(&fields, 0, sizeof(fields));
-
-  im.bpp    = 1;
-  im.width  = m_sourceWidth;
-  im.height = m_sourceHeight;
-  im.cshift_x = 0;
-  im.cshift_y = 0;
-
-  plane.pixpertex_x = 2;
-  plane.pixpertex_y = 1;
-  plane.texwidth    = im.width  / plane.pixpertex_x;
-  plane.texheight   = im.height / plane.pixpertex_y;
-
-  if(m_renderMethod & RENDER_POT)
-  {
-    plane.texwidth  = NP2(plane.texwidth);
-    plane.texheight = NP2(plane.texheight);
-  }
-
-  glEnable(m_textureTarget);
-  glGenTextures(1, &plane.id);
-  glDisable(m_textureTarget);
-
-#endif
-  return true;
-}
-
 bool CLinuxRendererGL::UploadYUV422PackedTexture(int source)
 {
   YUVBUFFER& buf    =  m_buffers[source];
@@ -3239,12 +2749,6 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
 {
   if(feature == RENDERFEATURE_BRIGHTNESS)
   {
-    if ((m_renderMethod & RENDER_VDPAU) && !g_guiSettings.GetBool("videoscreen.limitedrange"))
-      return true;
-
-    if (m_renderMethod & RENDER_VAAPI)
-      return false;
-
     return (m_renderMethod & RENDER_GLSL)
         || (m_renderMethod & RENDER_ARB)
         || ((m_renderMethod & RENDER_SW) && glewIsSupported("GL_ARB_imaging") == GL_TRUE);
@@ -3252,12 +2756,6 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
   
   if(feature == RENDERFEATURE_CONTRAST)
   {
-    if ((m_renderMethod & RENDER_VDPAU) && !g_guiSettings.GetBool("videoscreen.limitedrange"))
-      return true;
-
-    if (m_renderMethod & RENDER_VAAPI)
-      return false;
-
     return (m_renderMethod & RENDER_GLSL)
         || (m_renderMethod & RENDER_ARB)
         || ((m_renderMethod & RENDER_SW) && glewIsSupported("GL_ARB_imaging") == GL_TRUE);
@@ -3267,21 +2765,16 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
     return false;
   
   if(feature == RENDERFEATURE_NOISE)
-  {
-    if(m_renderMethod & RENDER_VDPAU)
-      return true;
-  }
+    return false;
 
   if(feature == RENDERFEATURE_SHARPNESS)
   {
-    if(m_renderMethod & RENDER_VDPAU)
-      return true;
+    return false;
   }
 
   if (feature == RENDERFEATURE_NONLINSTRETCH)
   {
-    if (((m_renderMethod & RENDER_GLSL) && !(m_renderMethod & RENDER_POT)) ||
-        (m_renderMethod & RENDER_VDPAU) || (m_renderMethod & RENDER_VAAPI))
+    if ((m_renderMethod & RENDER_GLSL) && !(m_renderMethod & RENDER_POT))
       return true;
   }
 
@@ -3321,34 +2814,6 @@ bool CLinuxRendererGL::Supports(EINTERLACEMETHOD method)
 
   if(method == VS_INTERLACEMETHOD_AUTO)
     return true;
-
-  if(m_renderMethod & RENDER_VDPAU ||
-      m_format == RENDER_FMT_VDPAU_420)
-  {
-#ifdef HAVE_LIBVDPAU
-    VDPAU::CVdpauRenderPicture *vdpauPic = m_buffers[m_iYV12RenderBuffer].vdpau;
-    if(vdpauPic && vdpauPic->vdpau)
-      return vdpauPic->vdpau->Supports(method);
-#endif
-    return false;
-  }
-
-  if(m_format == RENDER_FMT_VAAPI ||
-      m_format == RENDER_FMT_VAAPINV12)
-  {
-#ifdef HAVE_LIBVA
-    VAAPI::CVaapiRenderPicture *vaapiPic = m_buffers[m_iYV12RenderBuffer].vaapi;
-    if(vaapiPic && vaapiPic->vaapi)
-      return vaapiPic->vaapi->Supports(method);
-#endif
-    return false;
-  }
-
-#ifdef TARGET_DARWIN_IOS
-  // iOS does not have the ponies for YADIF
-  if(method == VS_INTERLACEMETHOD_DEINTERLACE)
-    return false;
-#endif
   
   if(method == VS_INTERLACEMETHOD_DEINTERLACE
   || method == VS_INTERLACEMETHOD_DEINTERLACE_HALF
@@ -3391,8 +2856,7 @@ bool CLinuxRendererGL::Supports(ESCALINGMETHOD method)
     if (scaleX < minScale && scaleY < minScale)
       return false;
 
-    if ((glewIsSupported("GL_EXT_framebuffer_object") && (m_renderMethod & RENDER_GLSL)) ||
-        (m_renderMethod & RENDER_VDPAU) || (m_renderMethod & RENDER_VAAPI))
+    if (glewIsSupported("GL_EXT_framebuffer_object") && (m_renderMethod & RENDER_GLSL))
     {
       // spline36 and lanczos3 are only allowed through advancedsettings.xml
       if(method != VS_SCALINGMETHOD_SPLINE36
@@ -3408,12 +2872,6 @@ bool CLinuxRendererGL::Supports(ESCALINGMETHOD method)
 
 EINTERLACEMETHOD CLinuxRendererGL::AutoInterlaceMethod()
 {
-  if(m_renderMethod & RENDER_CVREF)
-    return VS_INTERLACEMETHOD_NONE;
-
-  if(m_renderMethod & RENDER_VDPAU)
-    return VS_INTERLACEMETHOD_NONE;
-
   if(Supports(VS_INTERLACEMETHOD_RENDER_BOB))
     return VS_INTERLACEMETHOD_RENDER_BOB;
 
@@ -3459,54 +2917,8 @@ CRenderInfo CLinuxRendererGL::GetRenderInfo()
   CRenderInfo info;
   info.formats = m_formats;
   info.max_buffer_size = NUM_BUFFERS;
-  if(m_format == RENDER_FMT_CVBREF)
-    info.optimal_buffer_size = 2;
-  else if (m_format == RENDER_FMT_VAAPI ||
-           m_format == RENDER_FMT_VAAPINV12 ||
-           m_format == RENDER_FMT_VDPAU ||
-           m_format == RENDER_FMT_VDPAU_420)
-    info.optimal_buffer_size = 5;
-  else
-    info.optimal_buffer_size = 3;
+  info.optimal_buffer_size = 3;
   return info;
 }
 
-void CLinuxRendererGL::AddVideoPictureHW(DVDVideoPicture &picture, int index)
-{
-  if (picture.format == RENDER_FMT_VDPAU ||
-      picture.format == RENDER_FMT_VDPAU_420)
-  {
-#ifdef HAVE_LIBVDPAU
-    VDPAU::CVdpauRenderPicture *vdpau = picture.vdpau;
-    YUVBUFFER &buf = m_buffers[index];
-    VDPAU::CVdpauRenderPicture *pic = vdpau->Acquire();
-    SAFE_RELEASE(buf.vdpau);
-    buf.vdpau = pic;
-#endif
-  }
-  else if (picture.format == RENDER_FMT_VAAPI ||
-           picture.format == RENDER_FMT_VAAPINV12)
-  {
-#ifdef HAVE_LIBVA
-    VAAPI::CVaapiRenderPicture *vaapi = picture.vaapi;
-    YUVBUFFER &buf = m_buffers[index];
-    VAAPI::CVaapiRenderPicture *pic = vaapi->Acquire();
-    SAFE_RELEASE(buf.vaapi);
-    buf.vaapi = pic;
-#endif
-  }
-  else if (picture.format == RENDER_FMT_CVBREF)
-  {
-#ifdef TARGET_DARWIN
-    struct __CVBuffer *cvBufferRef = picture.cvBufferRef;
-    YUVBUFFER &buf = m_buffers[index];
-    if (buf.cvBufferRef)
-       CVBufferRelease(buf.cvBufferRef);
-    buf.cvBufferRef = cvBufferRef;
-    // retain another reference, this way dvdplayer and renderer can issue releases.
-    CVBufferRetain(buf.cvBufferRef);
-#endif
-  }
-}
-
 #endif
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.h b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
index e71e7d2678..cf827d2b07 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
@@ -40,8 +40,6 @@ class CRenderCapture;
 class CBaseTexture;
 namespace Shaders { class BaseYUV2RGBShader; }
 namespace Shaders { class BaseVideoFilterShader; }
-namespace VAAPI   { class CVaapiRenderPicture; }
-namespace VDPAU   { class CVdpauRenderPicture; }
 
 #undef ALIGN
 #define ALIGN(value, alignment) (((value)+((alignment)-1))&~((alignment)-1))
@@ -122,13 +120,11 @@ public:
   virtual bool IsConfigured() { return m_bConfigured; }
   virtual int GetImage(YV12Image *image, int source = AUTOSOURCE, bool readonly = false);
   virtual void ReleaseImage(int source, bool preserve = false);
-  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index);
   virtual void FlipPage(int source);
-  virtual unsigned int PreInit();
+  virtual void PreInit();
   virtual void UnInit();
   virtual void Reset(); /* resets renderer after seek for example */
   virtual void Flush();
-  virtual void ReleaseBuffer(int idx);
   virtual void SetBufferSize(int numBuffers) { m_NumYV12Buffers = numBuffers; }
   virtual void RenderUpdate(bool clear, DWORD flags = 0, DWORD alpha = 255);
   virtual void Update();
@@ -146,8 +142,8 @@ public:
 
 protected:
   virtual void Render(DWORD flags, int renderBuffer);
-  void         ClearBackBuffer();
-  void         DrawBlackBars();
+  void ClearBackBuffer();
+  void DrawBlackBars();
 
   bool ValidateRenderer();
   int  NextYV12Texture();
@@ -157,9 +153,9 @@ protected:
   void UpdateVideoFilter();
 
   // textures
-  bool (CLinuxRendererGL::*m_textureUpload)(int index);
-  void (CLinuxRendererGL::*m_textureDelete)(int index);
-  bool (CLinuxRendererGL::*m_textureCreate)(int index);
+  virtual bool UploadTexture(int index);
+  virtual void DeleteTexture(int index);
+  virtual bool CreateTexture(int index);
 
   bool UploadYV12Texture(int index);
   void DeleteYV12Texture(int index);
@@ -168,22 +164,6 @@ protected:
   bool UploadNV12Texture(int index);
   void DeleteNV12Texture(int index);
   bool CreateNV12Texture(int index);
-  
-  bool UploadVDPAUTexture(int index);
-  void DeleteVDPAUTexture(int index);
-  bool CreateVDPAUTexture(int index);
-
-  bool UploadVDPAUTexture420(int index);
-  void DeleteVDPAUTexture420(int index);
-  bool CreateVDPAUTexture420(int index);
-
-  bool UploadVAAPITexture(int index);
-  void DeleteVAAPITexture(int index);
-  bool CreateVAAPITexture(int index);
-
-  bool UploadCVRefTexture(int index);
-  void DeleteCVRefTexture(int index);
-  bool CreateCVRefTexture(int index);
 
   bool UploadYUV422PackedTexture(int index);
   void DeleteYUV422PackedTexture(int index);
@@ -204,6 +184,10 @@ protected:
   void RenderRGB(int renderBuffer, int field);      // render using vdpau/vaapi hardware
   void RenderProgressiveWeave(int renderBuffer, int field); // render using vdpau hardware
 
+  // hooks for HwDec Renderered
+  virtual bool LoadShadersHook() { return false; };
+  virtual bool RenderHook(int idx) { return false; };
+
   struct
   {
     CFrameBufferObject fbo;
@@ -260,15 +244,7 @@ protected:
     unsigned  flipindex; /* used to decide if this has been uploaded */
     GLuint    pbo[MAX_PLANES];
 
-#ifdef HAVE_LIBVDPAU
-    VDPAU::CVdpauRenderPicture *vdpau;
-#endif
-#ifdef HAVE_LIBVA
-    VAAPI::CVaapiRenderPicture *vaapi;
-#endif
-#ifdef TARGET_DARWIN_OSX
-    struct __CVBuffer *cvBufferRef;
-#endif
+    void *hwDec;
   };
 
   typedef YUVBUFFER          YUVBUFFERS[NUM_BUFFERS];
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 03bd487126..77b00ef9c1 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -19,9 +19,6 @@
  */
 
 #include "system.h"
-#if defined(HAS_GL)
-  #include "system_gl.h"
-#endif
 #include "RenderManager.h"
 #include "RenderFlags.h"
 #include "threads/CriticalSection.h"
@@ -40,7 +37,12 @@
 #include "cores/DataCacheCore.h"
 
 #if defined(HAS_GL)
-  #include "LinuxRendererGL.h"
+#include "LinuxRendererGL.h"
+#include "HwDecRender/RendererVAAPI.h"
+#include "HwDecRender/RendererVDPAU.h"
+#if defined(TARGET_DARWIN_OSX)
+#include "HwDecRender/RendererVDA.h"
+#endif
 #elif defined(HAS_MMAL)
   #include "MMALRenderer.h"
 #elif HAS_GLES == 2
@@ -58,10 +60,6 @@
 #include "../dvdplayer/DVDCodecs/Video/DVDVideoCodec.h"
 #include "../dvdplayer/DVDCodecs/DVDCodecUtils.h"
 
-#ifdef HAVE_LIBVA
-  #include "../dvdplayer/DVDCodecs/Video/VAAPI.h"
-#endif
-
 #define MAXPRESENTDELAY 0.500
 
 
@@ -102,10 +100,34 @@ static void requeue(std::deque<int> &trg, std::deque<int> &src)
   src.pop_front();
 }
 
+static std::string GetRenderFormatName(ERenderFormat format)
+{
+  switch(format)
+  {
+    case RENDER_FMT_YUV420P:   return "YV12";
+    case RENDER_FMT_YUV420P16: return "YV12P16";
+    case RENDER_FMT_YUV420P10: return "YV12P10";
+    case RENDER_FMT_NV12:      return "NV12";
+    case RENDER_FMT_UYVY422:   return "UYVY";
+    case RENDER_FMT_YUYV422:   return "YUY2";
+    case RENDER_FMT_VDPAU:     return "VDPAU";
+    case RENDER_FMT_VDPAU_420: return "VDPAU_420";
+    case RENDER_FMT_DXVA:      return "DXVA";
+    case RENDER_FMT_VAAPI:     return "VAAPI";
+    case RENDER_FMT_VAAPINV12: return "VAAPI_NV12";
+    case RENDER_FMT_OMXEGL:    return "OMXEGL";
+    case RENDER_FMT_CVBREF:    return "BGRA";
+    case RENDER_FMT_BYPASS:    return "BYPASS";
+    case RENDER_FMT_MMAL:      return "MMAL";
+    case RENDER_FMT_NONE:      return "NONE";
+  }
+  return "UNKNOWN";
+}
+
 CXBMCRenderManager::CXBMCRenderManager()
 {
   m_pRenderer = NULL;
-  m_bIsStarted = false;
+  m_renderState = STATE_UNCONFIGURED;
 
   m_presentstep = PRESENT_IDLE;
   m_rendermethod = 0;
@@ -126,7 +148,6 @@ CXBMCRenderManager::CXBMCRenderManager()
 CXBMCRenderManager::~CXBMCRenderManager()
 {
   delete m_pRenderer;
-  m_pRenderer = NULL;
 }
 
 void CXBMCRenderManager::GetVideoRect(CRect &source, CRect &dest, CRect &view)
@@ -212,14 +233,11 @@ void CXBMCRenderManager::WaitPresentTime(double presenttime)
 
   avgerror /= ERRORBUFFSIZE;
 
-
   //we change the clock speed slightly
   //to make every frame's presenttime end up in the middle of two vblanks
   //integral correction, clamp to -0.5:0.5 range
   m_presentcorr = std::max(std::min(m_presentcorr + avgerror * 0.01, 0.1), -0.1);
   g_VideoReferenceClock.SetFineAdjust(1.0 - avgerror * 0.01 - m_presentcorr * 0.01);
-
-  //printf("%f %f % 2.0f%% % f % f\n", presenttime, clock, m_presentcorr * 100, error, error_org);
 }
 
 std::string CXBMCRenderManager::GetVSyncState()
@@ -236,56 +254,118 @@ std::string CXBMCRenderManager::GetVSyncState()
   return state;
 }
 
-bool CXBMCRenderManager::Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, float fps, unsigned flags, ERenderFormat format, unsigned extended_format, unsigned int orientation, int buffers)
+bool CXBMCRenderManager::Configure(DVDVideoPicture& picture, float fps, unsigned flags, unsigned int orientation, int buffers)
 {
 
-  CSingleLock    lock2(m_presentlock);
+  // check if something has changed
+  {
+    float config_framerate = fps;
+    float render_framerate = g_graphicsContext.GetFPS();
+    if (g_guiSettings.GetInt("videoplayer.adjustrefreshrate") == ADJUST_REFRESHRATE_OFF)
+      render_framerate = config_framerate;
+    bool changerefresh = (fps != 0) &&
+                         (m_fps == 0.0 || fmod(m_fps, fps) != 0.0) &&
+                         (render_framerate != config_framerate);
+
+    CSharedLock lock(m_sharedSection);
+    if (m_width == picture.iWidth &&
+        m_height == picture.iHeight &&
+        m_dwidth == picture.iDisplayWidth &&
+        m_dheight == picture.iDisplayHeight &&
+        !changerefresh &&
+        (m_flags & ~CONF_FLAGS_FULLSCREEN) == (flags & ~CONF_FLAGS_FULLSCREEN) &&
+        m_format == picture.format &&
+        m_extended_format == picture.extended_format &&
+        m_orientation == orientation &&
+        m_NumberBuffers == buffers &&
+        m_pRenderer != NULL)
+      return true;
+  }
+
+  std::string formatstr = GetRenderFormatName(picture.format);
+  CLog::Log(LOGDEBUG, "CXBMCRenderManager::Configure - change configuration. %dx%d. display: %dx%d. framerate: %4.2f. format: %s", picture.iWidth, picture.iHeight, picture.iDisplayWidth, picture.iDisplayHeight, fps, formatstr.c_str());
 
-  /* make sure any queued frame was fully presented */
-  XbmcThreads::EndTime endtime(10000);
-  while(m_presentstep != PRESENT_IDLE && m_presentstep != PRESENT_READY)
+  // make sure any queued frame was fully presented
   {
-    if(endtime.IsTimePast())
+    CSingleLock lock(m_presentlock);
+    XbmcThreads::EndTime endtime(5000);
+    while(m_presentstep != PRESENT_IDLE && m_presentstep != PRESENT_READY)
     {
-      CLog::Log(LOGWARNING, "CRenderManager::Configure - timeout waiting for state");
-      return false;
+      if(endtime.IsTimePast())
+      {
+        CLog::Log(LOGWARNING, "CRenderManager::Configure - timeout waiting for state");
+        return false;
+      }
+      m_presentevent.wait(lock, endtime.MillisLeft());
     }
-    m_presentevent.wait(lock2, endtime.MillisLeft());
-  };
-  lock2.Leave();
+  }
 
-  CExclusiveLock lock(m_sharedSection);
-  if(!m_pRenderer)
   {
-    CLog::Log(LOGERROR, "%s called without a valid Renderer object", __FUNCTION__);
+    CExclusiveLock lock(m_sharedSection);
+    m_width = picture.iWidth;
+    m_height = picture.iHeight,
+    m_dwidth = picture.iDisplayWidth;
+    m_dheight = picture.iDisplayHeight;
+    m_fps = fps;
+    m_flags = flags;
+    m_format = picture.format;
+    m_extended_format = picture.extended_format;
+    m_orientation = orientation;
+    m_NumberBuffers  = buffers;
+    m_renderState = STATE_CONFIGURING;
+    m_stateEvent.Reset();
+  }
+
+  if (!m_stateEvent.WaitMSec(1000))
+  {
+    CLog::Log(LOGWARNING, "CRenderManager::Configure - timeout waiting for configure");
+    return false;
+  }
+
+  CSharedLock lock(m_sharedSection);
+  if (m_renderState != STATE_CONFIGURED)
+  {
+    CLog::Log(LOGWARNING, "CRenderManager::Configure - failed to configure");
     return false;
   }
 
+  return true;
+}
+
+bool CXBMCRenderManager::Configure()
+{
+  CExclusiveLock lock(m_sharedSection);
+  CSingleLock lock2(m_presentlock);
 
-  bool result = m_pRenderer->Configure(width, height, d_width, d_height, fps, flags, format, extended_format, orientation);
-  if(result)
+  if (m_pRenderer && m_pRenderer->GetRenderFormat() != m_format)
   {
-    if( flags & CONF_FLAGS_FULLSCREEN )
-    {
-      lock.Leave();
-      CApplicationMessenger::Get().SwitchToFullscreen();
-      lock.Enter();
-    }
-    lock2.Enter();
-    m_format = format;
+    DeleteRenderer();
+  }
 
+  if(!m_pRenderer)
+  {
+    CreateRenderer();
+    if (!m_pRenderer)
+      return false;
+    else
+      m_pRenderer->PreInit();
+  }
+
+  bool result = m_pRenderer->Configure(m_width, m_height, m_dwidth, m_dheight, m_fps, m_flags, m_format, m_extended_format, m_orientation);
+  if (result)
+  {
     CRenderInfo info = m_pRenderer->GetRenderInfo();
     int renderbuffers = info.optimal_buffer_size;
     m_QueueSize = renderbuffers;
-    if (buffers > 0)
-      m_QueueSize = std::min(buffers, renderbuffers);
+    if (m_NumberBuffers > 0)
+      m_QueueSize = std::min(m_NumberBuffers, renderbuffers);
 
     m_QueueSize = std::min(m_QueueSize, (int)info.max_buffer_size);
     m_QueueSize = std::min(m_QueueSize, NUM_BUFFERS);
     if(m_QueueSize < 2)
     {
       m_QueueSize = 2;
-      CLog::Log(LOGWARNING, "CXBMCRenderManager::Configure - queue size too small (%d, %d, %d)", m_QueueSize, renderbuffers, buffers);
+      CLog::Log(LOGWARNING, "CXBMCRenderManager::Configure - queue size too small (%d, %d, %d)", m_QueueSize, renderbuffers, m_NumberBuffers);
     }
 
     m_pRenderer->SetBufferSize(m_QueueSize);
@@ -298,7 +378,6 @@ bool CXBMCRenderManager::Configure(unsigned int width, unsigned int height, unsi
     for (int i=1; i < m_QueueSize; i++)
       m_free.push_back(i);
 
-    m_bIsStarted = true;
     m_bRenderGUI = true;
     m_waitForBufferCount = 0;
     m_bReconfigured = true;
@@ -308,17 +387,24 @@ bool CXBMCRenderManager::Configure(unsigned int width, unsigned int height, unsi
     m_presentevent.notifyAll();
     m_renderedOverlay = false;
 
+    m_renderState = STATE_CONFIGURED;
+
     CLog::Log(LOGDEBUG, "CXBMCRenderManager::Configure - %d", m_QueueSize);
   }
+  else
+    m_renderState = STATE_UNCONFIGURED;
 
+  m_stateEvent.Set();
   return result;
 }
 
 bool CXBMCRenderManager::IsConfigured() const
 {
-  if (!m_pRenderer)
+  CSharedLock lock(m_sharedSection);
+  if (m_renderState == STATE_CONFIGURED)
+    return true;
+  else
     return false;
-  return m_pRenderer->IsConfigured();
 }
 
 void CXBMCRenderManager::Update()
@@ -348,54 +434,66 @@ bool CXBMCRenderManager::HasFrame()
 
 void CXBMCRenderManager::FrameMove()
 {
-  { CSharedLock lock(m_sharedSection);
-    CSingleLock lock2(m_presentlock);
+  CSharedLock lock(m_sharedSection);
 
-    if (!m_pRenderer)
+  if (m_renderState == STATE_UNCONFIGURED)
+    return;
+  else if (m_renderState == STATE_CONFIGURING)
+  {
+    lock.Leave();
+    if (!Configure())
       return;
 
-    if (m_presentstep == PRESENT_FRAME2)
+    if (m_flags & CONF_FLAGS_FULLSCREEN)
     {
-      if(!m_queued.empty())
-      {
-        double timestamp = GetPresentTime();
-        SPresent& m = m_Queue[m_presentsource];
-        SPresent& q = m_Queue[m_queued.front()];
-        if(timestamp > m.timestamp + (q.timestamp - m.timestamp) * 0.5)
-        {
-          m_presentstep = PRESENT_READY;
-          m_presentevent.notifyAll();
-        }
-      }
+      CApplicationMessenger::Get().SwitchToFullscreen();
     }
+    lock.Enter();
+  }
 
-    if (m_presentstep == PRESENT_READY)
-      PrepareNextRender();
-
-    if(m_presentstep == PRESENT_FLIP)
-    {
-      m_pRenderer->FlipPage(m_presentsource);
-      m_presentstep = PRESENT_FRAME;
-      m_presentevent.notifyAll();
-    }
+  CSingleLock lock2(m_presentlock);
 
-    /* release all previous */
-    for(std::deque<int>::iterator it = m_discard.begin(); it != m_discard.end(); )
+  if (m_presentstep == PRESENT_FRAME2)
+  {
+    if (!m_queued.empty())
     {
-      // renderer may want to keep the frame for postprocessing
-      if (!m_pRenderer->NeedBufferForRef(*it) || !m_bRenderGUI)
+      double timestamp = GetPresentTime();
+      SPresent& m = m_Queue[m_presentsource];
+      SPresent& q = m_Queue[m_queued.front()];
+      if(timestamp > m.timestamp + (q.timestamp - m.timestamp) * 0.5)
       {
-        m_pRenderer->ReleaseBuffer(*it);
-        m_overlays.Release(*it);
-        m_free.push_back(*it);
-        it = m_discard.erase(it);
+        m_presentstep = PRESENT_READY;
+        m_presentevent.notifyAll();
       }
-      else
-        ++it;
     }
+  }
 
-    m_bRenderGUI = true;
+  if (m_presentstep == PRESENT_READY)
+    PrepareNextRender();
+
+  if(m_presentstep == PRESENT_FLIP)
+  {
+    m_pRenderer->FlipPage(m_presentsource);
+    m_presentstep = PRESENT_FRAME;
+    m_presentevent.notifyAll();
   }
+
+  /* release all previous */
+  for (std::deque<int>::iterator it = m_discard.begin(); it != m_discard.end(); )
+  {
+    // renderer may want to keep the frame for postprocessing
+    if (!m_pRenderer->NeedBufferForRef(*it) || !m_bRenderGUI)
+    {
+      m_pRenderer->ReleaseBuffer(*it);
+      m_overlays.Release(*it);
+      m_free.push_back(*it);
+      it = m_discard.erase(it);
+    }
+    else
+      ++it;
+  }
+
+  m_bRenderGUI = true;
 }
 
 void CXBMCRenderManager::FrameFinish()
@@ -424,7 +522,6 @@ void CXBMCRenderManager::FrameFinish()
     else if(m_presentstep == PRESENT_FRAME2)
       m_presentstep = PRESENT_IDLE;
 
-
     if(m_presentstep == PRESENT_IDLE)
     {
       if(!m_queued.empty())
@@ -435,8 +532,14 @@ void CXBMCRenderManager::FrameFinish()
   }
 }
 
-unsigned int CXBMCRenderManager::PreInit()
+void CXBMCRenderManager::PreInit()
 {
+  if (!g_application.IsCurrentThread())
+  {
+    CLog::Log(LOGERROR, "CXBMCRenderManager::UnInit - not called from render thread");
+    return;
+  }
+
   CRetakeLock<CExclusiveLock> lock(m_sharedSection);
 
   m_presentcorr = 0.0;
@@ -444,20 +547,10 @@ unsigned int CXBMCRenderManager::PreInit()
   m_errorindex  = 0;
   memset(m_errorbuff, 0, sizeof(m_errorbuff));
 
-  m_bIsStarted = false;
   if (!m_pRenderer)
   {
-#if defined(HAS_GL)
-    m_pRenderer = new CLinuxRendererGL();
-#elif defined(HAS_MMAL)
-    m_pRenderer = new CMMALRenderer();
-#elif HAS_GLES == 2
-    m_pRenderer = new CLinuxRendererGLES();
-#elif defined(HAS_DX)
-    m_pRenderer = new CWinRenderer();
-#elif defined(HAS_SDL)
-    m_pRenderer = new CLinuxRenderer();
-#endif
+    m_format = RENDER_FMT_NONE;
+    CreateRenderer();
   }
 
   UpdateDisplayLatency();
@@ -465,24 +558,25 @@ unsigned int CXBMCRenderManager::PreInit()
   m_QueueSize   = 2;
   m_QueueSkip   = 0;
   m_presentstep = PRESENT_IDLE;
-
-  return m_pRenderer->PreInit();
 }
 
 void CXBMCRenderManager::UnInit()
 {
-  CRetakeLock<CExclusiveLock> lock(m_sharedSection);
+  if (!g_application.IsCurrentThread())
+  {
+    CLog::Log(LOGERROR, "CXBMCRenderManager::UnInit - not called from render thread");
+    return;
+  }
 
-  m_bIsStarted = false;
+  CRetakeLock<CExclusiveLock> lock(m_sharedSection);
 
   m_overlays.Flush();
   g_fontManager.Unload("__subtitle__");
   g_fontManager.Unload("__subtitleborder__");
 
-  // free renderer resources.
-  // TODO: we may also want to release the renderer here.
-  if (m_pRenderer)
-    m_pRenderer->UnInit();
+  DeleteRenderer();
+
+  m_renderState = STATE_UNCONFIGURED;
 }
 
 bool CXBMCRenderManager::Flush()
@@ -495,9 +589,13 @@ bool CXBMCRenderManager::Flush()
     CLog::Log(LOGDEBUG, "%s - flushing renderer", __FUNCTION__);
 
     CRetakeLock<CExclusiveLock> lock(m_sharedSection);
-    m_pRenderer->Flush();
-    m_overlays.Flush();
-    m_flushEvent.Set();
+
+    if (m_pRenderer)
+    {
+      m_pRenderer->Flush();
+      m_overlays.Flush();
+      m_flushEvent.Set();
+    }
   }
   else
   {
@@ -513,6 +611,7 @@ bool CXBMCRenderManager::Flush()
       return true;
   }
 
+  CSingleLock lock(m_presentlock);
   m_queued.clear();
   m_discard.clear();
   m_free.clear();
@@ -522,6 +621,56 @@ bool CXBMCRenderManager::Flush()
 
   return true;
 }
+void CXBMCRenderManager::CreateRenderer()
+{
+  if (!m_pRenderer)
+  {
+#if defined(HAS_MMAL)
+    m_pRenderer = new CMMALRenderer();
+#elif HAS_GLES == 2
+    m_pRenderer = new CLinuxRendererGLES();
+#elif defined(HAS_DX)
+    m_pRenderer = new CWinRenderer();
+#endif
+#if defined(HAS_GL)
+    if (m_format == RENDER_FMT_VAAPI || m_format == RENDER_FMT_VAAPINV12)
+    {
+#if defined(HAVE_LIBVA)
+      m_pRenderer = new CRendererVAAPI;
+#endif
+    }
+    else if (m_format == RENDER_FMT_VDPAU || m_format == RENDER_FMT_VDPAU_420)
+    {
+#if defined(HAVE_LIBVDPAU)
+      m_pRenderer = new CRendererVDPAU;
+#endif
+    }
+    else if (m_format == RENDER_FMT_CVBREF)
+    {
+#if defined(TARGET_DARWIN_OSX)
+      m_pRenderer = new CRendererVDA;
+#endif
+    }
+    else if (m_format != RENDER_FMT_NONE)
+    {
+      m_pRenderer = new CLinuxRendererGL;
+    }
+#endif
+    if (m_pRenderer)
+      m_pRenderer->PreInit();
+  }
+}
+
+void CXBMCRenderManager::DeleteRenderer()
+{
+  CLog::Log(LOGDEBUG, "%s - deleting renderer", __FUNCTION__);
+
+  if (m_pRenderer)
+  {
+    delete m_pRenderer;
+    m_pRenderer = NULL;
+  }
+}
 
 void CXBMCRenderManager::SetupScreenshot()
 {
@@ -756,13 +905,6 @@ void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0L
   }
 }
 
-void CXBMCRenderManager::Reset()
-{
-  CSharedLock lock(m_sharedSection);
-  if (m_pRenderer)
-    m_pRenderer->Reset();
-}
-
 RESOLUTION CXBMCRenderManager::GetResolution()
 {
   CSharedLock lock(m_sharedSection);
@@ -803,6 +945,9 @@ void CXBMCRenderManager::Render(bool clear, DWORD flags, DWORD alpha, bool gui)
 {
   CSharedLock lock(m_sharedSection);
 
+  if (m_renderState != STATE_CONFIGURED)
+    return;
+
   if (!gui && m_pRenderer->IsGuiLayer())
     return;
 
@@ -911,10 +1056,6 @@ void CXBMCRenderManager::PresentBlend(bool clear, DWORD flags, DWORD alpha)
 
 void CXBMCRenderManager::Recover()
 {
-#if defined(HAS_GL) && !defined(TARGET_DARWIN)
-  glFlush(); // attempt to have gpu done with pixmap and vdpau
-#endif
-
   UpdateDisplayLatency();
 }
 
@@ -949,8 +1090,8 @@ CRenderInfo CXBMCRenderManager::GetRenderInfo()
   CRenderInfo info;
   if (!m_pRenderer)
   {
-    CLog::Log(LOGERROR, "%s - renderer is NULL", __FUNCTION__);
-    return CRenderInfo();
+    info.max_buffer_size = NUM_BUFFERS;
+    return info;;
   }
   return m_pRenderer->GetRenderInfo();
 }
@@ -1001,13 +1142,9 @@ int CXBMCRenderManager::AddVideoPicture(DVDVideoPicture& pic)
        || pic.format == RENDER_FMT_OMXEGL
        || pic.format == RENDER_FMT_CVBREF
        || pic.format == RENDER_FMT_VAAPI
+       || pic.format == RENDER_FMT_VAAPINV12
        || pic.format == RENDER_FMT_MMAL)
     m_pRenderer->AddVideoPictureHW(pic, index);
-  else if(pic.format == RENDER_FMT_VAAPINV12)
-  {
-    m_pRenderer->AddVideoPictureHW(pic, index);
-    CDVDCodecUtils::CopyNV12Picture(&image, &pic.vaapi->DVDPic);
-  }
 
   m_pRenderer->ReleaseImage(index, false);
 
@@ -1072,7 +1209,7 @@ EINTERLACEMETHOD CXBMCRenderManager::AutoInterlaceMethodInternal(EINTERLACEMETHO
 
 int CXBMCRenderManager::WaitForBuffer(volatile bool& bStop, int timeout)
 {
-  CSingleLock lock2(m_presentlock);
+  CSingleLock lock(m_presentlock);
 
   // check if gui is active and discard buffer if not
   // this keeps videoplayer going
@@ -1093,7 +1230,7 @@ int CXBMCRenderManager::WaitForBuffer(volatile bool& bStop, int timeout)
     if (sleeptime < 0)
       sleeptime = 0;
     sleeptime = std::min(sleeptime, 20);
-    m_presentevent.wait(lock2, sleeptime);
+    m_presentevent.wait(lock, sleeptime);
     DiscardBuffer();
     return 0;
   }
@@ -1101,7 +1238,7 @@ int CXBMCRenderManager::WaitForBuffer(volatile bool& bStop, int timeout)
   XbmcThreads::EndTime endtime(timeout);
   while(m_free.empty())
   {
-    m_presentevent.wait(lock2, std::min(50, timeout));
+    m_presentevent.wait(lock, std::min(50, timeout));
     if(endtime.IsTimePast() || bStop)
     {
       if (timeout != 0 && !bStop)
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index 8f14264105..8736429d2a 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -53,7 +53,7 @@ public:
   CXBMCRenderManager();
   ~CXBMCRenderManager();
 
-  // Functions called from the GUI
+  // Functions called from render thread
   void GetVideoRect(CRect &source, CRect &dest, CRect &view);
   float GetAspectRatio();
   void Update();
@@ -64,31 +64,43 @@ public:
   void Render(bool clear, DWORD flags = 0, DWORD alpha = 255, bool gui = true);
   bool IsGuiLayer();
   bool IsVideoLayer();
-  void SetupScreenshot();
+  RESOLUTION GetResolution();
+  void UpdateResolution();
+  void SetViewMode(int iViewMode);
+  void Recover(); // called after resolution switch if something special is needed
+  void PreInit();
+  void UnInit();
+  bool Flush();
+  bool IsConfigured() const;
 
+  void SetupScreenshot();
   CRenderCapture* AllocRenderCapture();
   void ReleaseRenderCapture(CRenderCapture* capture);
   void Capture(CRenderCapture *capture, unsigned int width, unsigned int height, int flags);
   void ManageCaptures();
 
-  void SetViewMode(int iViewMode);
+  // Functions called from GUI
+  bool Supports(ERENDERFEATURE feature);
+  bool Supports(EDEINTERLACEMODE method);
+  bool Supports(EINTERLACEMETHOD method);
+  bool Supports(ESCALINGMETHOD method);
+  EINTERLACEMETHOD AutoInterlaceMethod(EINTERLACEMETHOD mInt);
+
+  static float GetMaximumFPS();
+  double GetDisplayLatency() { return m_displayLatency; }
+  int GetSkippedFrames()  { return m_QueueSkip; }
+  std::string GetVSyncState();
 
   // Functions called from mplayer
   /**
    * Called by video player to configure renderer
-   * @param width width of decoded frame
-   * @param height height of decoded frame
-   * @param d_width displayed width of frame (aspect ratio)
-   * @param d_height displayed height of frame
+   * @param picture
    * @param fps frames per second of video
    * @param flags see RenderFlags.h
-   * @param format see RenderFormats.h
-   * @param extended_format used by DXVA
    * @param orientation
    * @param numbers of kept buffer references
    */
-  bool Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, float fps, unsigned flags, ERenderFormat format, unsigned extended_format,  unsigned int orientation, int buffers = 0);
-  bool IsConfigured() const;
+  bool Configure(DVDVideoPicture& picture, float fps, unsigned flags, unsigned int orientation, int buffers = 0);
 
   int AddVideoPicture(DVDVideoPicture& picture);
 
@@ -107,9 +119,6 @@ public:
    * @param sync signals frame, top, or bottom field
    */
   void FlipPage(volatile bool& bStop, double timestamp = 0.0, double pts = 0.0, int source = -1, EFIELDSYNC sync = FS_NONE);
-  unsigned int PreInit();
-  void UnInit();
-  bool Flush();
 
   void AddOverlay(CDVDOverlay* o, double pts)
   {
@@ -127,41 +136,9 @@ public:
     m_overlays.AddCleanup(o);
   }
 
-  void Reset();
-
-  RESOLUTION GetResolution();
-
-  static float GetMaximumFPS();
-  inline bool IsStarted() { return m_bIsStarted;}
-  double GetDisplayLatency() { return m_displayLatency; }
-  int    GetSkippedFrames()  { return m_QueueSkip; }
-
-  bool Supports(ERENDERFEATURE feature);
-  bool Supports(EDEINTERLACEMODE method);
-  bool Supports(EINTERLACEMETHOD method);
-  bool Supports(ESCALINGMETHOD method);
-
-  EINTERLACEMETHOD AutoInterlaceMethod(EINTERLACEMETHOD mInt);
-
-  static double GetPresentTime();
-  void  WaitPresentTime(double presenttime);
-
-  std::string GetVSyncState();
-
-  void UpdateResolution();
-
-  CBaseRenderer *m_pRenderer;
-
   // Get renderer info, can be called before configure
   CRenderInfo GetRenderInfo();
 
-  void Recover(); // called after resolution switch if something special is needed
-
-  CSharedSection& GetSection() { return m_sharedSection; };
-
-  void RegisterRenderUpdateCallBack(const void *ctx, RenderUpdateCallBackFn fn);
-  void RegisterRenderFeaturesCallBack(const void *ctx, RenderFeaturesCallBackFn fn);
-
   /**
    * If player uses buffering it has to wait for a buffer before it calls
    * AddVideoPicture and AddOverlay. It waits for max 50 ms before it returns -1
@@ -183,6 +160,10 @@ public:
    */
   void DiscardBuffer();
 
+  // TODO: trash those
+  void RegisterRenderUpdateCallBack(const void *ctx, RenderUpdateCallBackFn fn);
+  void RegisterRenderFeaturesCallBack(const void *ctx, RenderFeaturesCallBackFn fn);
+
 protected:
 
   void PresentSingle(bool clear, DWORD flags, DWORD alpha);
@@ -190,17 +171,22 @@ protected:
   void PresentBlend(bool clear, DWORD flags, DWORD alpha);
 
   void PrepareNextRender();
+  static double GetPresentTime();
+  void  WaitPresentTime(double presenttime);
 
   EINTERLACEMETHOD AutoInterlaceMethodInternal(EINTERLACEMETHOD mInt);
+  bool Configure();
+  void CreateRenderer();
+  void DeleteRenderer();
 
+  CBaseRenderer *m_pRenderer;
+  OVERLAY::CRenderer m_overlays;
   CSharedSection m_sharedSection;
-
-  bool m_bIsStarted;
   bool m_bReconfigured;
   bool m_bRenderGUI;
   int m_waitForBufferCount;
-
   int m_rendermethod;
+  bool m_renderedOverlay;
 
   enum EPRESENTSTEP
   {
@@ -219,6 +205,15 @@ protected:
     PRESENT_METHOD_BOB,
   };
 
+  enum ERENDERSTATE
+  {
+    STATE_UNCONFIGURED = 0,
+    STATE_CONFIGURING,
+    STATE_CONFIGURED,
+  };
+  ERENDERSTATE m_renderState;
+  CEvent m_stateEvent;
+
   double m_displayLatency;
   void UpdateDisplayLatency();
 
@@ -238,6 +233,12 @@ protected:
   std::deque<int> m_discard;
 
   ERenderFormat m_format;
+  unsigned int m_width, m_height, m_dwidth, m_dheight;
+  unsigned int m_flags;
+  float m_fps;
+  unsigned int m_extended_format;
+  unsigned int m_orientation;
+  int m_NumberBuffers;
 
   double m_sleeptime;
   double m_presentpts;
@@ -252,9 +253,6 @@ protected:
   CEvent m_flushEvent;
   double m_clock_framefinish;
 
-  OVERLAY::CRenderer m_overlays;
-  bool m_renderedOverlay;
-
   void RenderCapture(CRenderCapture* capture);
   void RemoveCapture(CRenderCapture* capture);
   CCriticalSection m_captCritSect;
diff --git a/xbmc/cores/VideoRenderers/WinRenderer.cpp b/xbmc/cores/VideoRenderers/WinRenderer.cpp
index 77273ba4c5..ea25f93d05 100644
--- a/xbmc/cores/VideoRenderers/WinRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/WinRenderer.cpp
@@ -135,7 +135,7 @@ void CWinRenderer::SelectRenderMethod()
     if (!m_processor || !m_processor->Open(m_sourceWidth, m_sourceHeight, m_iFlags, m_format, m_extended_format))
     {
       CLog::Log(LOGNOTICE, "D3D: unable to open DXVA processor");
-      if (m_processor)  
+      if (m_processor)
         m_processor->Close();
       m_renderMethod = RENDER_INVALID;
     }
@@ -345,7 +345,7 @@ void CWinRenderer::Update()
   ManageDisplay();
 }
 
-void CWinRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
+void CWinRenderer::RenderUpdate(bool clear, unsigned int flags, unsigned int alpha)
 {
   LPDIRECT3DDEVICE9 pD3DDevice = g_Windowing.Get3DDevice();
 
@@ -357,7 +357,7 @@ void CWinRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
   else
     pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
 
-  if (!m_bConfigured) 
+  if (!m_bConfigured)
     return;
 
   ManageTextures();
@@ -392,7 +392,7 @@ void CWinRenderer::FlipPage(int source)
   return;
 }
 
-unsigned int CWinRenderer::PreInit()
+void CWinRenderer::PreInit()
 {
   CSingleLock lock(g_graphicsContext);
   m_bConfigured = false;
@@ -446,7 +446,6 @@ unsigned int CWinRenderer::PreInit()
     m_formats.push_back(RENDER_FMT_YUYV422);
     m_formats.push_back(RENDER_FMT_UYVY422);
   }
-  return 0;
 }
 
 void CWinRenderer::UnInit()
@@ -461,7 +460,7 @@ void CWinRenderer::UnInit()
 
   SAFE_DELETE(m_colorShader);
   SAFE_DELETE(m_scalerShader);
-  
+
   m_bConfigured = false;
   m_bFilterInitialized = false;
 
@@ -644,7 +643,7 @@ void CWinRenderer::UpdatePSVideoFilter()
   if (m_renderMethod == RENDER_DXVA)
   {
     // we'd use m_IntermediateTarget as rendering target for possible anaglyph stereo with dxva processor.
-    if (!m_bUseHQScaler) 
+    if (!m_bUseHQScaler)
       CreateIntermediateRenderTarget(m_destWidth, m_destHeight);
 
     // When using DXVA, we are already setup at this point, color shader is not needed
@@ -772,7 +771,7 @@ void CWinRenderer::RenderSW()
       srcStride[idx] = srclr[idx].Pitch;
     }
   }
-  
+
   D3DLOCKED_RECT destlr = {0,0};
   if (!m_SWTarget.LockRect(0, &destlr, NULL, D3DLOCK_DISCARD))
     CLog::Log(LOGERROR, __FUNCTION__" - failed to lock swtarget texture into memory");
@@ -799,7 +798,7 @@ void CWinRenderer::RenderSW()
 }
 
 /*
-Code kept for reference, as a basis to re-enable StretchRect and 
+Code kept for reference, as a basis to re-enable StretchRect and
 do the color conversion with it.
 See IDirect3D9::CheckDeviceFormat() for support of non-standard fourcc textures
 and IDirect3D9::CheckDeviceFormatConversion for color conversion support
@@ -985,7 +984,7 @@ void CWinRenderer::Stage1()
     // Restore the render target
     pD3DDevice->SetRenderTarget(0, oldRT);
 
-    // MSDN says: Setting a new render target will cause the viewport 
+    // MSDN says: Setting a new render target will cause the viewport
     // to be set to the full size of the new render target.
     // So we need restore our viewport
     g_Windowing.RestoreViewPort();
@@ -1035,7 +1034,7 @@ void CWinRenderer::RenderProcessor(DWORD flags)
     return;
 
   IDirect3DSurface9* target;
-  if ( m_bUseHQScaler 
+  if ( m_bUseHQScaler
     || g_graphicsContext.GetStereoMode() == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN
     || g_graphicsContext.GetStereoMode() == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA
     || g_graphicsContext.GetStereoMode() == RENDER_STEREO_MODE_ANAGLYPH_YELLOW_BLUE)
diff --git a/xbmc/cores/VideoRenderers/WinRenderer.h b/xbmc/cores/VideoRenderers/WinRenderer.h
index 255ecf050e..a80395c1db 100644
--- a/xbmc/cores/VideoRenderers/WinRenderer.h
+++ b/xbmc/cores/VideoRenderers/WinRenderer.h
@@ -147,7 +147,7 @@ public:
   virtual void         ReleaseImage(int source, bool preserve = false);
   virtual bool         AddVideoPicture(DVDVideoPicture* picture, int index);
   virtual void         FlipPage(int source);
-  virtual unsigned int PreInit();
+  virtual void         PreInit();
   virtual void         UnInit();
   virtual void         Reset(); /* resets renderer after seek for example */
   virtual bool         IsConfigured() { return m_bConfigured; }
@@ -155,6 +155,8 @@ public:
 
   virtual CRenderInfo GetRenderInfo();
 
+  // Feature support
+  virtual bool         SupportsMultiPassRendering() { return false; }
   virtual bool         Supports(ERENDERFEATURE feature);
   virtual bool         Supports(EDEINTERLACEMODE mode);
   virtual bool         Supports(EINTERLACEMETHOD method);
@@ -162,7 +164,7 @@ public:
 
   virtual EINTERLACEMETHOD AutoInterlaceMethod();
 
-  void                 RenderUpdate(bool clear, DWORD flags = 0, DWORD alpha = 255);
+  void                 RenderUpdate(bool clear, unsigned int flags = 0, unsigned int alpha = 255);
 
   virtual void         SetBufferSize(int numBuffers) { m_neededBuffers = numBuffers; }
   virtual void         ReleaseBuffer(int idx);
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 8b92c58d2b..b5dfcac795 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -153,7 +153,6 @@ CDVDPlayerVideo::CDVDPlayerVideo( CDVDClock* pClock
   m_iFrameRateLength = 0;
   m_bFpsInvalid = false;
   m_bAllowFullscreen = false;
-  memset(&m_output, 0, sizeof(m_output));
 }
 
 CDVDPlayerVideo::~CDVDPlayerVideo()
@@ -919,30 +918,6 @@ void CDVDPlayerVideo::ProcessOverlays(DVDVideoPicture* pSource, double pts)
 }
 #endif
 
-static std::string GetRenderFormatName(ERenderFormat format)
-{
-  switch(format)
-  {
-    case RENDER_FMT_YUV420P:   return "YV12";
-    case RENDER_FMT_YUV420P16: return "YV12P16";
-    case RENDER_FMT_YUV420P10: return "YV12P10";
-    case RENDER_FMT_NV12:      return "NV12";
-    case RENDER_FMT_UYVY422:   return "UYVY";
-    case RENDER_FMT_YUYV422:   return "YUY2";
-    case RENDER_FMT_VDPAU:     return "VDPAU";
-    case RENDER_FMT_VDPAU_420: return "VDPAU_420";
-    case RENDER_FMT_DXVA:      return "DXVA";
-    case RENDER_FMT_VAAPI:     return "VAAPI";
-    case RENDER_FMT_VAAPINV12: return "VAAPI_NV12";
-    case RENDER_FMT_OMXEGL:    return "OMXEGL";
-    case RENDER_FMT_CVBREF:    return "BGRA";
-    case RENDER_FMT_BYPASS:    return "BYPASS";
-    case RENDER_FMT_MMAL:      return "MMAL";
-    case RENDER_FMT_NONE:      return "NONE";
-  }
-  return "UNKNOWN";
-}
-
 std::string CDVDPlayerVideo::GetStereoMode()
 {
   std::string  stereo_mode;
@@ -974,91 +949,39 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
 
 #ifdef HAS_VIDEO_PLAYBACK
   double config_framerate = m_bFpsInvalid ? 0.0 : m_fFrameRate;
-  bool changerefresh = !m_bFpsInvalid &&
-                       (m_output.framerate == 0.0 || fmod(m_output.framerate, config_framerate) != 0.0);
-
-  /* check so that our format or aspect has changed. if it has, reconfigure renderer */
-  if (!g_renderManager.IsConfigured()
-   || ( m_output.width           != pPicture->iWidth )
-   || ( m_output.height          != pPicture->iHeight )
-   || ( m_output.dwidth          != pPicture->iDisplayWidth )
-   || ( m_output.dheight         != pPicture->iDisplayHeight )
-   || changerefresh
-   || ( m_output.color_format    != (unsigned int)pPicture->format )
-   || ( m_output.extended_format != pPicture->extended_format )
-   || ( m_output.color_matrix    != pPicture->color_matrix    && pPicture->color_matrix    != 0 ) // don't reconfigure on unspecified
-   || ( m_output.chroma_position != pPicture->chroma_position && pPicture->chroma_position != 0 )
-   || ( m_output.color_primaries != pPicture->color_primaries && pPicture->color_primaries != 0 )
-   || ( m_output.color_transfer  != pPicture->color_transfer  && pPicture->color_transfer  != 0 )
-   || ( m_output.color_range     != pPicture->color_range )
-   || ( m_output.stereo_flags    != stereo_flags))
-  {
-    CLog::Log(LOGNOTICE, " fps: %f, pwidth: %i, pheight: %i, dwidth: %i, dheight: %i"
-                       , config_framerate
-                       , pPicture->iWidth
-                       , pPicture->iHeight
-                       , pPicture->iDisplayWidth
-                       , pPicture->iDisplayHeight);
-
-    unsigned flags = 0;
-    if(pPicture->color_range == 1)
-      flags |= CONF_FLAGS_YUV_FULLRANGE;
 
-    flags |= GetFlagsChromaPosition(pPicture->chroma_position)
-          |  GetFlagsColorMatrix(pPicture->color_matrix, pPicture->iWidth, pPicture->iHeight)
-          |  GetFlagsColorPrimaries(pPicture->color_primaries)
-          |  GetFlagsColorTransfer(pPicture->color_transfer);
+  unsigned flags = 0;
+  if(pPicture->color_range == 1)
+    flags |= CONF_FLAGS_YUV_FULLRANGE;
 
-    std::string formatstr = GetRenderFormatName(pPicture->format);
+  flags |= GetFlagsChromaPosition(pPicture->chroma_position)
+              |  GetFlagsColorMatrix(pPicture->color_matrix, pPicture->iWidth, pPicture->iHeight)
+              |  GetFlagsColorPrimaries(pPicture->color_primaries)
+              |  GetFlagsColorTransfer(pPicture->color_transfer);
 
-    if(m_bAllowFullscreen)
-    {
-      flags |= CONF_FLAGS_FULLSCREEN;
-      m_bAllowFullscreen = false; // only allow on first configure
-    }
 
-    flags |= stereo_flags;
-
-    CLog::Log(LOGDEBUG,"%s - change configuration. %dx%d. framerate: %4.2f. format: %s",__FUNCTION__,pPicture->iWidth, pPicture->iHeight, config_framerate, formatstr.c_str());
-    if(!g_renderManager.Configure(pPicture->iWidth
-                                , pPicture->iHeight
-                                , pPicture->iDisplayWidth
-                                , pPicture->iDisplayHeight
-                                , config_framerate
-                                , flags
-                                , pPicture->format
-                                , pPicture->extended_format
-                                , m_hints.orientation
-                                , m_pVideoCodec->GetAllowedReferences()))
-    {
-      CLog::Log(LOGERROR, "%s - failed to configure renderer", __FUNCTION__);
-      return EOS_ABORT;
-    }
-
-    m_output.width           = pPicture->iWidth;
-    m_output.height          = pPicture->iHeight;
-    m_output.dwidth          = pPicture->iDisplayWidth;
-    m_output.dheight         = pPicture->iDisplayHeight;
-    m_output.framerate       = config_framerate;
-    m_output.color_format    = pPicture->format;
-    m_output.extended_format = pPicture->extended_format;
-    m_output.color_matrix    = pPicture->color_matrix;
-    m_output.chroma_position = pPicture->chroma_position;
-    m_output.color_primaries = pPicture->color_primaries;
-    m_output.color_transfer  = pPicture->color_transfer;
-    m_output.color_range     = pPicture->color_range;
-    m_output.stereo_flags    = stereo_flags;
+  if(m_bAllowFullscreen)
+  {
+    flags |= CONF_FLAGS_FULLSCREEN;
+    m_bAllowFullscreen = false; // only allow on first configure
   }
 
-  int    result  = 0;
+  flags |= stereo_flags;
 
-  if (!g_renderManager.IsStarted()) {
-    CLog::Log(LOGERROR, "%s - renderer not started", __FUNCTION__);
+  if(!g_renderManager.Configure(picture,
+                                config_framerate,
+                                flags,
+                                m_hints.orientation,
+                                m_pVideoCodec->GetAllowedReferences()))
+  {
+    CLog::Log(LOGERROR, "%s - failed to configure renderer", __FUNCTION__);
     return EOS_ABORT;
   }
 
+  int    result  = 0;
+
   //correct any pattern in the timestamps
-  if (m_output.color_format != RENDER_FMT_BYPASS)
+  if (picture.format != RENDER_FMT_BYPASS)
   {
     m_pullupCorrection.Add(pts);
     pts += m_pullupCorrection.GetCorrection();
@@ -1079,7 +1002,7 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
     pts -= DVD_TIME_BASE * interval;
   }
 
-  if (m_output.color_format != RENDER_FMT_BYPASS)
+  if (picture.format != RENDER_FMT_BYPASS)
   {
     // Correct pts by user set delay and rendering delay
     pts += m_iVideoDelay - DVD_SEC_TO_TIME(g_renderManager.GetDisplayLatency());
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.h b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
index 01cf811253..947ac04a93 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
@@ -161,23 +161,6 @@ protected:
 
   bool   m_bFpsInvalid;      // needed to ignore fps (e.g. dvd stills)
 
-  struct SOutputConfiguration
-  {
-    unsigned int width;
-    unsigned int height;
-    unsigned int dwidth;
-    unsigned int dheight;
-    unsigned int color_format;
-    unsigned int extended_format;
-    unsigned int color_matrix : 4;
-    unsigned int color_range  : 1;
-    unsigned int chroma_position;
-    unsigned int color_primaries;
-    unsigned int color_transfer;
-    unsigned int stereo_flags;
-    double       framerate;
-  } m_output; //holds currently configured output
-
   bool m_bAllowFullscreen;
   bool m_bRenderSubs;
 
diff --git a/xbmc/guilib/GUIVideoControl.cpp b/xbmc/guilib/GUIVideoControl.cpp
index 26d54c9e86..1cb593b5ef 100644
--- a/xbmc/guilib/GUIVideoControl.cpp
+++ b/xbmc/guilib/GUIVideoControl.cpp
@@ -53,7 +53,7 @@ void CGUIVideoControl::Render()
   // don't render if we aren't playing video, or if the renderer isn't started
   // (otherwise the lock we have from CApplication::Render() may clash with the startup
   // locks in the RenderManager.)
-  if (g_application.m_pPlayer->IsPlayingVideo() && g_renderManager.IsStarted())
+  if (g_application.m_pPlayer->IsPlayingVideo() && g_renderManager.IsConfigured())
   {
 #else
   if (g_application.m_pPlayer->IsPlayingVideo())
@@ -99,7 +99,7 @@ void CGUIVideoControl::Render()
 void CGUIVideoControl::RenderEx()
 {
 #ifdef HAS_VIDEO_PLAYBACK
-  if (g_application.m_pPlayer->IsPlayingVideo() && g_renderManager.IsStarted())
+  if (g_application.m_pPlayer->IsPlayingVideo() && g_renderManager.IsConfigured())
     g_renderManager.Render(false, 0, 255, false);
   g_renderManager.FrameFinish();
 #endif

From 1485bf75bc953f5bfbc86c93cab7b6c84e10d691 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 4 Jun 2015 09:48:31 +0200
Subject: [PATCH 03/41] X11: add EGL

---
 system/shaders/yuv2rgb_basic.glsl                  |   2 +-
 .../VideoRenderers/HwDecRender/RendererVAAPI.cpp   | 138 ++----
 .../VideoRenderers/HwDecRender/RendererVDPAU.cpp   |   3 +-
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp      |  21 +-
 xbmc/cores/VideoRenderers/RenderManager.cpp        |   2 +-
 .../VideoShaders/VideoFilterShader.cpp             |   3 +-
 .../VideoRenderers/VideoShaders/YUV2RGBShader.cpp  |   4 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp     | 515 ++++++++++++---------
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h       |  53 ++-
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp     |   4 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h       |   7 +-
 xbmc/guilib/Shader.cpp                             |  48 --
 xbmc/rendering/gl/RenderSystemGL.cpp               |  26 +-
 xbmc/system_gl.h                                   |   4 +-
 xbmc/windowing/WindowingFactory.h                  |   7 +-
 xbmc/windowing/X11/GLContext.h                     |  68 +++
 xbmc/windowing/X11/GLContextEGL.cpp                | 367 +++++++++++++++
 xbmc/windowing/X11/GLContextEGL.h                  |  44 ++
 xbmc/windowing/X11/GLContextGLX.cpp                | 309 +++++++++++++
 .../X11/{WinSystemX11GL.h => GLContextGLX.h}       |  49 +-
 xbmc/windowing/X11/Makefile                        |   5 +-
 xbmc/windowing/X11/WinSystemX11.cpp                | 438 +-----------------
 xbmc/windowing/X11/WinSystemX11.h                  |  73 +--
 xbmc/windowing/X11/WinSystemX11GL.cpp              | 221 ---------
 xbmc/windowing/X11/WinSystemX11GLContext.cpp       | 196 ++++++++
 xbmc/windowing/X11/WinSystemX11GLContext.h         |  66 +++
 xbmc/windowing/X11/WinSystemX11GLES.cpp            | 107 -----
 xbmc/windowing/X11/WinSystemX11GLES.h              |  50 --
 xbmc/windowing/windows/WinSystemWin32GL.cpp        |   1 -
 29 files changed, 1512 insertions(+), 1319 deletions(-)
 create mode 100644 xbmc/windowing/X11/GLContext.h
 create mode 100644 xbmc/windowing/X11/GLContextEGL.cpp
 create mode 100644 xbmc/windowing/X11/GLContextEGL.h
 create mode 100644 xbmc/windowing/X11/GLContextGLX.cpp
 rename xbmc/windowing/X11/{WinSystemX11GL.h => GLContextGLX.h} (50%)
 delete mode 100644 xbmc/windowing/X11/WinSystemX11GL.cpp
 create mode 100644 xbmc/windowing/X11/WinSystemX11GLContext.cpp
 create mode 100644 xbmc/windowing/X11/WinSystemX11GLContext.h
 delete mode 100644 xbmc/windowing/X11/WinSystemX11GLES.cpp
 delete mode 100644 xbmc/windowing/X11/WinSystemX11GLES.h

diff --git a/system/shaders/yuv2rgb_basic.glsl b/system/shaders/yuv2rgb_basic.glsl
index aa26174acc..7e97046e72 100644
--- a/system/shaders/yuv2rgb_basic.glsl
+++ b/system/shaders/yuv2rgb_basic.glsl
@@ -70,7 +70,7 @@ void main()
   rgb.a = gl_Color.a;
   gl_FragColor = rgb;
 
-#elif defined(XBMC_VDPAU_NV12)
+#elif defined(XBMC_NV12_RRG)
 
   vec4 yuv, rgb;
   yuv.rgba = vec4( texture2D(m_sampY, stretch(m_cordY)).r
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp b/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
index 053ccd3c6c..2b8a0d45c5 100644
--- a/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVAAPI.cpp
@@ -27,6 +27,7 @@
 #include "settings/GUISettings.h"
 #include "settings/AdvancedSettings.h"
 #include "utils/log.h"
+#include "utils/GLUtils.h"
 
 CRendererVAAPI::CRendererVAAPI()
 {
@@ -79,19 +80,7 @@ CRenderInfo CRendererVAAPI::GetRenderInfo()
 
 bool CRendererVAAPI::Supports(ERENDERFEATURE feature)
 {
-  if (m_format == RENDER_FMT_VAAPINV12)
-    return CLinuxRendererGL::Supports(feature);
-
-  if (feature == RENDERFEATURE_STRETCH         ||
-      feature == RENDERFEATURE_ZOOM            ||
-      feature == RENDERFEATURE_VERTICAL_SHIFT  ||
-      feature == RENDERFEATURE_PIXEL_RATIO     ||
-      feature == RENDERFEATURE_POSTPROCESS     ||
-      feature == RENDERFEATURE_ROTATION        ||
-      feature == RENDERFEATURE_NONLINSTRETCH)
-    return true;
-
-  return false;
+  return CLinuxRendererGL::Supports(feature);
 }
 
 bool CRendererVAAPI::Supports(EINTERLACEMETHOD method)
@@ -104,67 +93,17 @@ bool CRendererVAAPI::Supports(EINTERLACEMETHOD method)
 
 bool CRendererVAAPI::Supports(ESCALINGMETHOD method)
 {
-  if (m_format == RENDER_FMT_VAAPINV12)
-    return CLinuxRendererGL::Supports(method);
-
-  //nearest neighbor doesn't work on YUY2 and UYVY
-  if (method == VS_SCALINGMETHOD_NEAREST &&
-      m_format != RENDER_FMT_YUYV422 &&
-      m_format != RENDER_FMT_UYVY422)
-    return true;
-
-  if(method == VS_SCALINGMETHOD_LINEAR
-  || method == VS_SCALINGMETHOD_AUTO)
-    return true;
-
-  if(method == VS_SCALINGMETHOD_CUBIC
-  || method == VS_SCALINGMETHOD_LANCZOS2
-  || method == VS_SCALINGMETHOD_SPLINE36_FAST
-  || method == VS_SCALINGMETHOD_LANCZOS3_FAST
-  || method == VS_SCALINGMETHOD_SPLINE36
-  || method == VS_SCALINGMETHOD_LANCZOS3)
-  {
-    // if scaling is below level, avoid hq scaling
-    float scaleX = fabs(((float)m_sourceWidth - m_destRect.Width())/m_sourceWidth)*100;
-    float scaleY = fabs(((float)m_sourceHeight - m_destRect.Height())/m_sourceHeight)*100;
-    int minScale = g_guiSettings.GetInt("videoplayer.hqscalers");
-    if (scaleX < minScale && scaleY < minScale)
-      return false;
-
-    // spline36 and lanczos3 are only allowed through advancedsettings.xml
-    if(method != VS_SCALINGMETHOD_SPLINE36
-        && method != VS_SCALINGMETHOD_LANCZOS3)
-      return true;
-    else
-      return g_advancedSettings.m_videoEnableHighQualityHwScalers;
-  }
-
-  return false;
+  return CLinuxRendererGL::Supports(method);
 }
 
 bool CRendererVAAPI::LoadShadersHook()
 {
-  if (m_format == RENDER_FMT_VAAPINV12)
-    return false;
-
-  CLog::Log(LOGNOTICE, "GL: Using VAAPI render method");
-  m_renderMethod = RENDER_VAAPI;
-  return true;
+  return false;
 }
 
 bool CRendererVAAPI::RenderHook(int idx)
 {
-  if (m_format == RENDER_FMT_VAAPINV12)
-    return false;
-
-  UpdateVideoFilter();
-  RenderRGB(idx, m_currentField);
-  YUVBUFFER &buf = m_buffers[idx];
-  if (buf.hwDec)
-  {
-    ((VAAPI::CVaapiRenderPicture*)buf.hwDec)->Sync();
-  }
-  return true;
+  return false;
 }
 
 bool CRendererVAAPI::CreateTexture(int index)
@@ -184,9 +123,8 @@ bool CRendererVAAPI::CreateTexture(int index)
   memset(&fields, 0, sizeof(fields));
   im.height = m_sourceHeight;
   im.width  = m_sourceWidth;
-
-  plane.texwidth  = im.width;
-  plane.texheight = im.height;
+  im.cshift_x = 1;
+  im.cshift_y = 1;
 
   plane.pixpertex_x = 1;
   plane.pixpertex_y = 1;
@@ -204,11 +142,14 @@ void CRendererVAAPI::DeleteTexture(int index)
     return;
   }
 
-  YUVPLANE &plane = m_buffers[index].fields[FIELD_FULL][0];
   if (m_buffers[index].hwDec)
     ((VAAPI::CVaapiRenderPicture*)m_buffers[index].hwDec)->Release();
   m_buffers[index].hwDec = NULL;
-  plane.id = 0;
+
+  YUVFIELDS &fields = m_buffers[index].fields;
+  fields[FIELD_FULL][0].id = None;
+  fields[FIELD_FULL][1].id = None;
+  fields[FIELD_FULL][2].id = None;
 }
 
 bool CRendererVAAPI::UploadTexture(int index)
@@ -220,43 +161,52 @@ bool CRendererVAAPI::UploadTexture(int index)
 
   VAAPI::CVaapiRenderPicture *vaapi = (VAAPI::CVaapiRenderPicture*)m_buffers[index].hwDec;
 
+  YV12Image &im = m_buffers[index].image;
+
   YUVFIELDS &fields = m_buffers[index].fields;
-  YUVPLANE &plane = fields[FIELD_FULL][0];
 
   if (!vaapi || !vaapi->valid)
   {
     return false;
   }
 
-  if (!vaapi->CopyGlx())
-    return false;
+  YUVPLANES &planes = fields[0];
 
-  plane.id = vaapi->texture;
+  planes[0].texwidth  = vaapi->texWidth;
+  planes[0].texheight = vaapi->texHeight;
 
-  // in stereoscopic mode sourceRect may only
-  // be a part of the source video surface
-  plane.rect = m_sourceRect;
+  planes[1].texwidth  = planes[0].texwidth  >> im.cshift_x;
+  planes[1].texheight = planes[0].texheight >> im.cshift_y;
+  planes[2].texwidth  = planes[1].texwidth;
+  planes[2].texheight = planes[1].texheight;
 
-  // clip rect
-  if (vaapi->crop.x1 > plane.rect.x1)
-    plane.rect.x1 = vaapi->crop.x1;
-  if (vaapi->crop.x2 < plane.rect.x2)
-    plane.rect.x2 = vaapi->crop.x2;
-  if (vaapi->crop.y1 > plane.rect.y1)
-    plane.rect.y1 = vaapi->crop.y1;
-  if (vaapi->crop.y2 < plane.rect.y2)
-    plane.rect.y2 = vaapi->crop.y2;
+  for (int p = 0; p < 3; p++)
+  {
+    planes[p].pixpertex_x = 1;
+    planes[p].pixpertex_y = 1;
+  }
 
-  plane.texheight = vaapi->texHeight;
-  plane.texwidth  = vaapi->texWidth;
+  // set textures
+  fields[0][0].id = vaapi->textureY;
+  fields[0][1].id = vaapi->textureVU;
+  fields[0][2].id = vaapi->textureVU;
 
-  if (m_textureTarget == GL_TEXTURE_2D)
+  glEnable(m_textureTarget);
+
+  for (int p=0; p<2; p++)
   {
-    plane.rect.y1 /= plane.texheight;
-    plane.rect.y2 /= plane.texheight;
-    plane.rect.x1 /= plane.texwidth;
-    plane.rect.x2 /= plane.texwidth;
+    glBindTexture(m_textureTarget,fields[0][p].id);
+    glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+
+    glBindTexture(m_textureTarget, 0);
+    VerifyGLState();
   }
+
+  CalculateTextureSourceRects(index, 3);
+  glDisable(m_textureTarget);
   return true;
 }
 
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp
index 1162b49201..799e0b45fb 100644
--- a/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp
@@ -27,6 +27,7 @@
 #include "settings/AdvancedSettings.h"
 #include "utils/log.h"
 #include "utils/GLUtils.h"
+#include "windowing/WindowingFactory.h"
 
 CRendererVDPAU::CRendererVDPAU()
 {
@@ -78,7 +79,7 @@ bool CRendererVDPAU::Supports(ERENDERFEATURE feature)
 
     return (m_renderMethod & RENDER_GLSL)
         || (m_renderMethod & RENDER_ARB)
-        || ((m_renderMethod & RENDER_SW) && glewIsSupported("GL_ARB_imaging") == GL_TRUE);
+        || ((m_renderMethod & RENDER_SW) && g_Windowing.IsExtSupported("GL_ARB_imaging") == GL_TRUE);
   }
   else if (feature == RENDERFEATURE_NOISE ||
            feature == RENDERFEATURE_SHARPNESS)
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index be9df52dab..5d06a05a00 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -213,7 +213,8 @@ bool CLinuxRendererGL::ValidateRenderTarget()
 {
   if (!m_bValidated)
   {
-    if (!glewIsSupported("GL_ARB_texture_non_power_of_two") && glewIsSupported("GL_ARB_texture_rectangle"))
+    if (!g_Windowing.IsExtSupported("GL_ARB_texture_non_power_of_two") &&
+         g_Windowing.IsExtSupported("GL_ARB_texture_rectangle"))
     {
       m_textureTarget = GL_TEXTURE_RECTANGLE_ARB;
     }
@@ -278,7 +279,7 @@ bool CLinuxRendererGL::Configure(unsigned int width, unsigned int height, unsign
   m_nonLinStretchGui = false;
   m_pixelRatio       = 1.0;
 
-  m_pboSupported = glewIsSupported("GL_ARB_pixel_buffer_object");
+  m_pboSupported = g_Windowing.IsExtSupported("GL_ARB_pixel_buffer_object");
 
 #ifdef TARGET_DARWIN_OSX
   // on osx 10.9 mavericks we get a strange ripple
@@ -917,7 +918,7 @@ void CLinuxRendererGL::LoadShaders(int field)
       }
       case RENDER_METHOD_ARB:
       // Try ARB shaders if supported and user requested it or GLSL shaders failed.
-      if (glewIsSupported("GL_ARB_fragment_program"))
+      if (g_Windowing.IsExtSupported("GL_ARB_fragment_program"))
       {
         CLog::Log(LOGNOTICE, "GL: ARB shaders support detected");
         m_renderMethod = RENDER_ARB ;
@@ -953,9 +954,9 @@ void CLinuxRendererGL::LoadShaders(int field)
   }
 
   // determine whether GPU supports NPOT textures
-  if (!glewIsSupported("GL_ARB_texture_non_power_of_two"))
+  if (!g_Windowing.IsExtSupported("GL_ARB_texture_non_power_of_two"))
   {
-    if (!glewIsSupported("GL_ARB_texture_rectangle"))
+    if (!g_Windowing.IsExtSupported("GL_ARB_texture_rectangle"))
     {
       CLog::Log(LOGNOTICE, "GL: GL_ARB_texture_rectangle not supported and OpenGL version is not 2.x");
       CLog::Log(LOGNOTICE, "GL: Reverting to POT textures");
@@ -2637,7 +2638,7 @@ bool CLinuxRendererGL::UploadRGBTexture(int source)
   if (imaging==-1)
   {
     imaging = 0;
-    if (glewIsSupported("GL_ARB_imaging"))
+    if (g_Windowing.IsExtSupported("GL_ARB_imaging"))
     {
       CLog::Log(LOGINFO, "GL: ARB Imaging extension supported");
       imaging = 1;
@@ -2751,14 +2752,14 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
   {
     return (m_renderMethod & RENDER_GLSL)
         || (m_renderMethod & RENDER_ARB)
-        || ((m_renderMethod & RENDER_SW) && glewIsSupported("GL_ARB_imaging") == GL_TRUE);
+        || ((m_renderMethod & RENDER_SW) && g_Windowing.IsExtSupported("GL_ARB_imaging") == GL_TRUE);
   }
   
   if(feature == RENDERFEATURE_CONTRAST)
   {
     return (m_renderMethod & RENDER_GLSL)
         || (m_renderMethod & RENDER_ARB)
-        || ((m_renderMethod & RENDER_SW) && glewIsSupported("GL_ARB_imaging") == GL_TRUE);
+        || ((m_renderMethod & RENDER_SW) && g_Windowing.IsExtSupported("GL_ARB_imaging") == GL_TRUE);
   }
 
   if(feature == RENDERFEATURE_GAMMA)
@@ -2791,7 +2792,7 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
 
 bool CLinuxRendererGL::SupportsMultiPassRendering()
 {
-  return glewIsSupported("GL_EXT_framebuffer_object") && glCreateProgram;
+  return g_Windowing.IsExtSupported("GL_EXT_framebuffer_object") && glCreateProgram;
 }
 
 bool CLinuxRendererGL::Supports(EDEINTERLACEMODE mode)
@@ -2856,7 +2857,7 @@ bool CLinuxRendererGL::Supports(ESCALINGMETHOD method)
     if (scaleX < minScale && scaleY < minScale)
       return false;
 
-    if (glewIsSupported("GL_EXT_framebuffer_object") && (m_renderMethod & RENDER_GLSL))
+    if (g_Windowing.IsExtSupported("GL_EXT_framebuffer_object") && (m_renderMethod & RENDER_GLSL))
     {
       // spline36 and lanczos3 are only allowed through advancedsettings.xml
       if(method != VS_SCALINGMETHOD_SPLINE36
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 77b00ef9c1..13150323f2 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -1065,7 +1065,7 @@ void CXBMCRenderManager::UpdateDisplayLatency()
   if (g_graphicsContext.GetVideoResolution() == RES_WINDOW)
     refresh = 0; // No idea about refresh rate when windowed, just get the default latency
   m_displayLatency = (double) g_advancedSettings.GetDisplayLatency(refresh);
-  CLog::Log(LOGDEBUG, "CRenderManager::UpdateDisplayLatency - Latency set to %1.0f msec", m_displayLatency * 1000.0f);
+  //CLog::Log(LOGDEBUG, "CRenderManager::UpdateDisplayLatency - Latency set to %1.0f msec", m_displayLatency * 1000.0f);
 }
 
 void CXBMCRenderManager::UpdateResolution()
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
index 2f28ef0514..dcfd146f1c 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
@@ -28,6 +28,7 @@
 #include "utils/log.h"
 #include "utils/GLUtils.h"
 #include "ConvolutionKernels.h"
+#include "windowing/WindowingFactory.h"
 
 #if defined(HAS_GL)
   #define USE1DTEXTURE
@@ -84,7 +85,7 @@ ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool str
   std::string defines;
 
 #if defined(HAS_GL)
-  m_floattex = glewIsSupported("GL_ARB_texture_float");
+  m_floattex = g_Windowing.IsExtSupported("GL_ARB_texture_float");
 #elif HAS_GLES == 2
   m_floattex = false;
 #endif
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
index c9ed91563a..f45b7583a1 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
@@ -215,7 +215,9 @@ BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderF
   else if (m_format == RENDER_FMT_UYVY422 || m_format == RENDER_FMT_CVBREF)
     m_defines += "#define XBMC_UYVY\n";
   else if (m_format == RENDER_FMT_VDPAU_420)
-    m_defines += "#define XBMC_VDPAU_NV12\n";
+    m_defines += "#define XBMC_NV12_RRG\n";
+  else if (m_format == RENDER_FMT_VAAPI)
+    m_defines += "#define XBMC_NV12_RRG\n";
   else
     CLog::Log(LOGERROR, "GL: BaseYUV2RGBGLSLShader - unsupported format %d", m_format);
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index f533602d01..716ae8dd26 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -19,8 +19,8 @@
  */
 #include "system.h"
 #ifdef HAVE_LIBVA
-#include "windowing/WindowingFactory.h"
 #include "VAAPI.h"
+#include "windowing/WindowingFactory.h"
 #include "DVDVideoCodec.h"
 #include "cores/dvdplayer/DVDCodecs/DVDCodecUtils.h"
 #include "cores/dvdplayer/DVDClock.h"
@@ -32,6 +32,8 @@
 #include "settings/GUISettings.h"
 #include "settings/AdvancedSettings.h"
 #include <va/va_x11.h>
+#include <va/va_drmcommon.h>
+#include <drm_fourcc.h>
 
 extern "C" {
 #include "libavutil/avutil.h"
@@ -40,11 +42,6 @@ extern "C" {
 #include "libavfilter/buffersrc.h"
 }
 
-#ifndef VA_SURFACE_ATTRIB_SETTABLE
-#define vaCreateSurfaces(d, f, w, h, s, ns, a, na) \
-vaCreateSurfaces(d, w, h, f, ns, s)
-#endif
-
 #if VA_CHECK_VERSION(0,34,0)
 #include <va/va_vpp.h>
 #define HAVE_VPP 1
@@ -1191,92 +1188,200 @@ void CVaapiRenderPicture::ReturnUnused()
     vaapi->ReturnRenderPicture(this);
 }
 
-bool CVaapiRenderPicture::CopyGlx()
+void CVaapiRenderPicture::Sync()
 {
+#ifdef GL_ARB_sync
   CSingleLock lock(renderPicSection);
-
-  if (glx.bound == true)
-    return true;
-
-  if (glx.procPic.source == CVaapiProcessedPicture::SKIP_SRC ||
-      glx.procPic.source == CVaapiProcessedPicture::VPP_SRC)
+  if (usefence)
   {
-    unsigned int colorStandard;
-    switch(glx.procPic.DVDPic.color_matrix)
+    if(glIsSync(fence))
     {
-      case AVCOL_SPC_BT709:
-        colorStandard = VA_SRC_BT709;
-        break;
-      case AVCOL_SPC_BT470BG:
-      case AVCOL_SPC_SMPTE170M:
-        colorStandard = VA_SRC_BT601;
-        break;
-      case AVCOL_SPC_SMPTE240M:
-      case AVCOL_SPC_FCC:
-      case AVCOL_SPC_UNSPECIFIED:
-      case AVCOL_SPC_RGB:
-      default:
-        if(texWidth > 1000)
-          colorStandard = VA_SRC_BT709;
-        else
-          colorStandard = VA_SRC_BT601;
+      glDeleteSync(fence);
+      fence = None;
     }
+    fence = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
+  }
+#endif
+}
 
-    if (vaSyncSurface(glx.vadsp, glx.procPic.videoSurface) != VA_STATUS_SUCCESS)
-      return false;
+bool CVaapiRenderPicture::GLMapSurface()
+{
+  VAStatus status;
+  glInterop.vaImage.image_id = VA_INVALID_ID;
 
-    if (vaPutSurface(glx.vadsp,
-                     glx.procPic.videoSurface,
-                     glx.pixmap,
-                     0,0,
-                     texWidth, texHeight,
-                     0,0,
-                     texWidth, texHeight,
-                     NULL,0,
-                     VA_FRAME_PICTURE | colorStandard) != VA_STATUS_SUCCESS)
-    {
-      return false;
+  vaSyncSurface(glInterop.vadsp, glInterop.procPic.videoSurface);
+
+  status = vaDeriveImage(glInterop.vadsp, glInterop.procPic.videoSurface,
+                                                  &glInterop.vaImage);
+  if (status != VA_STATUS_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "VAAPI::%s - Error: %s(%d)", __FUNCTION__, vaErrorStr(status), status);
+    return false;
+  }
+  memset(&glInterop.vBufInfo, 0, sizeof(glInterop.vBufInfo));
+  glInterop.vBufInfo.mem_type = VA_SURFACE_ATTRIB_MEM_TYPE_DRM_PRIME;
+  status = vaAcquireBufferHandle(glInterop.vadsp, glInterop.vaImage.buf,
+                                 &glInterop.vBufInfo);
+  if (status != VA_STATUS_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "VAAPI::%s - Error: %s(%d)", __FUNCTION__, vaErrorStr(status), status);
+    return false;
+  }
+
+  texWidth = glInterop.vaImage.width;
+  texHeight = glInterop.vaImage.height;
+
+  GLint attribs[23], *attrib;
+
+  switch (glInterop.vaImage.format.fourcc)
+  {
+    case VA_FOURCC('N','V','1','2'):
+    {
+      attrib = attribs;
+      *attrib++ = EGL_LINUX_DRM_FOURCC_EXT;
+      *attrib++ = fourcc_code('R', '8', ' ', ' ');
+      *attrib++ = EGL_WIDTH;
+      *attrib++ = glInterop.vaImage.width;
+      *attrib++ = EGL_HEIGHT;
+      *attrib++ = glInterop.vaImage.height;
+      *attrib++ = EGL_DMA_BUF_PLANE0_FD_EXT;
+      *attrib++ = (intptr_t)glInterop.vBufInfo.handle;
+      *attrib++ = EGL_DMA_BUF_PLANE0_OFFSET_EXT;
+      *attrib++ = glInterop.vaImage.offsets[0];
+      *attrib++ = EGL_DMA_BUF_PLANE0_PITCH_EXT;
+      *attrib++ = glInterop.vaImage.pitches[0];
+      *attrib++ = EGL_NONE;
+      glInterop.eglImageY = glInterop.eglCreateImageKHR(glInterop.eglDisplay,
+                                          EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, (EGLClientBuffer)NULL,
+                                          attribs);
+      if (!glInterop.eglImageY)
+      {
+        EGLint err = eglGetError();
+        CLog::Log(LOGERROR, "failed to import VA buffer NV12 into EGL image: %d", err);
+        return false;
+      }
+
+      attrib = attribs;
+      *attrib++ = EGL_LINUX_DRM_FOURCC_EXT;
+      *attrib++ = fourcc_code('G', 'R', '8', '8');
+      *attrib++ = EGL_WIDTH;
+      *attrib++ = (glInterop.vaImage.width + 1) >> 1;
+      *attrib++ = EGL_HEIGHT;
+      *attrib++ = (glInterop.vaImage.height + 1) >> 1;
+      *attrib++ = EGL_DMA_BUF_PLANE0_FD_EXT;
+      *attrib++ = (intptr_t)glInterop.vBufInfo.handle;
+      *attrib++ = EGL_DMA_BUF_PLANE0_OFFSET_EXT;
+      *attrib++ = glInterop.vaImage.offsets[1];
+      *attrib++ = EGL_DMA_BUF_PLANE0_PITCH_EXT;
+      *attrib++ = glInterop.vaImage.pitches[1];
+      *attrib++ = EGL_NONE;
+      glInterop.eglImageVU = glInterop.eglCreateImageKHR(glInterop.eglDisplay,
+                                          EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, (EGLClientBuffer)NULL,
+                                          attribs);
+      if (!glInterop.eglImageVU)
+      {
+        EGLint err = eglGetError();
+        CLog::Log(LOGERROR, "failed to import VA buffer NV12 into EGL image: %d", err);
+        return false;
+      }
+
+      GLint format;
+
+      glGenTextures(1, &textureY);
+      glEnable(glInterop.textureTarget);
+      glBindTexture(glInterop.textureTarget, textureY);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+      glInterop.glEGLImageTargetTexture2DOES(glInterop.textureTarget, glInterop.eglImageY);
+      glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_FORMAT, &format);
+
+      glGenTextures(1, &textureVU);
+      glEnable(glInterop.textureTarget);
+      glBindTexture(glInterop.textureTarget, textureVU);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+      glInterop.glEGLImageTargetTexture2DOES(glInterop.textureTarget, glInterop.eglImageVU);
+      glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_FORMAT, &format);
+
+      glBindTexture(glInterop.textureTarget, 0);
+      glDisable(glInterop.textureTarget);
+
+      break;
     }
+    case VA_FOURCC('B','G','R','A'):
+    {
+      attrib = attribs;
+      *attrib++ = EGL_DRM_BUFFER_FORMAT_MESA;
+      *attrib++ = EGL_DRM_BUFFER_FORMAT_ARGB32_MESA;
+      *attrib++ = EGL_WIDTH;
+      *attrib++ = glInterop.vaImage.width;
+      *attrib++ = EGL_HEIGHT;
+      *attrib++ = glInterop.vaImage.height;
+      *attrib++ = EGL_DRM_BUFFER_STRIDE_MESA;
+      *attrib++ = glInterop.vaImage.pitches[0] / 4;
+      *attrib++ = EGL_NONE;
+      glInterop.eglImage = glInterop.eglCreateImageKHR(glInterop.eglDisplay, EGL_NO_CONTEXT,
+                                         EGL_DRM_BUFFER_MESA,
+                                         (EGLClientBuffer)glInterop.vBufInfo.handle,
+                                         attribs);
+      if (!glInterop.eglImage)
+      {
+        EGLint err = eglGetError();
+        CLog::Log(LOGERROR, "failed to import VA buffer BGRA into EGL image: %d", err);
+        return false;
+      }
 
-    XSync(glx.x11dsp, false);
-    glEnable(glx.textureTarget);
-    glBindTexture(glx.textureTarget, texture);
-    glx.glXBindTexImageEXT(glx.x11dsp, glx.glPixmap, GLX_FRONT_LEFT_EXT, NULL);
-    glBindTexture(glx.textureTarget, 0);
-    glDisable(glx.textureTarget);
+      glGenTextures(1, &texture);
+      glEnable(glInterop.textureTarget);
+      glBindTexture(glInterop.textureTarget, texture);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+      glTexParameteri(glInterop.textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 
-    glx.bound = true;
+      glInterop.glEGLImageTargetTexture2DOES(glInterop.textureTarget, glInterop.eglImage);
 
-    vaapi->ReturnProcPicture(glx.procPic.id);
-    glx.procPic.id = -1;
+      glBindTexture(glInterop.textureTarget, 0);
+      glDisable(glInterop.textureTarget);
+
+      break;
+    }
+    default:
+      return false;
   }
 
   return true;
 }
 
-void CVaapiRenderPicture::Sync()
+void CVaapiRenderPicture::GLUnMapSurface()
 {
-#ifdef GL_ARB_sync
-  CSingleLock lock(renderPicSection);
-  if (usefence)
+  if (glInterop.vaImage.image_id == VA_INVALID_ID)
+    return;
+
+  glInterop.eglDestroyImageKHR(glInterop.eglDisplay, glInterop.eglImageY);
+  glInterop.eglDestroyImageKHR(glInterop.eglDisplay, glInterop.eglImageVU);
+
+  VAStatus status;
+  status = vaReleaseBufferHandle(glInterop.vadsp, glInterop.vaImage.buf);
+  if (status != VA_STATUS_SUCCESS)
   {
-    if(glIsSync(fence))
-    {
-      glDeleteSync(fence);
-      fence = None;
-    }
-    fence = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
+    CLog::Log(LOGERROR, "VAAPI::%s - Error: %s(%d)", __FUNCTION__, vaErrorStr(status), status);
   }
-#endif
 
-  if (DVDPic.format == RENDER_FMT_VAAPI && glx.bound)
+  status = vaDestroyImage(glInterop.vadsp, glInterop.vaImage.image_id);
+  if (status != VA_STATUS_SUCCESS)
   {
-    glEnable(glx.textureTarget);
-    glBindTexture(glx.textureTarget, texture);
-    glx.glXReleaseTexImageEXT(glx.x11dsp, glx.glPixmap, GLX_FRONT_LEFT_EXT);
-    glBindTexture(glx.textureTarget, 0);
-    glDisable(glx.textureTarget);
+    CLog::Log(LOGERROR, "VAAPI::%s - Error: %s(%d)", __FUNCTION__, vaErrorStr(status), status);
   }
+  glInterop.mapped = false;
+  glInterop.vaImage.image_id = VA_INVALID_ID;
+
+  glDeleteTextures(1, &textureY);
+  glDeleteTextures(1, &textureVU);
 }
 
 //-----------------------------------------------------------------------------
@@ -1634,7 +1739,6 @@ void COutput::StateMachine(int signal, Protocol *port, Message *msg)
             m_config.stats->DecProcessed();
             m_bufferPool.processedPics.pop_front();
             outPic = ProcessPicture(procPic);
-            //ReleaseProcessedPicture(procPic);
             if (outPic)
             {
               m_config.stats->IncRender();
@@ -1737,7 +1841,7 @@ void COutput::Process()
 
 bool COutput::Init()
 {
-  if (!CreateGlxContext())
+  if (!CreateEGLContext())
     return false;
 
   if (!GLInit())
@@ -1770,7 +1874,7 @@ bool COutput::Uninit()
   ReleaseBufferPool();
   delete m_pp;
   m_pp = NULL;
-  DestroyGlxContext();
+  DestroyEGLContext();
   return true;
 }
 
@@ -1935,10 +2039,14 @@ void COutput::InitCycle()
       if (!g_guiSettings.GetBool("videoplayer.prefervaapirender"))
         m_pp = new CFFmpegPostproc();
       else
+      {
         m_pp = new CSkipPostproc();
+        m_config.stats->SetVpp(true);
+      }
       if (m_pp->PreInit(m_config))
       {
         m_pp->Init(method);
+        m_currentDiMethod = method;
       }
       else
       {
@@ -1968,8 +2076,9 @@ CVaapiRenderPicture* COutput::ProcessPicture(CVaapiProcessedPicture &pic)
     pic.id = m_bufferPool.procPicId++;
     m_bufferPool.processedPicsAway.push_back(pic);
     retPic->DVDPic.format = RENDER_FMT_VAAPI;
-    retPic->glx.procPic = pic;
-    retPic->glx.bound = false;
+    retPic->glInterop.procPic = pic;
+    retPic->glInterop.mapped = false;
+    retPic->GLMapSurface();
   }
   else if (pic.source == CVaapiProcessedPicture::FFMPEG_SRC)
   {
@@ -1988,8 +2097,6 @@ CVaapiRenderPicture* COutput::ProcessPicture(CVaapiProcessedPicture &pic)
   retPic->DVDPic.iHeight = m_config.vidHeight;
 
   retPic->valid = true;
-  retPic->texWidth = m_config.outWidth;
-  retPic->texHeight = m_config.outHeight;
   retPic->crop.x1 = 0;
   retPic->crop.y1 = 0;
   retPic->crop.x2 = m_config.outWidth;
@@ -2142,7 +2249,8 @@ void COutput::ProcessReturnPicture(CVaapiRenderPicture *pic)
   if (pic->avFrame)
     av_frame_unref(pic->avFrame);
 
-  ProcessReturnProcPicture(pic->glx.procPic.id);
+  pic->GLUnMapSurface();
+  ProcessReturnProcPicture(pic->glInterop.procPic.id);
   pic->valid = false;
 }
 
@@ -2162,73 +2270,20 @@ void COutput::ProcessReturnProcPicture(int id)
 
 bool COutput::EnsureBufferPool()
 {
-  int fbConfigIndex = 0;
-  int num;
-
-  XWindowAttributes wndattribs;
-  XGetWindowAttributes(m_Display, g_Windowing.GetWindow(), &wndattribs);
-
-  int doubleVisAttributes[] = {
-      GLX_RENDER_TYPE, GLX_RGBA_BIT,
-      GLX_RED_SIZE, 8,
-      GLX_GREEN_SIZE, 8,
-      GLX_BLUE_SIZE, 8,
-      GLX_ALPHA_SIZE, 8,
-      GLX_DEPTH_SIZE, 8,
-      GLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT,
-      GLX_BIND_TO_TEXTURE_RGBA_EXT, True,
-      GLX_DOUBLEBUFFER, False,
-      GLX_Y_INVERTED_EXT, True,
-      GLX_X_RENDERABLE, True,
-      None};
-
-  int pixmapAttribs[] = {
-      GLX_TEXTURE_TARGET_EXT, GLX_TEXTURE_2D_EXT,
-      GLX_TEXTURE_FORMAT_EXT, GLX_TEXTURE_FORMAT_RGBA_EXT,
-      None};
-
-  GLXFBConfig *fbConfigs;
-  fbConfigs = glXChooseFBConfig(m_Display, g_Windowing.GetCurrentScreen(), doubleVisAttributes, &num);
-  if (fbConfigs==NULL)
-  {
-    CLog::Log(LOGERROR, "VAAPI::EnsureBufferPool - No compatible framebuffers found");
-    return false;
-  }
-
-  fbConfigIndex = 0;
-
-  // create glx surfaces and avFrames
+  // create avFrames and init interop
   CVaapiRenderPicture *pic;
   for (unsigned int i = 0; i < m_bufferPool.allRenderPics.size(); i++)
   {
     pic = m_bufferPool.allRenderPics[i];
+    pic->glInterop.vadsp = m_config.dpy;
 
-    pic->glx.pixmap = XCreatePixmap(m_Display,
-                                m_Window,
-                                m_config.outWidth,
-                                m_config.outHeight,
-                                wndattribs.depth);
-    if (!pic->glx.pixmap)
-    {
-      CLog::Log(LOGERROR, "VAAPI::COutput::EnsureBufferPool - Unable to create XPixmap");
-      return false;
-    }
-
-    // create gl pixmap
-    pic->glx.glPixmap = glXCreatePixmap(m_Display, fbConfigs[fbConfigIndex], pic->glx.pixmap, pixmapAttribs);
-
-    if (!pic->glx.glPixmap)
-    {
-      CLog::Log(LOGERROR, "VAAPI::COutput::EnsureBufferPool - Could not create glPixmap");
-      return false;
-    }
-
-    glGenTextures(1, &pic->texture);
-    pic->glx.vadsp = m_config.dpy;
-    pic->glx.x11dsp = m_Display;
-    pic->glx.glXBindTexImageEXT = glXBindTexImageEXT;
-    pic->glx.glXReleaseTexImageEXT = glXReleaseTexImageEXT;
-    pic->glx.textureTarget = m_textureTarget;
+    pic->glInterop.eglDisplay = m_eglDisplay;
+    pic->glInterop.textureTarget = m_textureTarget;
+    pic->glInterop.eglCreateImageKHR = eglCreateImageKHR;
+    pic->glInterop.eglDestroyImageKHR = eglDestroyImageKHR;
+    pic->glInterop.glEGLImageTargetTexture2DOES = glEGLImageTargetTexture2DOES;
+    pic->glInterop.vaImage.image_id = VA_INVALID_ID;
+    pic->glInterop.mapped = false;
 
     pic->avFrame = av_frame_alloc();
     pic->valid = false;
@@ -2294,8 +2349,6 @@ void COutput::ReleaseBufferPool(bool precleanup)
     if (pic->texture)
     {
       glDeleteTextures(1, &pic->texture);
-      glXDestroyPixmap(m_Display, pic->glx.glPixmap);
-      XFreePixmap(m_Display, pic->glx.pixmap);
       pic->texture = None;
     }
     av_frame_free(&pic->avFrame);
@@ -2318,22 +2371,24 @@ void COutput::ReleaseBufferPool(bool precleanup)
 bool COutput::GLInit()
 {
 #ifdef GL_ARB_sync
-  bool hasfence = glewIsSupported("GL_ARB_sync");
+  bool hasfence = g_Windowing.IsExtSupported("GL_ARB_sync");
   for (unsigned int i = 0; i < m_bufferPool.allRenderPics.size(); i++)
   {
     m_bufferPool.allRenderPics[i]->usefence = hasfence;
   }
 #endif
 
-  if (!glewIsSupported("GL_ARB_texture_non_power_of_two") && glewIsSupported("GL_ARB_texture_rectangle"))
+  if (!g_Windowing.IsExtSupported("GL_ARB_texture_non_power_of_two") &&
+       g_Windowing.IsExtSupported("GL_ARB_texture_rectangle"))
   {
     m_textureTarget = GL_TEXTURE_RECTANGLE_ARB;
   }
   else
     m_textureTarget = GL_TEXTURE_2D;
 
-  glXBindTexImageEXT = (PFNGLXBINDTEXIMAGEEXTPROC)glXGetProcAddress((GLubyte *) "glXBindTexImageEXT");
-  glXReleaseTexImageEXT = (PFNGLXRELEASETEXIMAGEEXTPROC)glXGetProcAddress((GLubyte *) "glXReleaseTexImageEXT");
+  eglCreateImageKHR = (PFNEGLCREATEIMAGEKHRPROC)eglGetProcAddress("eglCreateImageKHR");
+  eglDestroyImageKHR = (PFNEGLDESTROYIMAGEKHRPROC)eglGetProcAddress("eglDestroyImageKHR");
+  glEGLImageTargetTexture2DOES = (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC)eglGetProcAddress("glEGLImageTargetTexture2DOES");
   return true;
 }
 
@@ -2348,80 +2403,58 @@ bool COutput::CheckSuccess(VAStatus status)
   return true;
 }
 
-bool COutput::CreateGlxContext()
+bool COutput::CreateEGLContext()
 {
-  GLXContext   glContext;
-
   m_Display = g_Windowing.GetDisplay();
-  glContext = g_Windowing.GetGlxContext();
-  m_Window = g_Windowing.GetWindow();
+  EGLDisplay eglDisplay = g_Windowing.GetEGLDisplay();
+  EGLContext eglMainContext = g_Windowing.GetEGLContext();
+  EGLConfig eglMainConfig = g_Windowing.GetEGLConfig();
 
-  // Get our window attribs.
-  XWindowAttributes wndattribs;
-  XGetWindowAttributes(m_Display, m_Window, &wndattribs);
-
-  // Get visual Info
-  XVisualInfo visInfo;
-  visInfo.visualid = wndattribs.visual->visualid;
-  int nvisuals = 0;
-  XVisualInfo* visuals = XGetVisualInfo(m_Display, VisualIDMask, &visInfo, &nvisuals);
-  if (nvisuals != 1)
+  EGLint pbufferAttribs[] =
   {
-    CLog::Log(LOGERROR, "VAAPI::COutput::CreateGlxContext - could not find visual");
-    return false;
-  }
-  visInfo = visuals[0];
-  XFree(visuals);
-
-  m_pixmap = XCreatePixmap(m_Display,
-                           m_Window,
-                           192,
-                           108,
-                           visInfo.depth);
-  if (!m_pixmap)
+    EGL_WIDTH, 8,
+    EGL_HEIGHT, 8,
+    EGL_TEXTURE_TARGET, EGL_NO_TEXTURE,
+    EGL_TEXTURE_FORMAT, EGL_NO_TEXTURE,
+    EGL_NONE
+  };
+  EGLint contextAttributes[] =
   {
-    CLog::Log(LOGERROR, "VAAPI::COutput::CreateGlxContext - Unable to create XPixmap");
-    return false;
-  }
-
-  // create gl pixmap
-  m_glPixmap = glXCreateGLXPixmap(m_Display, &visInfo, m_pixmap);
-
-  if (!m_glPixmap)
+    EGL_CONTEXT_CLIENT_VERSION, 2,
+    EGL_NONE
+  };
+  if (!eglBindAPI(EGL_OPENGL_API))
   {
-    CLog::Log(LOGERROR, "VAAPI::COutput::CreateGlxContext - Could not create glPixmap");
+    CLog::Log(LOGERROR, "VAAPI::COutput::CreateEGLContext -failed to bind egl API");
     return false;
   }
+  m_eglSurface = eglCreatePbufferSurface(eglDisplay, eglMainConfig, pbufferAttribs);
+  m_eglContext = eglCreateContext(eglDisplay, eglMainConfig, eglMainContext, contextAttributes);
+  m_eglDisplay = eglDisplay;
 
-  m_glContext = glXCreateContext(m_Display, &visInfo, glContext, True);
-
-  if (!glXMakeCurrent(m_Display, m_glPixmap, m_glContext))
+  if (!eglMakeCurrent(eglDisplay, m_eglSurface, m_eglSurface, m_eglContext))
   {
-    CLog::Log(LOGERROR, "VAAPI::COutput::CreateGlxContext - Could not make Pixmap current");
+    CLog::Log(LOGERROR, "VAAPI::COutput::CreateEGLContext - Could not make surface current");
     return false;
   }
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-    CLog::Log(LOGDEBUG, "VAAPI::COutput::CreateGlxContext - created context");
+    CLog::Log(LOGDEBUG, "VAAPI::COutput::CreateEGLContext - created context");
   return true;
 }
 
-bool COutput::DestroyGlxContext()
+bool COutput::DestroyEGLContext()
 {
-  if (m_glContext)
+  if (m_eglContext)
   {
     glFinish();
-    glXMakeCurrent(m_Display, None, NULL);
-    glXDestroyContext(m_Display, m_glContext);
+    eglMakeCurrent(m_eglContext, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    eglDestroyContext(m_eglDisplay, m_eglContext);
   }
-  m_glContext = 0;
-
-  if (m_glPixmap)
-    glXDestroyPixmap(m_Display, m_glPixmap);
-  m_glPixmap = 0;
+  m_eglContext = EGL_NO_CONTEXT;
 
-  if (m_pixmap)
-    XFreePixmap(m_Display, m_pixmap);
-  m_pixmap = 0;
+  if (m_eglSurface)
+    eglDestroySurface(m_eglDisplay, m_eglSurface);
+  m_eglSurface = EGL_NO_SURFACE;
 
   return true;
 }
@@ -2518,6 +2551,13 @@ bool CVppPostproc::PreInit(CVaapiConfig &config, SDiMethods *methods)
     return false;
   }
 
+  VASurfaceAttrib attribs[1], *attrib;
+  attrib = attribs;
+  attrib->flags = VA_SURFACE_ATTRIB_SETTABLE;
+  attrib->type = VASurfaceAttribPixelFormat;
+  attrib->value.type = VAGenericValueTypeInteger;
+  attrib->value.value.i = VA_FOURCC_NV12;
+
   // create surfaces
   VASurfaceID surfaces[32];
   int nb_surfaces = NUM_RENDER_PICS;
@@ -2527,7 +2567,7 @@ bool CVppPostproc::PreInit(CVaapiConfig &config, SDiMethods *methods)
                                      m_config.surfaceHeight,
                                      surfaces,
                                      nb_surfaces,
-                                     NULL, 0)))
+                                     attribs, 1)))
   {
     if (g_advancedSettings.CanLogComponent(LOGVIDEO))
       CLog::Log(LOGDEBUG, "CVppPostproc::PreInit  - VPP init failed");
@@ -2629,10 +2669,21 @@ bool CVppPostproc::Init(EINTERLACEMETHOD method)
   case VS_INTERLACEMETHOD_VAAPI_MACI:
     vppMethod = VAProcDeinterlacingMotionCompensated;
     break;
+  case VS_INTERLACEMETHOD_NONE:
+    // vppMethod = VAProcDeinterlacingNone;
+    break;
   default:
     return false;
   }
 
+  m_forwardRefs = 0;
+  m_backwardRefs = 0;
+  m_currentIdx = 0;
+  m_frameCount = 0;
+
+//  if (method == VS_INTERLACEMETHOD_NONE)
+//    return true;
+
   VAProcFilterParameterBufferDeinterlacing filterparams;
   filterparams.type = VAProcFilterDeinterlacing;
   filterparams.algorithm = vppMethod;
@@ -2655,8 +2706,6 @@ bool CVppPostproc::Init(EINTERLACEMETHOD method)
 
   m_forwardRefs = pplCaps.num_forward_references;
   m_backwardRefs = pplCaps.num_backward_references;
-  m_currentIdx = 0;
-  m_frameCount = 0;
 
 #endif
   return true;
@@ -2749,7 +2798,8 @@ bool CVppPostproc::Filter(CVaapiProcessedPicture &outPic)
   outPic.DVDPic = it->DVDPic;
 
   // skip deinterlacing cycle if requested
-  if (m_step == 1 && (outPic.DVDPic.iFlags & DVD_CODEC_CTRL_SKIPDEINT))
+  if ((m_step == 1) &&
+      ((outPic.DVDPic.iFlags & DVD_CODEC_CTRL_SKIPDEINT) || (m_vppMethod == VS_INTERLACEMETHOD_NONE)))
   {
     Advance();
     return false;
@@ -2800,36 +2850,44 @@ bool CVppPostproc::Filter(CVaapiProcessedPicture &outPic)
   int curPic = m_currentIdx;
 
   // deinterlace flag
-  unsigned int flags = 0;
-  if (it->DVDPic.iFlags & DVP_FLAG_TOP_FIELD_FIRST)
-    flags = 0;
-  else
-    flags = VA_DEINTERLACING_BOTTOM_FIELD_FIRST | VA_DEINTERLACING_BOTTOM_FIELD;
-
-  if (m_step)
+  if (m_vppMethod != VS_INTERLACEMETHOD_NONE)
   {
-    if (flags & VA_DEINTERLACING_BOTTOM_FIELD)
-      flags &= ~VA_DEINTERLACING_BOTTOM_FIELD;
+    unsigned int flags = 0;
+    if (it->DVDPic.iFlags & DVP_FLAG_TOP_FIELD_FIRST)
+      flags = 0;
     else
-      flags |= VA_DEINTERLACING_BOTTOM_FIELD;
-  }
-  if (!CheckSuccess(vaMapBuffer(m_config.dpy, m_filter, (void**)&filterParams)))
-  {
-    return false;
+      flags = VA_DEINTERLACING_BOTTOM_FIELD_FIRST | VA_DEINTERLACING_BOTTOM_FIELD;
+
+    if (m_step)
+    {
+      if (flags & VA_DEINTERLACING_BOTTOM_FIELD)
+        flags &= ~VA_DEINTERLACING_BOTTOM_FIELD;
+      else
+        flags |= VA_DEINTERLACING_BOTTOM_FIELD;
+    }
+    if (!CheckSuccess(vaMapBuffer(m_config.dpy, m_filter, (void**)&filterParams)))
+    {
+      return false;
+    }
+    filterParams->flags = flags;
+    if (!CheckSuccess(vaUnmapBuffer(m_config.dpy, m_filter)))
+    {
+      return false;
+    }
+
+    if (m_vppMethod == VS_INTERLACEMETHOD_VAAPI_BOB)
+      pipelineParams->filter_flags = (flags & VA_DEINTERLACING_BOTTOM_FIELD) ? VA_BOTTOM_FIELD : VA_TOP_FIELD;
+    else
+      pipelineParams->filter_flags = 0;
+
+    pipelineParams->filters = &m_filter;
+    pipelineParams->num_filters = 1;
   }
-  filterParams->flags = flags;
-  if (!CheckSuccess(vaUnmapBuffer(m_config.dpy, m_filter)))
+  else
   {
-    return false;
+    pipelineParams->num_filters = 0;
   }
 
-  if (m_vppMethod == VS_INTERLACEMETHOD_VAAPI_BOB)
-    pipelineParams->filter_flags = (flags & VA_DEINTERLACING_BOTTOM_FIELD) ? VA_BOTTOM_FIELD : VA_TOP_FIELD;
-  else
-    pipelineParams->filter_flags = 0;
-  pipelineParams->filters = &m_filter;
-  pipelineParams->num_filters = 1;
-
   // references
   double ptsLast = DVD_NOPTS_VALUE;
   double pts = DVD_NOPTS_VALUE;
@@ -2938,7 +2996,8 @@ bool CVppPostproc::Compatible(EINTERLACEMETHOD method)
 {
   if (method == VS_INTERLACEMETHOD_VAAPI_BOB ||
       method == VS_INTERLACEMETHOD_VAAPI_MADI ||
-      method == VS_INTERLACEMETHOD_VAAPI_MACI)
+      method == VS_INTERLACEMETHOD_VAAPI_MACI ||
+      method == VS_INTERLACEMETHOD_NONE)
     return true;
 
   return false;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
index 2312bbb62f..18769fe968 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
@@ -20,8 +20,8 @@
 #pragma once
 
 #include "system_gl.h"
-#define GLX_GLXEXT_PROTOTYPES
-#include <GL/glx.h>
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
 
 #include "DVDVideoCodec.h"
 #include "DVDVideoCodecFFmpeg.h"
@@ -33,6 +33,7 @@
 #include "threads/Event.h"
 #include "threads/Thread.h"
 #include "utils/ActorProtocol.h"
+#include "guilib/Geometry.h"
 #include <list>
 #include <map>
 #include <memory>
@@ -118,7 +119,6 @@ struct CVaapiConfig
   int upscale;
   CVideoSurfaces *videoSurfaces;
   uint32_t maxReferences;
-  bool useInteropYuv;
   CVAAPIContext *context;
   VADisplay dpy;
   VAProfile profile;
@@ -155,17 +155,23 @@ struct CVaapiProcessedPicture
   bool crop;
 };
 
-struct VaapiGlx
+/**
+ *
+ */
+struct CVaapiGLSurface
 {
-  Display *x11dsp;
+  CVaapiProcessedPicture procPic;
   VADisplay vadsp;
-  Pixmap pixmap;
-  GLXPixmap glPixmap;
+  VAImage vaImage;
+  VABufferInfo vBufInfo;
+  EGLImageKHR eglImage;
+  EGLImageKHR eglImageY, eglImageVU;
   GLenum textureTarget;
-  PFNGLXBINDTEXIMAGEEXTPROC glXBindTexImageEXT;
-  PFNGLXRELEASETEXIMAGEEXTPROC glXReleaseTexImageEXT;
-  CVaapiProcessedPicture procPic;
-  bool bound;
+  EGLDisplay eglDisplay;
+  PFNEGLCREATEIMAGEKHRPROC eglCreateImageKHR;
+  PFNEGLDESTROYIMAGEKHRPROC eglDestroyImageKHR;
+  PFNGLEGLIMAGETARGETTEXTURE2DOESPROC glEGLImageTargetTexture2DOES;
+  bool mapped;
 };
 
 /**
@@ -180,14 +186,14 @@ class CVaapiRenderPicture
   friend class COutput;
 public:
   CVaapiRenderPicture(CCriticalSection &section)
-    : texWidth(0), texHeight(0), texture(None), valid(false), vaapi(NULL), avFrame(NULL),
+    : texWidth(0), texHeight(0), texture(None), textureY(None), textureVU(None), valid(false), vaapi(NULL), avFrame(NULL),
       usefence(false), refCount(0), renderPicSection(section) { fence = None; }
   void Sync();
-  bool CopyGlx();
   DVDVideoPicture DVDPic;
   int texWidth, texHeight;
   CRect crop;
   GLuint texture;
+  GLuint textureY, textureVU;
   bool valid;
   CDecoder *vaapi;
   AVFrame *avFrame;
@@ -195,10 +201,12 @@ public:
   long Release();
 private:
   void ReturnUnused();
+  bool GLMapSurface();
+  void GLUnMapSurface();
   bool usefence;
   GLsync fence;
   int refCount;
-  VaapiGlx glx;
+  CVaapiGLSurface glInterop;
   CCriticalSection &renderPicSection;
 };
 
@@ -301,14 +309,15 @@ protected:
   bool Init();
   bool Uninit();
   void Flush();
-  bool CreateGlxContext();
-  bool DestroyGlxContext();
+  bool CreateEGLContext();
+  bool DestroyEGLContext();
   bool EnsureBufferPool();
   void ReleaseBufferPool(bool precleanup = false);
   bool GLInit();
   bool CheckSuccess(VAStatus status);
-  PFNGLXBINDTEXIMAGEEXTPROC glXBindTexImageEXT;
-  PFNGLXRELEASETEXIMAGEEXTPROC glXReleaseTexImageEXT;
+  PFNEGLCREATEIMAGEKHRPROC eglCreateImageKHR;
+  PFNEGLDESTROYIMAGEKHRPROC eglDestroyImageKHR;
+  PFNGLEGLIMAGETARGETTEXTURE2DOESPROC glEGLImageTargetTexture2DOES;
   CEvent m_outMsgEvent;
   CEvent *m_inMsgEvent;
   int m_state;
@@ -319,12 +328,10 @@ protected:
   bool m_vaError;
   CVaapiConfig m_config;
   VaapiBufferPool m_bufferPool;
+  EGLDisplay m_eglDisplay;
+  EGLSurface m_eglSurface;
+  EGLContext m_eglContext;
   Display *m_Display;
-  Window m_Window;
-  GLXContext m_glContext;
-  GLXWindow m_glWindow;
-  Pixmap    m_pixmap;
-  GLXPixmap m_glPixmap;
   CVaapiDecodedPicture m_currentPicture;
   GLenum m_textureTarget;
   CPostproc *m_pp;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index b58bef2360..2068f5ba91 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -20,9 +20,9 @@
 
 #include "system.h"
 #ifdef HAVE_LIBVDPAU
+#include "VDPAU.h"
 #include <dlfcn.h>
 #include "windowing/WindowingFactory.h"
-#include "VDPAU.h"
 #include "guilib/GraphicContext.h"
 #include "guilib/TextureManager.h"
 #include "cores/VideoRenderers/RenderManager.h"
@@ -3438,7 +3438,7 @@ bool COutput::GLInit()
 #endif
 
 #ifdef GL_ARB_sync
-  bool hasfence = glewIsSupported("GL_ARB_sync");
+  bool hasfence = g_Windowing.IsExtSupported("GL_ARB_sync");
   for (unsigned int i = 0; i < m_bufferPool.allRenderPics.size(); i++)
   {
     m_bufferPool.allRenderPics[i]->usefence = hasfence;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
index dfb62748d3..8cc9154b31 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
@@ -21,14 +21,14 @@
  */
 
 #include "system_gl.h"
+#define GLX_GLXEXT_PROTOTYPES
+#include <GL/glx.h>
+#include <GL/glext.h>
 
 #include "DVDVideoCodec.h"
 #include "DVDVideoCodecFFmpeg.h"
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
-#define GLX_GLXEXT_PROTOTYPES
-#include <GL/glx.h>
-
 #include "DVDVideoCodec.h"
 #include "DVDVideoCodecFFmpeg.h"
 #include "threads/CriticalSection.h"
@@ -38,6 +38,7 @@
 #include "threads/Event.h"
 #include "threads/Thread.h"
 #include "utils/ActorProtocol.h"
+#include "guilib/Geometry.h"
 #include <list>
 #include <map>
 
diff --git a/xbmc/guilib/Shader.cpp b/xbmc/guilib/Shader.cpp
index f37432ada8..fbcaab2270 100644
--- a/xbmc/guilib/Shader.cpp
+++ b/xbmc/guilib/Shader.cpp
@@ -68,14 +68,6 @@ bool CGLSLVertexShader::Compile()
 
   Free();
 
-#ifdef HAS_GL
-  if(!GLEW_VERSION_2_0)
-  {
-    CLog::Log(LOGERROR, "GL: GLSL vertex shaders not supported");
-    return false;
-  }
-#endif
-
   m_vertexShader = glCreateShader(GL_VERTEX_SHADER);
   const char *ptr = m_source.c_str();
   glShaderSource(m_vertexShader, 1, &ptr, 0);
@@ -105,11 +97,6 @@ bool CGLSLVertexShader::Compile()
 
 void CGLSLVertexShader::Free()
 {
-#ifdef HAS_GL
-  if(!GLEW_VERSION_2_0)
-    return;
-#endif
-
   if (m_vertexShader)
     glDeleteShader(m_vertexShader);
   m_vertexShader = 0;
@@ -167,14 +154,6 @@ void CARBVertexShader::Free()
 //////////////////////////////////////////////////////////////////////
 bool CGLSLPixelShader::Compile()
 {
-#ifdef HAS_GL
-  if(!GLEW_VERSION_2_0)
-  {
-    CLog::Log(LOGERROR, "GL: GLSL pixel shaders not supported");
-    return false;
-  }
-#endif
-
   GLint params[4];
 
   Free();
@@ -214,10 +193,6 @@ bool CGLSLPixelShader::Compile()
 
 void CGLSLPixelShader::Free()
 {
-#ifdef HAS_GL
-  if(!GLEW_VERSION_2_0)
-    return;
-#endif
   if (m_pixelShader)
     glDeleteShader(m_pixelShader);
   m_pixelShader = 0;
@@ -279,10 +254,6 @@ void CARBPixelShader::Free()
 //////////////////////////////////////////////////////////////////////
 void CGLSLShaderProgram::Free()
 {
-#ifdef HAS_GL
-  if(!GLEW_VERSION_2_0)
-    return;
-#endif
   m_pVP->Free();
   VerifyGLState();
   m_pFP->Free();
@@ -298,15 +269,6 @@ void CGLSLShaderProgram::Free()
 
 bool CGLSLShaderProgram::CompileAndLink()
 {
-#ifdef HAS_GL
-  // check that we support shaders
-  if(!GLEW_VERSION_2_0)
-  {
-    CLog::Log(LOGERROR, "GL: GLSL shaders not supported");
-    return false;
-  }
-#endif
-
   GLint params[4];
 
   // free resources
@@ -375,11 +337,6 @@ bool CGLSLShaderProgram::CompileAndLink()
 
 bool CGLSLShaderProgram::Enable()
 {
-#ifdef HAS_GL
-  if(!GLEW_VERSION_2_0)
-    return false;
-#endif
-
   if (OK())
   {
     glUseProgram(m_shaderProgram);
@@ -415,11 +372,6 @@ bool CGLSLShaderProgram::Enable()
 
 void CGLSLShaderProgram::Disable()
 {
-#ifdef HAS_GL
-  if(!GLEW_VERSION_2_0)
-    return;
-#endif
-
   if (OK())
   {
     glUseProgram(0);
diff --git a/xbmc/rendering/gl/RenderSystemGL.cpp b/xbmc/rendering/gl/RenderSystemGL.cpp
index bffc696536..eb4eb45510 100644
--- a/xbmc/rendering/gl/RenderSystemGL.cpp
+++ b/xbmc/rendering/gl/RenderSystemGL.cpp
@@ -112,6 +112,7 @@ bool CRenderSystemGL::InitRenderSystem()
   m_maxTextureSize = 2048;
   m_renderCaps = 0;
 
+#if defined(TARGET_DARWIN)
   // init glew library
   GLenum err = glewInit();
   if (GLEW_OK != err)
@@ -120,6 +121,13 @@ bool CRenderSystemGL::InitRenderSystem()
     CLog::Log(LOGERROR, "InitRenderSystem() glewInit returned %i: %s", err, glewGetErrorString(err));
     return false;
   }
+#endif
+
+  m_RenderExtensions  = " ";
+  m_RenderExtensions += (const char*) glGetString(GL_EXTENSIONS);
+  m_RenderExtensions += " ";
+
+  LogGraphicsInfo();
 
   // Get the GL version number
   m_RenderVersionMajor = 0;
@@ -132,7 +140,7 @@ bool CRenderSystemGL::InitRenderSystem()
     m_RenderVersion = ver;
   }
 
-  if (glewIsSupported("GL_ARB_shading_language_100"))
+  if (IsExtSupported("GL_ARB_shading_language_100"))
   {
     ver = (const char*)glGetString(GL_SHADING_LANGUAGE_VERSION);
     if (ver)
@@ -158,10 +166,10 @@ bool CRenderSystemGL::InitRenderSystem()
     m_RenderRenderer = tmpRenderer;
 
   // grab our capabilities
-  if (glewIsSupported("GL_EXT_texture_compression_s3tc"))
+  if (IsExtSupported("GL_EXT_texture_compression_s3tc"))
     m_renderCaps |= RENDER_CAPS_DXT;
 
-  if (glewIsSupported("GL_ARB_texture_non_power_of_two"))
+  if (IsExtSupported("GL_ARB_texture_non_power_of_two"))
   {
     m_renderCaps |= RENDER_CAPS_NPOT;
     if (m_renderCaps & RENDER_CAPS_DXT) 
@@ -170,16 +178,6 @@ bool CRenderSystemGL::InitRenderSystem()
   //Check OpenGL quirks and revert m_renderCaps as needed
   CheckOpenGLQuirks();
 	
-  m_RenderExtensions  = " ";
-
-  const char *tmpExtensions = (const char*) glGetString(GL_EXTENSIONS);
-  if (tmpExtensions != NULL)
-    m_RenderExtensions += tmpExtensions;
-
-  m_RenderExtensions += " ";
-
-  LogGraphicsInfo();
-
   m_bRenderCreated = true;
 
   return true;
@@ -213,7 +211,7 @@ bool CRenderSystemGL::ResetRenderSystem(int width, int height, bool fullScreen,
   glMatrixTexture->LoadIdentity();
   glMatrixTexture.Load();
 
-  if (glewIsSupported("GL_ARB_multitexture"))
+  if (IsExtSupported("GL_ARB_multitexture"))
   {
     //clear error flags
     ResetGLErrors();
diff --git a/xbmc/system_gl.h b/xbmc/system_gl.h
index 4136277131..6feceb5554 100644
--- a/xbmc/system_gl.h
+++ b/xbmc/system_gl.h
@@ -28,15 +28,13 @@
     #define GL_GLEXT_PROTOTYPES
   #endif
   #if defined(TARGET_WINDOWS)
-    #include <GL/glew.h>
     #include <GL/gl.h>
     #include <GL/glu.h>
   #elif defined(TARGET_LINUX)
-    #include <GL/glew.h>
     #include <GL/gl.h>
+    #include <GL/glu.h>
     #include <GL/glext.h>
   #elif defined(TARGET_FREEBSD)
-    #include <GL/glew.h>
     #include <GL/gl.h>
   #elif defined(TARGET_DARWIN)
     #include <GL/glew.h>
diff --git a/xbmc/windowing/WindowingFactory.h b/xbmc/windowing/WindowingFactory.h
index c5ea0ac6e9..38bf2a9aa2 100644
--- a/xbmc/windowing/WindowingFactory.h
+++ b/xbmc/windowing/WindowingFactory.h
@@ -29,11 +29,8 @@
 #elif defined(TARGET_WINDOWS) && defined(HAS_DX)
 #include "windows/WinSystemWin32DX.h"
 
-#elif defined(TARGET_LINUX)   && defined(HAS_EGL)   && defined(HAVE_X11)
-#include "X11/WinSystemX11GLES.h"
-
-#elif defined(TARGET_LINUX)   && defined(HAS_GL)   && defined(HAVE_X11)
-#include "X11/WinSystemX11GL.h"
+#elif defined(TARGET_LINUX)   && defined(HAVE_X11)
+#include "X11/WinSystemX11GLContext.h"
 
 #elif defined(TARGET_LINUX)   && defined(HAS_GLES) && defined(HAS_EGL) && !defined(HAVE_X11)
 #include "egl/WinSystemEGL.h"
diff --git a/xbmc/windowing/X11/GLContext.h b/xbmc/windowing/X11/GLContext.h
new file mode 100644
index 0000000000..f3efdc8130
--- /dev/null
+++ b/xbmc/windowing/X11/GLContext.h
@@ -0,0 +1,68 @@
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#if defined(HAVE_X11)
+#include "GL/glx.h"
+#include "EGL/egl.h"
+#include "X11/Xlib.h"
+#include "guilib/DirtyRegion.h"
+#include <string>
+
+#define EGL_NO_CONFIG (EGLConfig)0
+
+class CGLContext
+{
+public:
+  CGLContext(Display *dpy)
+  {
+    m_dpy = dpy;
+    m_extensions = "";
+    m_glxWindow = 0;
+    m_glxContext = 0;
+    m_eglDisplay = EGL_NO_DISPLAY;
+    m_eglSurface = EGL_NO_SURFACE;
+    m_eglContext = EGL_NO_CONTEXT;
+    m_eglConfig = EGL_NO_CONFIG;
+  }
+  virtual ~CGLContext() {};
+  virtual bool Refresh(bool force, int screen, Window glWindow, bool &newContext) = 0;
+  virtual void Destroy() = 0;
+  virtual void Detach() = 0;
+  virtual void SetVSync(bool enable, int &mode) = 0;
+  virtual bool SwapBuffers(const CDirtyRegionList& dirty, int &mode) = 0;
+  virtual void QueryExtensions() = 0;
+  virtual bool IsExtSupported(const char* extension) = 0;
+
+  std::string ExtPrefix(){ return m_extPrefix; };
+  std::string m_extPrefix;
+  std::string m_extensions;
+
+  Display *m_dpy;
+  GLXWindow m_glxWindow;
+  GLXContext m_glxContext;
+  EGLDisplay m_eglDisplay;
+  EGLSurface m_eglSurface;
+  EGLContext m_eglContext;
+  EGLConfig m_eglConfig;
+};
+
+#endif
diff --git a/xbmc/windowing/X11/GLContextEGL.cpp b/xbmc/windowing/X11/GLContextEGL.cpp
new file mode 100644
index 0000000000..fb00504867
--- /dev/null
+++ b/xbmc/windowing/X11/GLContextEGL.cpp
@@ -0,0 +1,367 @@
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+
+#if defined(HAVE_X11)
+
+#include "GLContextEGL.h"
+#include "utils/log.h"
+
+CGLContextEGL::CGLContextEGL(Display *dpy) : CGLContext(dpy)
+{
+  m_extPrefix = "EGL_";
+}
+
+CGLContextEGL::~CGLContextEGL()
+{
+  Destroy();
+}
+
+bool CGLContextEGL::Refresh(bool force, int screen, Window glWindow, bool &newContext)
+{
+  // refresh context
+  if (m_eglContext && !force)
+  {
+    if (m_eglSurface == EGL_NO_SURFACE)
+    {
+      m_eglSurface = eglCreateWindowSurface(m_eglDisplay, m_eglConfig, glWindow, NULL);
+      if (m_eglSurface == EGL_NO_SURFACE)
+      {
+        CLog::Log(LOGERROR, "failed to create EGL window surface %d\n", eglGetError());
+        return false;
+      }
+    }
+
+    CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshEGLContext: refreshing context");
+    eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    eglMakeCurrent(m_eglDisplay, m_eglSurface, m_eglSurface, m_eglContext);
+    return true;
+  }
+
+  // create context
+  bool retVal = false;
+
+  if (m_eglDisplay == EGL_NO_DISPLAY)
+  {
+    m_eglDisplay = eglGetDisplay((EGLNativeDisplayType)m_dpy);
+    if (m_eglDisplay == EGL_NO_DISPLAY)
+    {
+      CLog::Log(LOGERROR, "failed to get egl display\n");
+      return false;
+    }
+    if (!eglInitialize(m_eglDisplay, NULL, NULL))
+    {
+      CLog::Log(LOGERROR, "failed to initialize egl display\n");
+      return false;
+    }
+  }
+
+  XVisualInfo vMask;
+  XVisualInfo *visuals;
+  XVisualInfo *vInfo      = NULL;
+  int availableVisuals    = 0;
+  vMask.screen = screen;
+  XWindowAttributes winAttr;
+
+  /* Assume a depth of 24 in case the below calls to XGetWindowAttributes()
+     or XGetVisualInfo() fail. That shouldn't happen unless something is
+     fatally wrong, but lets prepare for everything. */
+  vMask.depth = 24;
+
+  if (XGetWindowAttributes(m_dpy, glWindow, &winAttr))
+  {
+    vMask.visualid = XVisualIDFromVisual(winAttr.visual);
+    vInfo = XGetVisualInfo(m_dpy, VisualScreenMask | VisualIDMask, &vMask, &availableVisuals);
+    if (!vInfo)
+      CLog::Log(LOGWARNING, "Failed to get VisualInfo of visual 0x%x", (unsigned) vMask.visualid);
+    else if(!IsSuitableVisual(vInfo))
+    {
+      CLog::Log(LOGWARNING, "Visual 0x%x of the window is not suitable, looking for another one...",
+                (unsigned) vInfo->visualid);
+      vMask.depth = vInfo->depth;
+      XFree(vInfo);
+      vInfo = NULL;
+    }
+  }
+  else
+    CLog::Log(LOGWARNING, "Failed to get window attributes");
+
+  /* As per glXMakeCurrent documentation, we have to use the same visual as
+     m_glWindow. Since that was not suitable for use, we try to use another
+     one with the same depth and hope that the used implementation is less
+     strict than the documentation. */
+  if (!vInfo)
+  {
+    visuals = XGetVisualInfo(m_dpy, VisualScreenMask | VisualDepthMask, &vMask, &availableVisuals);
+    for (int i = 0; i < availableVisuals; i++)
+    {
+      if (IsSuitableVisual(&visuals[i]))
+      {
+        vMask.visualid = visuals[i].visualid;
+        vInfo = XGetVisualInfo(m_dpy, VisualScreenMask | VisualIDMask, &vMask, &availableVisuals);
+        break;
+      }
+    }
+    XFree(visuals);
+  }
+
+  if (vInfo)
+  {
+    CLog::Log(LOGNOTICE, "Using visual 0x%x", (unsigned) vInfo->visualid);
+
+    if (m_eglContext)
+    {
+      eglMakeCurrent(m_eglContext, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+      eglDestroyContext(m_eglDisplay, m_eglContext);
+      m_eglContext = EGL_NO_CONTEXT;
+
+      if (m_eglSurface)
+      {
+        eglDestroySurface(m_eglDisplay, m_eglSurface);
+        m_eglSurface = EGL_NO_SURFACE;
+      }
+      eglTerminate(m_eglDisplay);
+      m_eglDisplay = EGL_NO_DISPLAY;
+      XSync(m_dpy, FALSE);
+      newContext = true;
+    }
+
+    m_eglDisplay = eglGetDisplay((EGLNativeDisplayType)m_dpy);
+    if (m_eglDisplay == EGL_NO_DISPLAY)
+    {
+      CLog::Log(LOGERROR, "failed to get egl display");
+      return false;
+    }
+    if (!eglInitialize(m_eglDisplay, NULL, NULL))
+    {
+      CLog::Log(LOGERROR, "failed to initialize egl\n");
+      return false;
+    }
+
+#if defined (HAS_GL)
+    if (!eglBindAPI(EGL_OPENGL_API))
+    {
+      CLog::Log(LOGERROR, "failed to initialize egl");
+      XFree(vInfo);
+      return false;
+    }
+#endif
+
+    m_eglConfig = getEGLConfig(m_eglDisplay, vInfo);
+
+    if (m_eglConfig == EGL_NO_CONFIG)
+    {
+      CLog::Log(LOGERROR, "failed to get eglconfig for visual id");
+      XFree(vInfo);
+      return false;
+    }
+
+    if (m_eglSurface == EGL_NO_SURFACE)
+    {
+      m_eglSurface = eglCreateWindowSurface(m_eglDisplay, m_eglConfig, glWindow, NULL);
+      if (m_eglSurface == EGL_NO_SURFACE)
+      {
+        CLog::Log(LOGERROR, "failed to create EGL window surface %d", eglGetError());
+        XFree(vInfo);
+        return false;
+      }
+    }
+
+    EGLint contextAttributes[] =
+    {
+      EGL_CONTEXT_CLIENT_VERSION, 2,
+      EGL_NONE
+    };
+    m_eglContext = eglCreateContext(m_eglDisplay, m_eglConfig, EGL_NO_CONTEXT, contextAttributes);
+    if (m_eglContext == EGL_NO_CONTEXT)
+    {
+      CLog::Log(LOGERROR, "failed to create EGL context\n");
+      return false;
+    }
+
+    if (!eglMakeCurrent(m_eglDisplay, m_eglSurface, m_eglSurface, m_eglContext))
+    {
+      CLog::Log(LOGERROR, "Failed to make context current %p %p %p\n", m_eglDisplay, m_eglSurface, m_eglContext);
+      return false;
+    }
+    XFree(vInfo);
+    retVal = true;
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "EGL Error: vInfo is NULL!");
+  }
+
+  return retVal;
+}
+
+void CGLContextEGL::Destroy()
+{
+  if (m_eglContext)
+  {
+    glFinish();
+    eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    eglDestroyContext(m_eglDisplay, m_eglContext);
+    m_eglContext = EGL_NO_CONTEXT;
+  }
+
+  if (m_eglSurface)
+  {
+    eglDestroySurface(m_eglDisplay, m_eglSurface);
+    m_eglSurface = EGL_NO_SURFACE;
+  }
+
+  if (m_eglDisplay)
+  {
+    eglTerminate(m_eglDisplay);
+    m_eglDisplay = EGL_NO_DISPLAY;
+  }
+}
+
+void CGLContextEGL::Detach()
+{
+  if (m_eglContext)
+  {
+    glFinish();
+    eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+  }
+  if (m_eglSurface)
+  {
+    eglDestroySurface(m_eglDisplay, m_eglSurface);
+    m_eglSurface = EGL_NO_SURFACE;
+  }
+}
+
+bool CGLContextEGL::IsSuitableVisual(XVisualInfo *vInfo)
+{
+  EGLConfig config = getEGLConfig(m_eglDisplay, vInfo);
+  if (config == EGL_NO_CONFIG)
+  {
+    CLog::Log(LOGERROR, "Failed to determine egl config for visual info");
+    return false;
+  }
+  EGLint value;
+
+  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_RED_SIZE, &value) || value < 8)
+    return false;
+  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_GREEN_SIZE, &value) || value < 8)
+    return false;
+  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_BLUE_SIZE, &value) || value < 8)
+    return false;
+  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_ALPHA_SIZE, &value) || value < 8)
+    return false;
+  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_DEPTH_SIZE, &value) || value < 24)
+    return false;
+
+  return true;
+}
+
+EGLConfig CGLContextEGL::getEGLConfig(EGLDisplay eglDisplay, XVisualInfo *vInfo)
+{
+  EGLint attributes[] =
+  {
+    EGL_DEPTH_SIZE, 24,
+    EGL_ALPHA_SIZE, 8,
+    EGL_RED_SIZE, 8,
+    EGL_BLUE_SIZE, 8,
+    EGL_GREEN_SIZE, 8,
+    EGL_NONE
+  };
+  EGLint numConfigs;
+
+  if (!eglChooseConfig(eglDisplay, attributes, NULL, 0, &numConfigs))
+  {
+    CLog::Log(LOGERROR, "Failed to query number of egl configs");
+    return EGL_NO_CONFIG;
+  }
+  if (numConfigs == 0)
+  {
+    CLog::Log(LOGERROR, "No suitable egl configs found");
+    return EGL_NO_CONFIG;
+  }
+
+  EGLConfig *eglConfigs;
+  eglConfigs = (EGLConfig*)malloc(numConfigs * sizeof(EGLConfig));
+  if (!eglConfigs)
+  {
+    CLog::Log(LOGERROR, "eglConfigs malloc failed");
+    return EGL_NO_CONFIG;
+  }
+  EGLConfig eglConfig = EGL_NO_CONFIG;
+  if (!eglChooseConfig(eglDisplay, attributes, eglConfigs, numConfigs, &numConfigs))
+  {
+    CLog::Log(LOGERROR, "Failed to query egl configs");
+    goto Exit;
+  }
+  for (EGLint i = 0;i < numConfigs;++i)
+  {
+    EGLint value;
+    if (!eglGetConfigAttrib(eglDisplay, eglConfigs[i], EGL_NATIVE_VISUAL_ID, &value))
+    {
+      CLog::Log(LOGERROR, "Failed to query EGL_NATIVE_VISUAL_ID for egl config.");
+      break;
+    }
+    if (value == (EGLint)vInfo->visualid) {
+      eglConfig = eglConfigs[i];
+      break;
+    }
+  }
+
+Exit:
+  free(eglConfigs);
+  return eglConfig;
+}
+
+void CGLContextEGL::SetVSync(bool enable, int &mode)
+{
+  eglSwapInterval(m_eglDisplay, enable ? 1 : 0);
+}
+
+bool CGLContextEGL::SwapBuffers(const CDirtyRegionList& dirty, int &mode)
+{
+  if ((m_eglDisplay == EGL_NO_DISPLAY) || (m_eglSurface == EGL_NO_SURFACE))
+    return false;
+
+  eglSwapBuffers(m_eglDisplay, m_eglSurface);
+
+  return true;
+}
+
+void CGLContextEGL::QueryExtensions()
+{
+  std::string extensions = eglQueryString(m_eglDisplay, EGL_EXTENSIONS);
+  m_extensions = std::string(" ") + extensions + " ";
+
+  CLog::Log(LOGDEBUG, "EGL_EXTENSIONS:%s", m_extensions.c_str());
+}
+
+bool CGLContextEGL::IsExtSupported(const char* extension)
+{
+  std::string name;
+
+  name  = " ";
+  name += extension;
+  name += " ";
+
+  return m_extensions.find(name) != std::string::npos;
+}
+
+#endif
diff --git a/xbmc/windowing/X11/GLContextEGL.h b/xbmc/windowing/X11/GLContextEGL.h
new file mode 100644
index 0000000000..dac7075745
--- /dev/null
+++ b/xbmc/windowing/X11/GLContextEGL.h
@@ -0,0 +1,44 @@
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#if defined(HAVE_X11)
+#include "GLContext.h"
+#include "EGL/egl.h"
+
+class CGLContextEGL : public CGLContext
+{
+public:
+  CGLContextEGL(Display *dpy);
+  virtual ~CGLContextEGL();
+  virtual bool Refresh(bool force, int screen, Window glWindow, bool &newContext);
+  virtual void Destroy();
+  virtual void Detach();
+  virtual void SetVSync(bool enable, int &mode);
+  virtual bool SwapBuffers(const CDirtyRegionList& dirty, int &mode);
+  virtual void QueryExtensions();
+  virtual bool IsExtSupported(const char* extension);
+protected:
+  bool IsSuitableVisual(XVisualInfo *vInfo);
+  EGLConfig getEGLConfig(EGLDisplay eglDisplay, XVisualInfo *vInfo);
+};
+
+#endif
diff --git a/xbmc/windowing/X11/GLContextGLX.cpp b/xbmc/windowing/X11/GLContextGLX.cpp
new file mode 100644
index 0000000000..6dc3d842bc
--- /dev/null
+++ b/xbmc/windowing/X11/GLContextGLX.cpp
@@ -0,0 +1,309 @@
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system_gl.h"
+
+#if defined(HAVE_X11)
+
+#include <GL/glx.h>
+#include "GLContextGLX.h"
+#include "utils/log.h"
+
+CGLContextGLX::CGLContextGLX(Display *dpy) : CGLContext(dpy)
+{
+  m_extPrefix = "GLX_";
+}
+
+bool CGLContextGLX::Refresh(bool force, int screen, Window glWindow, bool &newContext)
+{
+  bool retVal = false;
+  m_glxWindow = glWindow;
+  m_nScreen = screen;
+
+  // refresh context
+  if (m_glxContext && !force)
+  {
+    CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshGlxContext: refreshing context");
+    glXMakeCurrent(m_dpy, None, NULL);
+    glXMakeCurrent(m_dpy, glWindow, m_glxContext);
+    return true;
+  }
+
+  // create context
+
+  XVisualInfo vMask;
+  XVisualInfo *visuals;
+  XVisualInfo *vInfo = NULL;
+  int availableVisuals = 0;
+  vMask.screen = screen;
+  XWindowAttributes winAttr;
+
+  /* Assume a depth of 24 in case the below calls to XGetWindowAttributes()
+     or XGetVisualInfo() fail. That shouldn't happen unless something is
+     fatally wrong, but lets prepare for everything. */
+  vMask.depth = 24;
+
+  if (XGetWindowAttributes(m_dpy, glWindow, &winAttr))
+  {
+    vMask.visualid = XVisualIDFromVisual(winAttr.visual);
+    vInfo = XGetVisualInfo(m_dpy, VisualScreenMask | VisualIDMask, &vMask, &availableVisuals);
+    if (!vInfo)
+      CLog::Log(LOGWARNING, "Failed to get VisualInfo of visual 0x%x", (unsigned) vMask.visualid);
+    else if(!IsSuitableVisual(vInfo))
+    {
+      CLog::Log(LOGWARNING, "Visual 0x%x of the window is not suitable, looking for another one...",
+                (unsigned) vInfo->visualid);
+      vMask.depth = vInfo->depth;
+      XFree(vInfo);
+      vInfo = NULL;
+    }
+  }
+  else
+    CLog::Log(LOGWARNING, "Failed to get window attributes");
+
+  /* As per glXMakeCurrent documentation, we have to use the same visual as
+     m_glWindow. Since that was not suitable for use, we try to use another
+     one with the same depth and hope that the used implementation is less
+     strict than the documentation. */
+  if (!vInfo)
+  {
+    visuals = XGetVisualInfo(m_dpy, VisualScreenMask | VisualDepthMask, &vMask, &availableVisuals);
+    for (int i = 0; i < availableVisuals; i++)
+    {
+      if (IsSuitableVisual(&visuals[i]))
+      {
+        vMask.visualid = visuals[i].visualid;
+        vInfo = XGetVisualInfo(m_dpy, VisualScreenMask | VisualIDMask, &vMask, &availableVisuals);
+        break;
+      }
+    }
+    XFree(visuals);
+  }
+
+  if (vInfo)
+  {
+    CLog::Log(LOGNOTICE, "Using visual 0x%x", (unsigned) vInfo->visualid);
+    if (m_glxContext)
+    {
+      glXMakeCurrent(m_dpy, None, NULL);
+      glXDestroyContext(m_dpy, m_glxContext);
+      XSync(m_dpy, FALSE);
+    }
+
+    if ((m_glxContext = glXCreateContext(m_dpy, vInfo, NULL, True)))
+    {
+      // make this context current
+      glXMakeCurrent(m_dpy, glWindow, m_glxContext);
+      retVal = true;
+    }
+    else
+      CLog::Log(LOGERROR, "GLX Error: Could not create context");
+
+    XFree(vInfo);
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "GLX Error: vInfo is NULL!");
+  }
+
+  return retVal;
+}
+
+void CGLContextGLX::Destroy()
+{
+  glXMakeCurrent(m_dpy, None, NULL);
+  glXDestroyContext(m_dpy, m_glxContext);
+  m_glxContext = 0;
+}
+
+void CGLContextGLX::Detach()
+{
+  glXMakeCurrent(m_dpy, None, NULL);
+}
+
+bool CGLContextGLX::IsSuitableVisual(XVisualInfo *vInfo)
+{
+  int value;
+
+  if (glXGetConfig(m_dpy, vInfo, GLX_RGBA, &value) || !value)
+    return false;
+  if (glXGetConfig(m_dpy, vInfo, GLX_DOUBLEBUFFER, &value) || !value)
+    return false;
+  if (glXGetConfig(m_dpy, vInfo, GLX_RED_SIZE, &value) || value < 8)
+    return false;
+  if (glXGetConfig(m_dpy, vInfo, GLX_GREEN_SIZE, &value) || value < 8)
+    return false;
+  if (glXGetConfig(m_dpy, vInfo, GLX_BLUE_SIZE, &value) || value < 8)
+    return false;
+  if (glXGetConfig(m_dpy, vInfo, GLX_ALPHA_SIZE, &value) || value < 8)
+    return false;
+  if (glXGetConfig(m_dpy, vInfo, GLX_DEPTH_SIZE, &value) || value < 8)
+    return false;
+
+  return true;
+}
+
+void CGLContextGLX::SetVSync(bool enable, int &mode)
+{
+  // turn of current setting first
+  if(m_glXSwapIntervalEXT)
+    m_glXSwapIntervalEXT(m_dpy, m_glxWindow, 0);
+  else if(m_glXSwapIntervalMESA)
+    m_glXSwapIntervalMESA(0);
+
+  m_iVSyncErrors = 0;
+
+  if(!enable)
+    return;
+
+  if (m_glXSwapIntervalEXT && !mode)
+  {
+    m_glXSwapIntervalEXT(m_dpy, m_glxWindow, 1);
+    mode = 6;
+  }
+  if (m_glXSwapIntervalMESA && !mode)
+  {
+    if(m_glXSwapIntervalMESA(1) == 0)
+      mode = 2;
+    else
+      CLog::Log(LOGWARNING, "%s - glXSwapIntervalMESA failed", __FUNCTION__);
+  }
+  if (m_glXWaitVideoSyncSGI && m_glXGetVideoSyncSGI && !mode)
+  {
+    unsigned int count;
+    if(m_glXGetVideoSyncSGI(&count) == 0)
+      mode = 3;
+    else
+      CLog::Log(LOGWARNING, "%s - glXGetVideoSyncSGI failed, glcontext probably not direct", __FUNCTION__);
+  }
+}
+
+bool CGLContextGLX::SwapBuffers(const CDirtyRegionList& dirty, int &mode)
+{
+  if(mode == 3)
+  {
+    glFinish();
+    unsigned int before = 0, after = 0;
+    if (m_glXGetVideoSyncSGI(&before) != 0)
+      CLog::Log(LOGERROR, "%s - glXGetVideoSyncSGI - Failed to get current retrace count", __FUNCTION__);
+
+    glXSwapBuffers(m_dpy, m_glxWindow);
+    glFinish();
+
+    if(m_glXGetVideoSyncSGI(&after) != 0)
+      CLog::Log(LOGERROR, "%s - glXGetVideoSyncSGI - Failed to get current retrace count", __FUNCTION__);
+
+    if (after == before)
+      m_iVSyncErrors = 1;
+    else
+      m_iVSyncErrors--;
+
+    if (m_iVSyncErrors > 0)
+    {
+      CLog::Log(LOGINFO, "GL: retrace count didn't change after buffer swap, switching to vsync mode 4");
+      m_iVSyncErrors = 0;
+      mode = 4;
+    }
+
+    if (m_iVSyncErrors < -200)
+    {
+      CLog::Log(LOGINFO, "GL: retrace count change for %d consecutive buffer swap, switching to vsync mode 2", -m_iVSyncErrors);
+      m_iVSyncErrors = 0;
+      mode = 2;
+    }
+  }
+  else if (mode == 4)
+  {
+    glFinish();
+    unsigned int before = 0, swap = 0, after = 0;
+    if (m_glXGetVideoSyncSGI(&before) != 0)
+      CLog::Log(LOGERROR, "%s - glXGetVideoSyncSGI - Failed to get current retrace count", __FUNCTION__);
+
+    if(m_glXWaitVideoSyncSGI(2, (before+1)%2, &swap) != 0)
+      CLog::Log(LOGERROR, "%s - glXWaitVideoSyncSGI - Returned error", __FUNCTION__);
+
+    glXSwapBuffers(m_dpy, m_glxWindow);
+    glFinish();
+
+    if (m_glXGetVideoSyncSGI(&after) != 0)
+      CLog::Log(LOGERROR, "%s - glXGetVideoSyncSGI - Failed to get current retrace count", __FUNCTION__);
+
+    if (after == before)
+      CLog::Log(LOGERROR, "%s - glXWaitVideoSyncSGI - Woke up early", __FUNCTION__);
+
+    if (after > before + 1)
+      m_iVSyncErrors++;
+    else
+      m_iVSyncErrors = 0;
+
+    if (m_iVSyncErrors > 30)
+    {
+      CLog::Log(LOGINFO, "GL: retrace count seems to be changing due to the swapbuffers call, switching to vsync mode 3");
+      mode = 3;
+      m_iVSyncErrors = 0;
+    }
+  }
+  else
+    glXSwapBuffers(m_dpy, m_glxWindow);
+
+  return true;
+}
+
+void CGLContextGLX::QueryExtensions()
+{
+  m_extensions  = " ";
+  m_extensions += (const char*)glXQueryExtensionsString(m_dpy, m_nScreen);
+  m_extensions += " ";
+
+  CLog::Log(LOGDEBUG, "GLX_EXTENSIONS:%s", m_extensions.c_str());
+
+  if (IsExtSupported("GLX_SGI_video_sync"))
+    m_glXWaitVideoSyncSGI = (int (*)(int, int, unsigned int*))glXGetProcAddress((const GLubyte*)"glXWaitVideoSyncSGI");
+  else
+    m_glXWaitVideoSyncSGI = NULL;
+
+  if (IsExtSupported("GLX_SGI_video_sync"))
+    m_glXGetVideoSyncSGI = (int (*)(unsigned int*))glXGetProcAddress((const GLubyte*)"glXGetVideoSyncSGI");
+  else
+    m_glXGetVideoSyncSGI = NULL;
+
+  if (IsExtSupported("GLX_MESA_swap_control"))
+    m_glXSwapIntervalMESA = (int (*)(int))glXGetProcAddress((const GLubyte*)"glXSwapIntervalMESA");
+  else
+    m_glXSwapIntervalMESA = NULL;
+
+  if (IsExtSupported("GLX_EXT_swap_control"))
+    m_glXSwapIntervalEXT = (PFNGLXSWAPINTERVALEXTPROC)glXGetProcAddress((const GLubyte*)"glXSwapIntervalEXT");
+  else
+    m_glXSwapIntervalEXT = NULL;
+}
+
+bool CGLContextGLX::IsExtSupported(const char* extension)
+{
+  std::string name;
+
+  name  = " ";
+  name += extension;
+  name += " ";
+
+  return m_extensions.find(name) != std::string::npos;
+}
+
+#endif
diff --git a/xbmc/windowing/X11/WinSystemX11GL.h b/xbmc/windowing/X11/GLContextGLX.h
similarity index 50%
rename from xbmc/windowing/X11/WinSystemX11GL.h
rename to xbmc/windowing/X11/GLContextGLX.h
index 6454131a5f..c19a257503 100644
--- a/xbmc/windowing/X11/WinSystemX11GL.h
+++ b/xbmc/windowing/X11/GLContextGLX.h
@@ -1,12 +1,6 @@
-#ifndef WINDOW_SYSTEM_X11_GL_H
-#define WINDOW_SYSTEM_X11_GL_H
-
-#pragma once
-
-#if defined(HAVE_LIBGL)
 /*
- *      Copyright (C) 2005-2012 Team XBMC
- *      http://www.xbmc.org
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -23,38 +17,33 @@
  *  <http://www.gnu.org/licenses/>.
  *
  */
-#include "WinSystemX11.h"
-#include "rendering/gl/RenderSystemGL.h"
-#include "utils/GlobalsHandling.h"
 
-class CWinSystemX11GL : public CWinSystemX11, public CRenderSystemGL
+#pragma once
+
+#if defined(HAVE_X11)
+#include "GLContext.h"
+#include "GL/glx.h"
+
+class CGLContextGLX : public CGLContext
 {
 public:
-  CWinSystemX11GL();
-  virtual ~CWinSystemX11GL();
-  virtual bool CreateNewWindow(const CStdString& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction);
-  virtual bool ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop);
-  virtual bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays);
-
+  CGLContextGLX(Display *dpy);
+  virtual bool Refresh(bool force, int screen, Window glWindow, bool &newContext);
+  virtual void Destroy();
+  virtual void Detach();
+  virtual void SetVSync(bool enable, int &mode);
+  virtual bool SwapBuffers(const CDirtyRegionList& dirty, int &mode);
+  virtual void QueryExtensions();
   virtual bool IsExtSupported(const char* extension);
-
 protected:
-  virtual bool PresentRenderImpl(const CDirtyRegionList& dirty);
-  virtual void SetVSyncImpl(bool enable);
-
-  CStdString m_glxext;
+  bool IsSuitableVisual(XVisualInfo *vInfo);
 
   int (*m_glXGetVideoSyncSGI)(unsigned int*);
   int (*m_glXWaitVideoSyncSGI)(int, int, unsigned int*);
   int (*m_glXSwapIntervalMESA)(int);
   PFNGLXSWAPINTERVALEXTPROC m_glXSwapIntervalEXT;
-
+  int m_nScreen;
   int m_iVSyncErrors;
 };
 
-XBMC_GLOBAL_REF(CWinSystemX11GL,g_Windowing);
-#define g_Windowing XBMC_GLOBAL_USE(CWinSystemX11GL)
-
-#endif // HAVE_LIBGL
-
-#endif // WINDOW_SYSTEM_H
+#endif
diff --git a/xbmc/windowing/X11/Makefile b/xbmc/windowing/X11/Makefile
index 0dfbd42ad4..3f002765e0 100644
--- a/xbmc/windowing/X11/Makefile
+++ b/xbmc/windowing/X11/Makefile
@@ -1,6 +1,7 @@
 SRCS=WinSystemX11.cpp \
-     WinSystemX11GL.cpp \
-     WinSystemX11GLES.cpp \
+     WinSystemX11GLContext.cpp \
+     GLContextEGL.cpp \
+     GLContextGLX.cpp \
      XRandR.cpp \
      
 LIB=windowing_X11.a
diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 92ac51c1fa..3a908e9e0a 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -20,7 +20,7 @@
 
 #include "system.h"
 
-#if defined(HAS_GLX) || (defined(HAS_EGL) && defined(HAVE_X11))
+#if defined(HAVE_X11)
 
 #include "WinSystemX11.h"
 #include "settings/GUISettings.h"
@@ -49,13 +49,6 @@
 CWinSystemX11::CWinSystemX11() : CWinSystemBase()
 {
   m_eWindowSystem = WINDOW_SYSTEM_X11;
-#if defined(HAS_GLX)
-  m_glContext = NULL;
-#endif
-#if defined(HAS_EGL)
-  m_eglContext = EGL_NO_CONTEXT;
-  m_eglDisplay = EGL_NO_DISPLAY;
-#endif
   m_dpy = NULL;
   m_glWindow = 0;
   m_mainWindow = 0;
@@ -64,6 +57,7 @@ CWinSystemX11::CWinSystemX11() : CWinSystemBase()
   m_bIgnoreNextFocusMessage = false;
   m_invisibleCursor = 0;
   m_bIsInternalXrr = false;
+  m_delayDispReset = false;
 
   XSetErrorHandler(XErrorHandler);
 }
@@ -80,7 +74,7 @@ bool CWinSystemX11::InitWindowSystem()
     return ret;
   }
   else
-    CLog::Log(LOGERROR, "GLX Error: No Display found");
+    CLog::Log(LOGERROR, "X11 Error: No Display found");
 
   return false;
 }
@@ -100,37 +94,6 @@ bool CWinSystemX11::DestroyWindowSystem()
     g_xrandr.SetMode(out, mode);
   }
 
-#if defined(HAS_GLX)
-  if (m_dpy)
-  {
-    if (m_glContext)
-    {
-      glXMakeCurrent(m_dpy, None, NULL);
-      glXDestroyContext(m_dpy, m_glContext);
-    }
-
-    m_glContext = 0;
-
-    //we don't call XCloseDisplay() here, since ati keeps a pointer to our m_dpy
-    //so instead we just let m_dpy die on exit
-    // i have seen core dumps on ATI if the display is not closed here
-    // crashes when shutting down via cec
-//    XCloseDisplay(m_dpy);
-  }
-#endif
-
-#if defined(HAS_EGL)
-  if (m_eglDisplay)
-  {
-    if (m_eglContext != EGL_NO_CONTEXT)
-    {
-      eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
-      m_eglContext = EGL_NO_CONTEXT;
-    }
-  }
-#endif
-  // m_SDLSurface is free()'d by SDL_Quit().
-
   return true;
 }
 
@@ -148,21 +111,6 @@ bool CWinSystemX11::DestroyWindow()
   if (!m_mainWindow)
     return true;
 
-#if defined(HAS_GLX)
-  if (m_glContext)
-  {
-    glFinish();
-    glXMakeCurrent(m_dpy, None, NULL);
-  }
-#endif
-#if defined(HAS_EGL)
-  if (m_eglContext)
-  {
-    glFinish();
-    eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
-  }
-#endif
-
   if (m_invisibleCursor)
   {
     XUndefineCursor(m_dpy, m_mainWindow);
@@ -203,7 +151,7 @@ bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int n
   if (!out)
   {
     std::vector<XOutput> outputs = g_xrandr.GetModes();
-    if (outputs.size() > 0)
+    if (!outputs.empty())
     {
       m_userOutput = outputs[0].name;
     }
@@ -295,6 +243,12 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
         OnLostDevice();
         m_bIsInternalXrr = true;
         g_xrandr.SetMode(out, mode);
+        int delay = g_guiSettings.GetInt("videoscreen.delayrefreshchange");
+        if (delay > 0)
+        {
+          m_delayDispReset = true;
+          m_dispResetTimer.Set(delay * 100);
+        }
         return true;
       }
     }
@@ -487,275 +441,6 @@ bool CWinSystemX11::IsCurrentOutput(CStdString output)
   return (output.Equals("Default")) || (m_currentOutput.compare(output.c_str()) == 0);
 }
 
-#if defined(HAS_EGL)
-EGLConfig getEGLConfig(EGLDisplay eglDisplay, XVisualInfo *vInfo)
-{
-  EGLint attributes[] =
-  {
-    EGL_DEPTH_SIZE, 24,
-    EGL_NONE
-  };
-  EGLint numConfigs;
-
-  if (!eglChooseConfig(eglDisplay, attributes, NULL, 0, &numConfigs))
-  {
-    CLog::Log(LOGERROR, "Failed to query number of egl configs");
-    return EGL_NO_CONFIG;
-  }
-  if (numConfigs == 0)
-  {
-    CLog::Log(LOGERROR, "No suitable egl configs found");
-    return EGL_NO_CONFIG;
-  }
-
-  EGLConfig *eglConfigs;
-  eglConfigs = (EGLConfig*)malloc(numConfigs * sizeof(EGLConfig));
-  if (!eglConfigs)
-  {
-    CLog::Log(LOGERROR, "eglConfigs malloc failed");
-    return EGL_NO_CONFIG;
-  }
-  EGLConfig eglConfig = EGL_NO_CONFIG;
-  if (!eglChooseConfig(eglDisplay, attributes, eglConfigs, numConfigs, &numConfigs))
-  {
-    CLog::Log(LOGERROR, "Failed to query egl configs");
-    goto Exit;
-  }
-  for (EGLint i = 0;i < numConfigs;++i)
-  {
-    EGLint value;
-    if (!eglGetConfigAttrib(eglDisplay, eglConfigs[i], EGL_NATIVE_VISUAL_ID, &value))
-    {
-      CLog::Log(LOGERROR, "Failed to query EGL_NATIVE_VISUAL_ID for egl config.");
-      break;
-    }
-    if (value == (EGLint)vInfo->visualid) {
-      eglConfig = eglConfigs[i];
-      break;
-    }
-  }
-
-Exit:
-  free(eglConfigs);
-  return eglConfig;
-}
-
-#endif
-
-bool CWinSystemX11::IsSuitableVisual(XVisualInfo *vInfo)
-{
-#if defined(HAS_GLX)
-  int value;
-  if (glXGetConfig(m_dpy, vInfo, GLX_RGBA, &value) || !value)
-    return false;
-  if (glXGetConfig(m_dpy, vInfo, GLX_DOUBLEBUFFER, &value) || !value)
-    return false;
-  if (glXGetConfig(m_dpy, vInfo, GLX_RED_SIZE, &value) || value < 8)
-    return false;
-  if (glXGetConfig(m_dpy, vInfo, GLX_GREEN_SIZE, &value) || value < 8)
-    return false;
-  if (glXGetConfig(m_dpy, vInfo, GLX_BLUE_SIZE, &value) || value < 8)
-    return false;
-  if (glXGetConfig(m_dpy, vInfo, GLX_ALPHA_SIZE, &value) || value < 8)
-    return false;
-  if (glXGetConfig(m_dpy, vInfo, GLX_DEPTH_SIZE, &value) || value < 8)
-    return false;
-#endif
-
-#if defined(HAS_EGL)
-  EGLConfig config = getEGLConfig(m_eglDisplay, vInfo);
-  if (config == EGL_NO_CONFIG)
-  {
-    CLog::Log(LOGERROR, "Failed to determine egl config for visual info");
-    return false;
-  }
-  EGLint value;
-
-  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_RED_SIZE, &value) || value < 8)
-    return false;
-  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_GREEN_SIZE, &value) || value < 8)
-    return false;
-  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_BLUE_SIZE, &value) || value < 8)
-    return false;
-  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_ALPHA_SIZE, &value) || value < 8)
-    return false;
-  if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_DEPTH_SIZE, &value) || value < 24)
-    return false;
- 
-#endif
-  return true;
-}
-
-bool CWinSystemX11::RefreshGlxContext(bool force)
-{
-  bool retVal = false;
-
-#if defined(HAS_GLX)
-  if (m_glContext && !force)
-  {
-    CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshGlxContext: refreshing context");
-    glXMakeCurrent(m_dpy, None, NULL);
-    glXMakeCurrent(m_dpy, m_glWindow, m_glContext);
-    return true;
-  }
-#endif
-
-#if defined(HAS_EGL)
-  if (m_eglContext && !force)
-  {
-    CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshGlxContext: refreshing context");
-    eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
-    eglMakeCurrent(m_eglDisplay, m_eglSurface, m_eglSurface, m_eglContext);
-    return true;
-  }
-#endif
-
-
-  XVisualInfo vMask;
-  XVisualInfo *visuals;
-  XVisualInfo *vInfo      = NULL;
-  int availableVisuals    = 0;
-  vMask.screen = m_nScreen;
-  XWindowAttributes winAttr;
-
-  /* Assume a depth of 24 in case the below calls to XGetWindowAttributes()
-     or XGetVisualInfo() fail. That shouldn't happen unless something is
-     fatally wrong, but lets prepare for everything. */
-  vMask.depth = 24;
-
-  if (XGetWindowAttributes(m_dpy, m_glWindow, &winAttr))
-  {
-    vMask.visualid = XVisualIDFromVisual(winAttr.visual);
-    vInfo = XGetVisualInfo(m_dpy, VisualScreenMask | VisualIDMask, &vMask, &availableVisuals);
-    if (!vInfo)
-      CLog::Log(LOGWARNING, "Failed to get VisualInfo of SDL visual 0x%x", (unsigned) vMask.visualid);
-    else if(!IsSuitableVisual(vInfo))
-    {
-      CLog::Log(LOGWARNING, "Visual 0x%x of the SDL window is not suitable, looking for another one...",
-                (unsigned) vInfo->visualid);
-      vMask.depth = vInfo->depth;
-      XFree(vInfo);
-      vInfo = NULL;
-    }
-  }
-  else
-    CLog::Log(LOGWARNING, "Failed to get SDL window attributes");
-
-  /* As per glXMakeCurrent documentation, we have to use the same visual as
-     m_glWindow. Since that was not suitable for use, we try to use another
-     one with the same depth and hope that the used implementation is less
-     strict than the documentation. */
-  if (!vInfo)
-  {
-    visuals = XGetVisualInfo(m_dpy, VisualScreenMask | VisualDepthMask, &vMask, &availableVisuals);
-    for (int i = 0; i < availableVisuals; i++)
-    {
-      if (IsSuitableVisual(&visuals[i]))
-      {
-        vMask.visualid = visuals[i].visualid;
-        vInfo = XGetVisualInfo(m_dpy, VisualScreenMask | VisualIDMask, &vMask, &availableVisuals);
-        break;
-      }
-    }
-    XFree(visuals);
-  }
-
-  if (vInfo)
-  {
-    CLog::Log(LOGNOTICE, "Using visual 0x%x", (unsigned) vInfo->visualid);
-#if defined(HAS_GLX)
-    if (m_glContext)
-    {
-      glXMakeCurrent(m_dpy, None, NULL);
-      glXDestroyContext(m_dpy, m_glContext);
-      XSync(m_dpy, FALSE);
-      m_newGlContext = true;
-    }
-
-    if ((m_glContext = glXCreateContext(m_dpy, vInfo, NULL, True)))
-    {
-      // make this context current
-      glXMakeCurrent(m_dpy, m_glWindow, m_glContext);
-      retVal = true;
-    }
-    else
-      CLog::Log(LOGERROR, "GLX Error: Could not create context");
-#endif
-#if defined(HAS_EGL)
-    if (m_eglContext)
-    {
-      eglMakeCurrent(m_eglContext, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
-      eglDestroyContext(m_eglDisplay, m_eglContext);
-      m_eglContext = EGL_NO_CONTEXT;
-      eglDestroySurface(m_eglDisplay, m_eglSurface);
-      m_eglSurface = EGL_NO_SURFACE;
-      eglTerminate(m_eglDisplay);
-      m_eglDisplay = EGL_NO_DISPLAY;
-      XSync(m_dpy, FALSE);
-      m_newGlContext = true;
-    }
-
-    m_eglDisplay = eglGetDisplay((EGLNativeDisplayType)m_dpy);
-    if (m_eglDisplay == EGL_NO_DISPLAY)
-    {
-      CLog::Log(LOGERROR, "failed to get egl display\n");
-      return false;
-    }
-    if (!eglInitialize(m_eglDisplay, NULL, NULL))
-    {
-      CLog::Log(LOGERROR, "failed to initialize egl\n");
-      return false;
-    }
-
-    if(m_eglConfig == EGL_NO_CONFIG)
-    {
-      m_eglConfig = getEGLConfig(m_eglDisplay, vInfo);
-    }
-
-    if (m_eglConfig == EGL_NO_CONFIG)
-    {
-      CLog::Log(LOGERROR, "failed to get eglconfig for visual id\n");
-      return false;
-    }
-
-    if (m_eglSurface == EGL_NO_SURFACE)
-    {
-      m_eglSurface = eglCreateWindowSurface(m_eglDisplay, m_eglConfig, m_glWindow, NULL);
-      if (m_eglSurface == EGL_NO_SURFACE)
-      {
-        CLog::Log(LOGERROR, "failed to create EGL window surface %d\n", eglGetError());
-        return false;
-      }
-    }
-
-    EGLint contextAttributes[] =
-    {
-      EGL_CONTEXT_CLIENT_VERSION, 2,
-      EGL_NONE
-    };
-    m_eglContext = eglCreateContext(m_eglDisplay, m_eglConfig, EGL_NO_CONTEXT, contextAttributes);
-    if (m_eglContext == EGL_NO_CONTEXT)
-    {
-      CLog::Log(LOGERROR, "failed to create EGL context\n");
-      return false;
-    }
-
-    if (!eglMakeCurrent(m_eglDisplay, m_eglSurface, m_eglSurface, m_eglContext))
-    {
-      CLog::Log(LOGERROR, "Failed to make context current %p %p %p\n", m_eglDisplay, m_eglSurface, m_eglContext);
-      return false;
-    }
-#endif
-    XFree(vInfo);
-  }
-  else
-  {
-    CLog::Log(LOGERROR, "EGL/GLX Error: vInfo is NULL!");
-  }
-
-  return retVal;
-}
-
 void CWinSystemX11::ShowOSMouse(bool show)
 {
   if (show)
@@ -971,7 +656,7 @@ bool CWinSystemX11::EnableFrameLimiter()
   return m_minimized;
 }
 
-bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const std::string &output)
+bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const std::string &output, int *winstate)
 {
   bool changeWindow = false;
   bool changeSize = false;
@@ -1021,33 +706,6 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const std:
   {
     EnableSystemScreenSaver(false);
 
-#if defined(HAS_GLX)
-    GLint att[] =
-    {
-      GLX_RGBA,
-      GLX_RED_SIZE, 8,
-      GLX_GREEN_SIZE, 8,
-      GLX_BLUE_SIZE, 8,
-      GLX_ALPHA_SIZE, 8,
-      GLX_DEPTH_SIZE, 24,
-      GLX_DOUBLEBUFFER,
-      None
-    };
-#endif
-#if defined(HAS_EGL)
-    EGLint att[] =
-    {
-      EGL_RED_SIZE, 8,
-      EGL_GREEN_SIZE, 8,
-      EGL_BLUE_SIZE, 8,
-      EGL_ALPHA_SIZE, 8,
-      EGL_BUFFER_SIZE, 32,
-      EGL_DEPTH_SIZE, 24,
-      EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-      EGL_NONE
-    };
-#endif
-
     Colormap cmap;
     XSetWindowAttributes swa;
     XVisualInfo *vi;
@@ -1064,48 +722,8 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const std:
       y0 = out->y;
     }
 
-#if defined(HAS_GLX)
-    vi = glXChooseVisual(m_dpy, m_nScreen, att);
-#endif
-#if defined(HAS_EGL)
-    if (m_eglDisplay == EGL_NO_DISPLAY)
-    {
-      m_eglDisplay = eglGetDisplay((EGLNativeDisplayType)m_dpy);
-      if (m_eglDisplay == EGL_NO_DISPLAY)
-      {
-        CLog::Log(LOGERROR, "failed to get egl display\n");
-	return false;
-      }
-      if (!eglInitialize(m_eglDisplay, NULL, NULL))
-      {
-	CLog::Log(LOGERROR, "failed to initialize egl display\n");
-	return false;
-      }
-    }
-
-    EGLint numConfigs;
-    EGLConfig eglConfig = 0;
-    if (!eglChooseConfig(m_eglDisplay, att, &eglConfig, 1, &numConfigs) || numConfigs == 0) {
-      CLog::Log(LOGERROR, "Failed to choose a config %d\n", eglGetError());
-    }
-    m_eglConfig=eglConfig;
-
-    EGLint eglVisualid;
-    if (!eglGetConfigAttrib(m_eglDisplay, m_eglConfig, EGL_NATIVE_VISUAL_ID, &eglVisualid))
-    {
-      CLog::Log(LOGERROR, "Failed to query native visual id\n");
-    }
-    XVisualInfo x11_visual_info_template;
-    x11_visual_info_template.visualid = eglVisualid;
-    int num_visuals;
-    vi = XGetVisualInfo(m_dpy,
-                        VisualIDMask,
-                        &x11_visual_info_template,
-                        &num_visuals);
-
-#endif
-
-    if(!vi)
+    vi = GetVisual();
+    if (!vi)
     {
       CLog::Log(LOGERROR, "Failed to find matching visual");
       return false;
@@ -1173,21 +791,13 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const std:
                                             &black, &black, 0, 0);
     XFreePixmap(m_dpy, bitmapNoData);
     XDefineCursor(m_dpy,m_mainWindow, m_invisibleCursor);
+    XFree(vi);
 
     //init X11 events
     CWinEventsX11Imp::Init(m_dpy, m_mainWindow);
 
     changeWindow = true;
     changeSize = true;
-
-#if defined(HAS_EGL)
-    m_eglSurface = eglCreateWindowSurface(m_eglDisplay, m_eglConfig, m_glWindow, NULL);
-    if (m_eglSurface == EGL_NO_SURFACE)
-    {
-      CLog::Log(LOGERROR, "failed to create egl window surface\n");
-      return false;
-    }
-#endif
   }
 
   if (!CWinEventsX11Imp::HasStructureChanged() && ((width != m_nWidth) || (height != m_nHeight)))
@@ -1250,24 +860,8 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const std:
     // discard events generated by creating the window, i.e. xrr events
     XSync(m_dpy, TRUE);
 
-    CDirtyRegionList dr;
-    RefreshGlxContext(m_currentOutput.compare(output) != 0);
-    XSync(m_dpy, FALSE);
-    g_graphicsContext.Clear(0);
-    g_graphicsContext.Flip(dr);
-#if defined(HAS_GLX)
-    g_Windowing.ResetVSync();
-#endif
-    m_windowDirty = false;
-    m_bIsInternalXrr = false;
-
-// what's this???
-#if defined(HAS_GLX)
-    CSingleLock lock(m_resourceSection);
-    // tell any shared resources
-    for (std::vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
-      (*i)->OnResetDevice();
-#endif
+    if (winstate)
+      *winstate = 1;
   }
 
   UpdateCrtc();
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index cb1c82b61f..f40eedc5bf 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -1,8 +1,3 @@
-#ifndef WINDOW_SYSTEM_X11_H
-#define WINDOW_SYSTEM_X11_H
-
-#pragma once
-
 /*
  *      Copyright (C) 2005-2012 Team XBMC
  *      http://www.xbmc.org
@@ -23,19 +18,14 @@
  *
  */
 
-#include "system_gl.h"
-
-#if defined(HAS_GLX)
-#include <GL/glx.h>
-#endif
-
-#if defined(HAS_EGL)
-#include <EGL/egl.h>
-#endif
+#pragma once
 
 #include "windowing/WinSystem.h"
 #include "utils/Stopwatch.h"
 #include "threads/CriticalSection.h"
+#include "threads/SystemClock.h"
+#include "X11/Xlib.h"
+#include "X11/Xutil.h"
 
 class IDispResource;
 
@@ -76,15 +66,6 @@ public:
 
   // Local to WinSystemX11 only
   Display*  GetDisplay() { return m_dpy; }
-#if defined(HAS_GLX)
-  GLXWindow GetWindow() { return m_glWindow; }
-  GLXContext GetGlxContext() { return m_glContext; }
-#endif
-#if defined(HAS_EGL)
-  EGLDisplay GetEGLDisplay() const { return m_eglDisplay;}
-  EGLSurface GetEGLSurface() const { return m_eglSurface;}
-  EGLContext GetEGLContext() const { return m_eglContext;}
-#endif
   void NotifyXRREvent();
   void GetConnectedOutputs(std::vector<CStdString> *outputs);
   bool IsCurrentOutput(CStdString output);
@@ -92,34 +73,27 @@ public:
   int GetCrtc() { return m_crtc; }
 
 protected:
-  bool RefreshGlxContext(bool force);
+  virtual bool SetWindow(int width, int height, bool fullscreen, const std::string &output, int *winstate = NULL) = 0;
+  virtual XVisualInfo* GetVisual() = 0;
+
   void OnLostDevice();
-  bool SetWindow(int width, int height, bool fullscreen, const std::string &output);
 
-  Window       m_glWindow, m_mainWindow;
-#if defined(HAS_GLX)
-  GLXContext   m_glContext;
-#endif
-#if defined(HAS_EGL)
-  EGLDisplay            m_eglDisplay;
-  EGLSurface            m_eglSurface;
-  EGLContext            m_eglContext;
-  EGLConfig             m_eglConfig;
-#endif
-  Display*     m_dpy;
-  Cursor       m_invisibleCursor;
-  Pixmap       m_icon;
-  bool         m_bIsRotated;
-  bool         m_bWasFullScreenBeforeMinimize;
-  bool         m_minimized;
-  bool         m_bIgnoreNextFocusMessage;
-  CCriticalSection             m_resourceSection;
+  Window m_glWindow, m_mainWindow;
+  Display *m_dpy;
+  Cursor m_invisibleCursor;
+  Pixmap m_icon;
+  bool m_bIsRotated;
+  bool m_bWasFullScreenBeforeMinimize;
+  bool m_minimized;
+  bool m_bIgnoreNextFocusMessage;
+  CCriticalSection m_resourceSection;
   std::vector<IDispResource*>  m_resources;
-  std::string                  m_currentOutput;
-  std::string                  m_userOutput;
-  bool                         m_windowDirty;
-  bool                         m_bIsInternalXrr;
-  bool                         m_newGlContext;
+  bool m_delayDispReset;
+  XbmcThreads::EndTime m_dispResetTimer;
+  std::string m_currentOutput;
+  std::string m_userOutput;
+  bool m_windowDirty;
+  bool m_bIsInternalXrr;
   int m_MouseX, m_MouseY;
   int m_crtc;
 
@@ -132,6 +106,3 @@ private:
 
   CStopWatch m_screensaverReset;
 };
-
-#endif // WINDOW_SYSTEM_H
-
diff --git a/xbmc/windowing/X11/WinSystemX11GL.cpp b/xbmc/windowing/X11/WinSystemX11GL.cpp
deleted file mode 100644
index ddfa09fd88..0000000000
--- a/xbmc/windowing/X11/WinSystemX11GL.cpp
+++ /dev/null
@@ -1,221 +0,0 @@
-/*
- *      Copyright (C) 2005-2012 Team XBMC
- *      http://www.xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include "system.h"
-
-#if defined(HAS_GLX) && !defined(HAS_EGL)
-
-#include "WinSystemX11GL.h"
-#include "utils/log.h"
-#include "utils/StringUtils.h"
-#include "Application.h"
-
-CWinSystemX11GL::CWinSystemX11GL()
-{
-  m_glXGetVideoSyncSGI   = NULL;
-  m_glXWaitVideoSyncSGI  = NULL;
-  m_glXSwapIntervalMESA  = NULL;
-  m_glXSwapIntervalEXT   = NULL;
-
-  m_iVSyncErrors = 0;
-}
-
-CWinSystemX11GL::~CWinSystemX11GL()
-{
-}
-
-bool CWinSystemX11GL::PresentRenderImpl(const CDirtyRegionList& dirty)
-{
-  if(m_iVSyncMode == 3)
-  {
-    glFinish();
-    unsigned int before = 0, after = 0;
-    if(m_glXGetVideoSyncSGI(&before) != 0)
-      CLog::Log(LOGERROR, "%s - glXGetVideoSyncSGI - Failed to get current retrace count", __FUNCTION__);
-
-    glXSwapBuffers(m_dpy, m_glWindow);
-    glFinish();
-
-    if(m_glXGetVideoSyncSGI(&after) != 0)
-      CLog::Log(LOGERROR, "%s - glXGetVideoSyncSGI - Failed to get current retrace count", __FUNCTION__);
-
-    if(after == before)
-      m_iVSyncErrors = 1;
-    else
-      m_iVSyncErrors--;
-
-    if(m_iVSyncErrors > 0)
-    {
-      CLog::Log(LOGINFO, "GL: retrace count didn't change after buffer swap, switching to vsync mode 4");
-      m_iVSyncErrors = 0;
-      m_iVSyncMode   = 4;
-    }
-
-    if(m_iVSyncErrors < -200)
-    {
-      CLog::Log(LOGINFO, "GL: retrace count change for %d consecutive buffer swap, switching to vsync mode 2", -m_iVSyncErrors);
-      m_iVSyncErrors = 0;
-      m_iVSyncMode   = 2;
-    }
-  }
-  else if (m_iVSyncMode == 4)
-  {
-    glFinish();
-    unsigned int before = 0, swap = 0, after = 0;
-    if(m_glXGetVideoSyncSGI(&before) != 0)
-      CLog::Log(LOGERROR, "%s - glXGetVideoSyncSGI - Failed to get current retrace count", __FUNCTION__);
-
-    if(m_glXWaitVideoSyncSGI(2, (before+1)%2, &swap) != 0)
-      CLog::Log(LOGERROR, "%s - glXWaitVideoSyncSGI - Returned error", __FUNCTION__);
-
-    glXSwapBuffers(m_dpy, m_glWindow);
-    glFinish();
-
-    if(m_glXGetVideoSyncSGI(&after) != 0)
-      CLog::Log(LOGERROR, "%s - glXGetVideoSyncSGI - Failed to get current retrace count", __FUNCTION__);
-
-    if(after == before)
-      CLog::Log(LOGERROR, "%s - glXWaitVideoSyncSGI - Woke up early", __FUNCTION__);
-
-    if(after > before + 1)
-      m_iVSyncErrors++;
-    else
-      m_iVSyncErrors = 0;
-
-    if(m_iVSyncErrors > 30)
-    {
-      CLog::Log(LOGINFO, "GL: retrace count seems to be changing due to the swapbuffers call, switching to vsync mode 3");
-      m_iVSyncMode   = 3;
-      m_iVSyncErrors = 0;
-    }
-  }
-  else
-    glXSwapBuffers(m_dpy, m_glWindow);
-
-  return true;
-}
-
-void CWinSystemX11GL::SetVSyncImpl(bool enable)
-{
-  /* turn of current setting first */
-  if(m_glXSwapIntervalEXT)
-    m_glXSwapIntervalEXT(m_dpy, m_glWindow, 0);
-  else if(m_glXSwapIntervalMESA)
-    m_glXSwapIntervalMESA(0);
-
-  m_iVSyncErrors = 0;
-
-  if(!enable)
-    return;
-
-  if (m_glXSwapIntervalEXT && !m_iVSyncMode)
-  {
-    m_glXSwapIntervalEXT(m_dpy, m_glWindow, 1);
-    m_iVSyncMode = 6;
-  }
-  if (m_glXSwapIntervalMESA && !m_iVSyncMode)
-  {
-    if(m_glXSwapIntervalMESA(1) == 0)
-      m_iVSyncMode = 2;
-    else
-      CLog::Log(LOGWARNING, "%s - glXSwapIntervalMESA failed", __FUNCTION__);
-  }
-  if (m_glXWaitVideoSyncSGI && m_glXGetVideoSyncSGI && !m_iVSyncMode)
-  {
-    unsigned int count;
-    if(m_glXGetVideoSyncSGI(&count) == 0)
-        m_iVSyncMode = 3;
-    else
-      CLog::Log(LOGWARNING, "%s - glXGetVideoSyncSGI failed, glcontext probably not direct", __FUNCTION__);
-  }
-}
-
-bool CWinSystemX11GL::IsExtSupported(const char* extension)
-{
-  if(strncmp(extension, "GLX_", 4) != 0)
-    return CRenderSystemGL::IsExtSupported(extension);
-
-  CStdString name;
-
-  name  = " ";
-  name += extension;
-  name += " ";
-
-  return m_glxext.find(name) != std::string::npos;
-}
-
-bool CWinSystemX11GL::CreateNewWindow(const CStdString& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction)
-{
-  if(!CWinSystemX11::CreateNewWindow(name, fullScreen, res, userFunction))
-    return false;
-
-  m_glxext  = " ";
-  m_glxext += (const char*)glXQueryExtensionsString(m_dpy, m_nScreen);
-  m_glxext += " ";
-
-  CLog::Log(LOGDEBUG, "GLX_EXTENSIONS:%s", m_glxext.c_str());
-
-  if (IsExtSupported("GLX_SGI_video_sync"))
-    m_glXWaitVideoSyncSGI = (int (*)(int, int, unsigned int*))glXGetProcAddress((const GLubyte*)"glXWaitVideoSyncSGI");
-  else
-    m_glXWaitVideoSyncSGI = NULL;
-
-  if (IsExtSupported("GLX_SGI_video_sync"))
-    m_glXGetVideoSyncSGI = (int (*)(unsigned int*))glXGetProcAddress((const GLubyte*)"glXGetVideoSyncSGI");
-  else
-    m_glXGetVideoSyncSGI = NULL;
-
-  if (IsExtSupported("GLX_MESA_swap_control"))
-    m_glXSwapIntervalMESA = (int (*)(int))glXGetProcAddress((const GLubyte*)"glXSwapIntervalMESA");
-  else
-    m_glXSwapIntervalMESA = NULL;
-
-  if (IsExtSupported("GLX_EXT_swap_control"))
-    m_glXSwapIntervalEXT = (PFNGLXSWAPINTERVALEXTPROC)glXGetProcAddress((const GLubyte*)"glXSwapIntervalEXT");
-  else
-    m_glXSwapIntervalEXT = NULL;
-
-  return true;
-}
-
-bool CWinSystemX11GL::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
-{
-  m_newGlContext = false;
-  CWinSystemX11::ResizeWindow(newWidth, newHeight, newLeft, newTop);
-  CRenderSystemGL::ResetRenderSystem(newWidth, newHeight, false, 0);
-
-  if (m_newGlContext)
-    g_application.ReloadSkin();
-
-  return true;
-}
-
-bool CWinSystemX11GL::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
-{
-  m_newGlContext = false;
-  CWinSystemX11::SetFullScreen(fullScreen, res, blankOtherDisplays);
-  CRenderSystemGL::ResetRenderSystem(res.iWidth, res.iHeight, fullScreen, res.fRefreshRate);
-
-  if (m_newGlContext)
-    g_application.ReloadSkin();
-
-  return true;
-}
-
-#endif
diff --git a/xbmc/windowing/X11/WinSystemX11GLContext.cpp b/xbmc/windowing/X11/WinSystemX11GLContext.cpp
new file mode 100644
index 0000000000..ac071ca8a2
--- /dev/null
+++ b/xbmc/windowing/X11/WinSystemX11GLContext.cpp
@@ -0,0 +1,196 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+
+#if defined(HAVE_X11)
+
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+
+#include "WinSystemX11GLContext.h"
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+#include "guilib/GraphicContext.h"
+#include "guilib/DispResource.h"
+#include "threads/SingleLock.h"
+#include <vector>
+#include "Application.h"
+#include "GLContextEGL.h"
+#include "GLContextGLX.h"
+
+CWinSystemX11GLContext::CWinSystemX11GLContext()
+{
+  m_pGLContext = NULL;
+}
+
+CWinSystemX11GLContext::~CWinSystemX11GLContext()
+{
+  delete m_pGLContext;
+}
+
+bool CWinSystemX11GLContext::PresentRenderImpl(const CDirtyRegionList& dirty)
+{
+  m_pGLContext->SwapBuffers(dirty, m_iVSyncMode);
+  
+  if (m_delayDispReset && m_dispResetTimer.IsTimePast())
+  {
+    m_delayDispReset = false;
+    CSingleLock lock(m_resourceSection);
+    // tell any shared resources
+    for (std::vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
+      (*i)->OnResetDevice();
+  }
+  return true;
+}
+
+void CWinSystemX11GLContext::SetVSyncImpl(bool enable)
+{
+  m_pGLContext->SetVSync(enable, m_iVSyncMode);
+}
+
+bool CWinSystemX11GLContext::IsExtSupported(const char* extension)
+{
+  if(strncmp(extension, m_pGLContext->ExtPrefix().c_str(), 4) != 0)
+    return CRenderSystemGL::IsExtSupported(extension);
+
+  return m_pGLContext->IsExtSupported(extension);
+}
+
+bool CWinSystemX11GLContext::SetWindow(int width, int height, bool fullscreen, const std::string &output, int *winstate)
+{
+  int newwin = 0;
+  CWinSystemX11::SetWindow(width, height, fullscreen, output, &newwin);
+  if (newwin)
+  {
+    CDirtyRegionList dr;
+    RefreshGLContext(m_currentOutput.compare(output) != 0);
+    XSync(m_dpy, FALSE);
+    g_graphicsContext.Clear(0);
+    g_graphicsContext.Flip(dr);
+    ResetVSync();
+
+    m_windowDirty = false;
+    m_bIsInternalXrr = false;
+
+    if (!m_delayDispReset)
+    {
+      CSingleLock lock(m_resourceSection);
+      // tell any shared resources
+      for (std::vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
+        (*i)->OnResetDevice();
+    }
+  }
+  return true;
+}
+
+bool CWinSystemX11GLContext::CreateNewWindow(const std::string& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction)
+{
+  if(!CWinSystemX11::CreateNewWindow(name, fullScreen, res, userFunction))
+    return false;
+
+  m_pGLContext->QueryExtensions();
+  return true;
+}
+
+bool CWinSystemX11GLContext::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
+{
+  m_newGlContext = false;
+  CWinSystemX11::ResizeWindow(newWidth, newHeight, newLeft, newTop);
+  CRenderSystemGL::ResetRenderSystem(newWidth, newHeight, false, 0);
+
+  if (m_newGlContext)
+    g_application.ReloadSkin();
+
+  return true;
+}
+
+bool CWinSystemX11GLContext::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
+{
+  m_newGlContext = false;
+  CWinSystemX11::SetFullScreen(fullScreen, res, blankOtherDisplays);
+  CRenderSystemGL::ResetRenderSystem(res.iWidth, res.iHeight, fullScreen, res.fRefreshRate);
+
+  if (m_newGlContext)
+    g_application.ReloadSkin();
+
+  return true;
+}
+
+bool CWinSystemX11GLContext::DestroyWindowSystem()
+{
+  bool ret;
+  m_pGLContext->Destroy();
+  ret = CWinSystemX11::DestroyWindowSystem();
+  return ret;
+}
+
+bool CWinSystemX11GLContext::DestroyWindow()
+{
+  bool ret;
+  m_pGLContext->Detach();
+  ret = CWinSystemX11::DestroyWindow();
+  return ret;
+}
+
+XVisualInfo* CWinSystemX11GLContext::GetVisual()
+{
+  GLint att[] =
+  {
+    GLX_RGBA,
+    GLX_RED_SIZE, 8,
+    GLX_GREEN_SIZE, 8,
+    GLX_BLUE_SIZE, 8,
+    GLX_ALPHA_SIZE, 8,
+    GLX_DEPTH_SIZE, 24,
+    GLX_DOUBLEBUFFER,
+    None
+  };
+  return glXChooseVisual(m_dpy, m_nScreen, att);
+}
+
+bool CWinSystemX11GLContext::RefreshGLContext(bool force)
+{
+  bool firstrun = false;
+  if (!m_pGLContext)
+  {
+    m_pGLContext = new CGLContextEGL(m_dpy);
+    firstrun = true;
+  }
+  bool ret = m_pGLContext->Refresh(force, m_nScreen, m_glWindow, m_newGlContext);
+
+  if (ret && !firstrun)
+    return ret;
+
+  std::string gpuvendor = "";
+  if (ret)
+  {
+    gpuvendor = (const char*) glGetString(GL_VENDOR);
+  }
+  std::transform(gpuvendor.begin(), gpuvendor.end(), gpuvendor.begin(), ::tolower);
+  if (firstrun && (!ret || gpuvendor.compare(0, 5, "intel") != 0))
+  {
+    delete m_pGLContext;
+    m_pGLContext = new CGLContextGLX(m_dpy);
+    ret = m_pGLContext->Refresh(force, m_nScreen, m_glWindow, m_newGlContext);
+  }
+  return ret;
+}
+
+#endif
diff --git a/xbmc/windowing/X11/WinSystemX11GLContext.h b/xbmc/windowing/X11/WinSystemX11GLContext.h
new file mode 100644
index 0000000000..d16a823410
--- /dev/null
+++ b/xbmc/windowing/X11/WinSystemX11GLContext.h
@@ -0,0 +1,66 @@
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#if defined(HAVE_X11)
+
+#include "WinSystemX11.h"
+#include "GLContext.h"
+#include "rendering/gl/RenderSystemGL.h"
+#include "utils/GlobalsHandling.h"
+#include "GL/glx.h"
+#include "EGL/egl.h"
+
+class CWinSystemX11GLContext : public CWinSystemX11, public CRenderSystemGL
+{
+public:
+  CWinSystemX11GLContext();
+  virtual ~CWinSystemX11GLContext();
+  virtual bool CreateNewWindow(const std::string& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction);
+  virtual bool ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop);
+  virtual bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays);
+  virtual bool DestroyWindowSystem();
+  virtual bool DestroyWindow();
+
+  virtual bool IsExtSupported(const char* extension);
+
+  GLXWindow GetWindow() { return m_pGLContext->m_glxWindow; }
+  GLXContext GetGlxContext() { return m_pGLContext->m_glxContext; }
+  EGLDisplay GetEGLDisplay() const { return m_pGLContext->m_eglDisplay; }
+  EGLSurface GetEGLSurface() const { return m_pGLContext->m_eglSurface; }
+  EGLContext GetEGLContext() const { return m_pGLContext->m_eglContext; }
+  EGLConfig GetEGLConfig() const { return m_pGLContext->m_eglConfig; }
+
+protected:
+  virtual bool SetWindow(int width, int height, bool fullscreen, const std::string &output, int *winstate = NULL);
+  virtual bool PresentRenderImpl(const CDirtyRegionList& dirty);
+  virtual void SetVSyncImpl(bool enable);
+  virtual bool RefreshGLContext(bool force);
+  virtual XVisualInfo* GetVisual();
+
+  CGLContext *m_pGLContext;
+  bool m_newGlContext;
+};
+
+XBMC_GLOBAL_REF(CWinSystemX11GLContext,g_Windowing);
+#define g_Windowing XBMC_GLOBAL_USE(CWinSystemX11GLContext)
+
+#endif //HAVE_X11
diff --git a/xbmc/windowing/X11/WinSystemX11GLES.cpp b/xbmc/windowing/X11/WinSystemX11GLES.cpp
deleted file mode 100644
index da64d85fc6..0000000000
--- a/xbmc/windowing/X11/WinSystemX11GLES.cpp
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- *      Copyright (C) 2005-2012 Team XBMC
- *      http://www.xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-#include "system.h"
-
-#if defined(HAS_EGL) && defined(HAVE_X11)
-
-#include <X11/Xlib.h>
-#include <X11/Xutil.h>
-
-#include "WinSystemX11GLES.h"
-#include "utils/log.h"
-#include "utils/StringUtils.h"
-#include "Application.h"
-#include "windowing/egl/EGLWrapper.h"
-
-CWinSystemX11GLES::CWinSystemX11GLES()
-{
-}
-
-CWinSystemX11GLES::~CWinSystemX11GLES()
-{
-}
-
-bool CWinSystemX11GLES::PresentRenderImpl(const CDirtyRegionList& dirty)
-{
-  if ((m_eglDisplay == EGL_NO_DISPLAY) || (m_eglSurface == EGL_NO_SURFACE))
-    return false;
-
-  eglSwapBuffers(m_eglDisplay, m_eglSurface);
-
-  return true;
-}
-
-void CWinSystemX11GLES::SetVSyncImpl(bool enable)
-{
-  eglSwapInterval(m_eglDisplay, enable ? 1 : 0);
-}
-
-bool CWinSystemX11GLES::IsExtSupported(const char* extension)
-{
-  if(strncmp(extension, "EGL_", 4) != 0)
-    return CRenderSystemGLES::IsExtSupported(extension);
-
-  std::string name;
-
-  name  = " ";
-  name += extension;
-  name += " ";
-
-  return m_eglext.find(name) != std::string::npos;
-}
-
-bool CWinSystemX11GLES::CreateNewWindow(const CStdString& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction)
-{
-  if(!CWinSystemX11::CreateNewWindow(name, fullScreen, res, userFunction))
-    return false;
-
-  std::string extensions = eglQueryString(m_eglDisplay, EGL_EXTENSIONS);
-  m_eglext = std::string(" ") + extensions + " ";
-
-  CLog::Log(LOGDEBUG, "EGL_EXTENSIONS:%s", m_eglext.c_str());
-
-  return true;
-}
-
-bool CWinSystemX11GLES::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
-{
-  m_newGlContext = false;
-  CWinSystemX11::ResizeWindow(newWidth, newHeight, newLeft, newTop);
-  CRenderSystemGLES::ResetRenderSystem(newWidth, newHeight, false, 0);
-
-  if (m_newGlContext)
-    g_application.ReloadSkin();
-
-  return true;
-}
-
-bool CWinSystemX11GLES::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
-{
-  m_newGlContext = false;
-  CWinSystemX11::SetFullScreen(fullScreen, res, blankOtherDisplays);
-  CRenderSystemGLES::ResetRenderSystem(res.iWidth, res.iHeight, fullScreen, res.fRefreshRate);
-
-  if (m_newGlContext)
-    g_application.ReloadSkin();
-
-  return true;
-}
-
-#endif
diff --git a/xbmc/windowing/X11/WinSystemX11GLES.h b/xbmc/windowing/X11/WinSystemX11GLES.h
deleted file mode 100644
index 4ea08ba5b2..0000000000
--- a/xbmc/windowing/X11/WinSystemX11GLES.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- *      Copyright (C) 2005-2012 Team XBMC
- *      http://www.xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#pragma once
-
-#if defined(HAS_GLES) && defined(HAVE_X11)
-
-#include "WinSystemX11.h"
-#include "rendering/gles/RenderSystemGLES.h"
-#include "utils/GlobalsHandling.h"
-
-class CWinSystemX11GLES : public CWinSystemX11, public CRenderSystemGLES
-{
-public:
-  CWinSystemX11GLES();
-  virtual ~CWinSystemX11GLES();
-  virtual bool CreateNewWindow(const CStdString& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction);
-  virtual bool ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop);
-  virtual bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays);
-
-  virtual bool IsExtSupported(const char* extension);
-
-protected:
-  virtual bool PresentRenderImpl(const CDirtyRegionList& dirty);
-  virtual void SetVSyncImpl(bool enable);
-
-  std::string m_eglext;
-};
-
-XBMC_GLOBAL_REF(CWinSystemX11GLES,g_Windowing);
-#define g_Windowing XBMC_GLOBAL_USE(CWinSystemX11GLES)
-
-#endif // HAS_GLES && HAVE_X11
diff --git a/xbmc/windowing/windows/WinSystemWin32GL.cpp b/xbmc/windowing/windows/WinSystemWin32GL.cpp
index 4ef93c7420..8d51cc5aef 100644
--- a/xbmc/windowing/windows/WinSystemWin32GL.cpp
+++ b/xbmc/windowing/windows/WinSystemWin32GL.cpp
@@ -30,7 +30,6 @@
 #include "guilib/gui3d.h"
 
 #ifdef HAS_GL
-#include <GL/glew.h>
 
 #pragma comment (lib,"opengl32.lib")
 #pragma comment (lib,"glu32.lib")

From 8d90c6df9dfbc1c154b34c05c89163bc09849e9d Mon Sep 17 00:00:00 2001
From: Arne Morten Kvarving <cptspiff@gmail.com>
Date: Thu, 10 Sep 2015 15:14:18 +0200
Subject: [PATCH 04/41] fixed: don't assing std::string to nullptr

---
 xbmc/windowing/X11/WinSystemX11GLContext.cpp | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11GLContext.cpp b/xbmc/windowing/X11/WinSystemX11GLContext.cpp
index ac071ca8a2..6510b14d46 100644
--- a/xbmc/windowing/X11/WinSystemX11GLContext.cpp
+++ b/xbmc/windowing/X11/WinSystemX11GLContext.cpp
@@ -178,10 +178,12 @@ bool CWinSystemX11GLContext::RefreshGLContext(bool force)
   if (ret && !firstrun)
     return ret;
 
-  std::string gpuvendor = "";
+  std::string gpuvendor;
   if (ret)
   {
-    gpuvendor = (const char*) glGetString(GL_VENDOR);
+    const char* vend = (const char*) glGetString(GL_VENDOR);
+    if (vend)
+      gpuvendor = vend;
   }
   std::transform(gpuvendor.begin(), gpuvendor.end(), gpuvendor.begin(), ::tolower);
   if (firstrun && (!ret || gpuvendor.compare(0, 5, "intel") != 0))

From ec8e472caa0108225859d7fb972d406675e90c97 Mon Sep 17 00:00:00 2001
From: Leonidas Kosmidis <lkosmid@users.noreply.github.com>
Date: Wed, 21 Oct 2015 15:12:52 +0100
Subject: [PATCH 05/41] Fixed compilation of refactored EGL on X11

---
 plex/CMakeModules/PlatformConfigLINUX.cmake    |   1 +
 xbmc/rendering/gles/RenderSystemGLES.h         |   1 +
 xbmc/system.h                                  | 626 +++++++++++++------------
 xbmc/windowing/WindowingFactory.h              |   5 +-
 xbmc/windowing/X11/GLContext.h                 |  16 -
 xbmc/windowing/X11/GLContextEGL.cpp            |  74 ++-
 xbmc/windowing/X11/GLContextEGL.h              |   5 +
 xbmc/windowing/X11/GLContextGLX.cpp            |   4 +-
 xbmc/windowing/X11/GLContextGLX.h              |   2 +
 xbmc/windowing/X11/Makefile                    |   1 +
 xbmc/windowing/X11/WinSystemX11GLContext.cpp   |  36 +-
 xbmc/windowing/X11/WinSystemX11GLContext.h     |  19 +-
 xbmc/windowing/X11/WinSystemX11GLESContext.cpp | 167 +++++++
 xbmc/windowing/X11/WinSystemX11GLESContext.h   |  62 +++
 14 files changed, 675 insertions(+), 344 deletions(-)
 create mode 100644 xbmc/windowing/X11/WinSystemX11GLESContext.cpp
 create mode 100644 xbmc/windowing/X11/WinSystemX11GLESContext.h

diff --git a/plex/CMakeModules/PlatformConfigLINUX.cmake b/plex/CMakeModules/PlatformConfigLINUX.cmake
index d2e074e542..d044d651a4 100644
--- a/plex/CMakeModules/PlatformConfigLINUX.cmake
+++ b/plex/CMakeModules/PlatformConfigLINUX.cmake
@@ -147,6 +147,7 @@ plex_get_soname(CURL_SONAME ${CURL_LIBRARY})
 ####
 if(DEFINED X11_FOUND)
   set(HAVE_X11 1)
+  plex_find_library(EGL 0 0  system/usr/lib 1)
 endif()
 
 if(DEFINED OPENGL_FOUND)
diff --git a/xbmc/rendering/gles/RenderSystemGLES.h b/xbmc/rendering/gles/RenderSystemGLES.h
index ab1f063c8b..c64eefea53 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.h
+++ b/xbmc/rendering/gles/RenderSystemGLES.h
@@ -61,6 +61,7 @@ public:
   virtual bool IsExtSupported(const char* extension);
 
   virtual void SetVSync(bool vsync);
+  virtual void ResetVSync() { m_bVsyncInit = false; }
 
   virtual void SetViewPort(CRect& viewPort);
   virtual void GetViewPort(CRect& viewPort);
diff --git a/xbmc/system.h b/xbmc/system.h
index f37a8498ee..772e7498f3 100644
--- a/xbmc/system.h
+++ b/xbmc/system.h
@@ -1,311 +1,315 @@
-#pragma once
-
-/*
- *      Copyright (C) 2005-2012 Team XBMC
- *      http://www.xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if defined(HAVE_CONFIG_H) && !defined(TARGET_WINDOWS)
-#include "config.h"
-#define DECLARE_UNUSED(a,b) a __attribute__((unused)) b;
-#endif
-
-/*****************
- * All platforms
- *****************/
-#define HAS_DVD_SWSCALE
-#define HAS_DVDPLAYER
-#define HAS_EVENT_SERVER
-//#define HAS_KARAOKE
-#define HAS_SCREENSAVER
-//#define HAS_PYTHON
-#define HAS_SYSINFO
-#define HAS_VIDEO_PLAYBACK
-#define HAS_VISUALISATION
-#ifndef __PLEX__
-#define HAS_PVRCLIENTS
-#endif
-
-#ifdef HAVE_LIBMICROHTTPD
-#define HAS_WEB_SERVER
-#ifndef __PLEX__
-#define HAS_WEB_INTERFACE
-#endif
-#endif
-
-#define HAS_JSONRPC
-
-#ifdef USE_ASAP_CODEC
-#define HAS_ASAP_CODEC
-#endif
-
-#define HAS_FILESYSTEM
-#define HAS_FILESYSTEM_CDDA
-//#define HAS_FILESYSTEM_RTV
-//#define HAS_FILESYSTEM_DAAP
-//#define HAS_FILESYSTEM_SAP
-//#define HAS_FILESYSTEM_VTP
-#define HAS_FILESYSTEM_HTSP
-
-#ifdef HAVE_LIBSMBCLIENT
-  #define HAS_FILESYSTEM_SMB
-#endif
-
-#ifdef HAVE_LIBNFS
-  #define HAS_FILESYSTEM_NFS
-#endif
-
-#ifdef HAVE_LIBAFPCLIENT
-  #define HAS_FILESYSTEM_AFP
-#endif
-
-#ifdef HAVE_LIBPLIST
-  //#define HAS_AIRPLAY
-#endif
-
-#if defined(HAVE_LIBSHAIRPORT) || defined(HAVE_LIBSHAIRPLAY)
-  //#define HAS_AIRTUNES
-#endif
-
-#ifdef HAVE_MYSQL
-  #define HAS_MYSQL
-#endif
-
-#if defined(USE_UPNP)
-  #define HAS_UPNP
-#endif
-
-/**********************
- * Non-free Components
- **********************/
-
-#if defined(TARGET_WINDOWS)
-  //#define HAS_FILESYSTEM_RAR
-#else
-  #if defined(HAVE_XBMC_NONFREE)
-    //#define HAS_FILESYSTEM_RAR
-  #endif
-#endif
-
-/*****************
- * Win32 Specific
- *****************/
-
-#if defined(TARGET_WINDOWS)
-#define HAS_SDL_JOYSTICK
-#ifndef __PLEX__
-#define HAS_DVD_DRIVE
-#endif
-#define HAS_WIN32_NETWORK
-#define HAS_IRSERVERSUITE
-#define HAS_AUDIO
-#define HAS_WEB_SERVER
-#define HAS_WEB_INTERFACE
-#ifndef __PLEX__
-#define HAVE_LIBSSH
-#endif
-#define HAS_LIBRTMP
-#ifndef __PLEX__
-#define HAVE_LIBBLURAY
-#endif
-#define HAS_ASAP_CODEC
-#define HAVE_YAJL_YAJL_VERSION_H
-#ifndef __PLEX__
-#define HAS_FILESYSTEM_SMB
-#define HAS_FILESYSTEM_NFS
-#endif
-#define HAS_ZEROCONF
-#ifndef __PLEX__
-#define HAS_AIRPLAY
-#define HAS_AIRTUNES
-#endif
-#define HAVE_LIBSHAIRPLAY
-#define HAVE_LIBCEC
-#ifndef __PLEX__
-#define HAVE_LIBMP3LAME
-#define HAVE_LIBVORBISENC
-#define HAS_MYSQL
-#endif
-#define HAS_UPNP
-
-/* PLEX */
-#define ENABLE_AUTOUPDATE
-/* END PLEX */
-
-#define DECLARE_UNUSED(a,b) a b;
-#endif
-
-/*****************
- * Mac Specific
- *****************/
-
-#if defined(TARGET_DARWIN)
-  #if defined(TARGET_DARWIN_OSX)
-    #define HAS_GL
-    #define HAS_SDL
-    #define HAS_SDL_OPENGL
-    #define HAS_SDL_WIN_EVENTS
-  #endif
-  #define HAS_ZEROCONF
-  #define HAS_LINUX_NETWORK
-  #define HAS_LCD
-#endif
-
-/*****************
- * Linux Specific
- *****************/
-
-#if defined(TARGET_LINUX) || defined(TARGET_FREEBSD)
-#if defined(HAVE_LIBAVAHI_COMMON) && defined(HAVE_LIBAVAHI_CLIENT)
-#define HAS_ZEROCONF
-#define HAS_AVAHI
-#endif
-#define HAS_LCD
-#ifdef HAVE_DBUS
-#define HAS_DBUS
-#endif
-#define HAS_GL
-#ifdef HAVE_X11
-#define HAS_GLX
-#define HAS_X11_WIN_EVENTS
-#endif
-#ifdef HAVE_SDL
-#define HAS_SDL
-#ifndef HAS_SDL_OPENGL
-#define HAS_SDL_OPENGL
-#endif
-#ifndef HAVE_X11
-#define HAS_SDL_WIN_EVENTS
-#endif
-#else
-#ifndef HAVE_X11
-#define HAS_LINUX_EVENTS
-#endif
-#endif
-#define HAS_LINUX_NETWORK
-#define HAS_LIRC
-#ifdef HAVE_LIBPULSE
-#define HAS_PULSEAUDIO
-#endif
-#ifdef HAVE_LIBXRANDR
-#define HAS_XRANDR
-#endif
-#ifdef HAVE_ALSA
-#define HAS_ALSA
-#endif
-#endif
-
-#ifdef HAVE_LIBSSH
-#define HAS_FILESYSTEM_SFTP
-#endif
-
-/*****************
- * Git revision
- *****************/
-
-//#if defined(TARGET_DARWIN)
-//#include "../git_revision.h"
-//#endif
-
-//#ifndef GIT_REV
-//#define GIT_REV "Unknown"
-//#endif
-
-/****************************************
- * Additional platform specific includes
- ****************************************/
-
-#if defined(TARGET_WINDOWS)
-#include <windows.h>
-#define DIRECTINPUT_VERSION 0x0800
-#include "mmsystem.h"
-#include "DInput.h"
-#include "DSound.h"
-#define DSSPEAKER_USE_DEFAULT DSSPEAKER_STEREO
-#define LPDIRECTSOUND8 LPDIRECTSOUND
-#undef GetFreeSpace
-#include "PlatformInclude.h"
-#ifdef HAS_DX
-#include "D3D9.h"   // On Win32, we're always using DirectX for something, whether it be the actual rendering
-#include "D3DX9.h"  // or the reference video clock.
-#else
-#include <d3d9types.h>
-#endif
-#ifdef HAS_SDL
-#include "SDL\SDL.h"
-#endif
-#endif
-
-#if defined(TARGET_POSIX)
-#include <time.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <errno.h>
-#include "PlatformInclude.h"
-#endif
-
-#if defined(TARGET_ANDROID)
-#undef HAS_LINUX_EVENTS
-#undef HAS_LIRC
-#undef HAS_LCD
-#endif
-
-// EGL detected. Dont use GLX!
-#ifdef HAVE_LIBEGL
-#undef HAS_GLX
-#define HAS_EGL
-#endif
-
-// GLES2.0 detected. Dont use GL!
-#ifdef HAVE_LIBGLESV2
-#undef HAS_GL
-#define HAS_GLES 2
-/* PLEX */
-#if defined(TARGET_RASPBERRY_PI)
-  #undef HAS_SDL_WIN_EVENTS
-  #define HAS_LINUX_EVENTS
-#endif
-/* END PLEX */
-#endif
-
-// GLES1.0 detected. Dont use GL!
-#ifdef HAVE_LIBGLES
-#undef HAS_GL
-#define HAS_GLES 1
-#endif
-
-#ifdef HAS_DVD_DRIVE
-#ifndef __PLEX__
-#define HAS_CDDA_RIPPER
-#endif
-#endif
-
-#define SAFE_DELETE(p)       do { delete (p);     (p)=NULL; } while (0)
-#define SAFE_DELETE_ARRAY(p) do { delete[] (p);   (p)=NULL; } while (0)
-#define SAFE_RELEASE(p)      do { if(p) { (p)->Release(); (p)=NULL; } } while (0)
-
-// Useful pixel colour manipulation macros
-#define GET_A(color)            ((color >> 24) & 0xFF)
-#define GET_R(color)            ((color >> 16) & 0xFF)
-#define GET_G(color)            ((color >>  8) & 0xFF)
-#define GET_B(color)            ((color >>  0) & 0xFF)
-/* PLEX */
-#if defined(TARGET_RASPBERRY_PI)
-  #undef HAS_SDL_JOYSTICK
-#endif
-/* END PLEX */
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if defined(HAVE_CONFIG_H) && !defined(TARGET_WINDOWS)
+#include "config.h"
+#define DECLARE_UNUSED(a,b) a __attribute__((unused)) b;
+#endif
+
+/*****************
+ * All platforms
+ *****************/
+#define HAS_DVD_SWSCALE
+#define HAS_DVDPLAYER
+#define HAS_EVENT_SERVER
+//#define HAS_KARAOKE
+#define HAS_SCREENSAVER
+//#define HAS_PYTHON
+#define HAS_SYSINFO
+#define HAS_VIDEO_PLAYBACK
+#define HAS_VISUALISATION
+#ifndef __PLEX__
+#define HAS_PVRCLIENTS
+#endif
+
+#ifdef HAVE_LIBMICROHTTPD
+#define HAS_WEB_SERVER
+#ifndef __PLEX__
+#define HAS_WEB_INTERFACE
+#endif
+#endif
+
+#define HAS_JSONRPC
+
+#ifdef USE_ASAP_CODEC
+#define HAS_ASAP_CODEC
+#endif
+
+#define HAS_FILESYSTEM
+#define HAS_FILESYSTEM_CDDA
+//#define HAS_FILESYSTEM_RTV
+//#define HAS_FILESYSTEM_DAAP
+//#define HAS_FILESYSTEM_SAP
+//#define HAS_FILESYSTEM_VTP
+#define HAS_FILESYSTEM_HTSP
+
+#ifdef HAVE_LIBSMBCLIENT
+  #define HAS_FILESYSTEM_SMB
+#endif
+
+#ifdef HAVE_LIBNFS
+  #define HAS_FILESYSTEM_NFS
+#endif
+
+#ifdef HAVE_LIBAFPCLIENT
+  #define HAS_FILESYSTEM_AFP
+#endif
+
+#ifdef HAVE_LIBPLIST
+  //#define HAS_AIRPLAY
+#endif
+
+#if defined(HAVE_LIBSHAIRPORT) || defined(HAVE_LIBSHAIRPLAY)
+  //#define HAS_AIRTUNES
+#endif
+
+#ifdef HAVE_MYSQL
+  #define HAS_MYSQL
+#endif
+
+#if defined(USE_UPNP)
+  #define HAS_UPNP
+#endif
+
+/**********************
+ * Non-free Components
+ **********************/
+
+#if defined(TARGET_WINDOWS)
+  //#define HAS_FILESYSTEM_RAR
+#else
+  #if defined(HAVE_XBMC_NONFREE)
+    //#define HAS_FILESYSTEM_RAR
+  #endif
+#endif
+
+/*****************
+ * Win32 Specific
+ *****************/
+
+#if defined(TARGET_WINDOWS)
+#define HAS_SDL_JOYSTICK
+#ifndef __PLEX__
+#define HAS_DVD_DRIVE
+#endif
+#define HAS_WIN32_NETWORK
+#define HAS_IRSERVERSUITE
+#define HAS_AUDIO
+#define HAS_WEB_SERVER
+#define HAS_WEB_INTERFACE
+#ifndef __PLEX__
+#define HAVE_LIBSSH
+#endif
+#define HAS_LIBRTMP
+#ifndef __PLEX__
+#define HAVE_LIBBLURAY
+#endif
+#define HAS_ASAP_CODEC
+#define HAVE_YAJL_YAJL_VERSION_H
+#ifndef __PLEX__
+#define HAS_FILESYSTEM_SMB
+#define HAS_FILESYSTEM_NFS
+#endif
+#define HAS_ZEROCONF
+#ifndef __PLEX__
+#define HAS_AIRPLAY
+#define HAS_AIRTUNES
+#endif
+#define HAVE_LIBSHAIRPLAY
+#define HAVE_LIBCEC
+#ifndef __PLEX__
+#define HAVE_LIBMP3LAME
+#define HAVE_LIBVORBISENC
+#define HAS_MYSQL
+#endif
+#define HAS_UPNP
+
+/* PLEX */
+#define ENABLE_AUTOUPDATE
+/* END PLEX */
+
+#define DECLARE_UNUSED(a,b) a b;
+#endif
+
+/*****************
+ * Mac Specific
+ *****************/
+
+#if defined(TARGET_DARWIN)
+  #if defined(TARGET_DARWIN_OSX)
+    #define HAS_GL
+    #define HAS_SDL
+    #define HAS_SDL_OPENGL
+    #define HAS_SDL_WIN_EVENTS
+  #endif
+  #define HAS_ZEROCONF
+  #define HAS_LINUX_NETWORK
+  #define HAS_LCD
+#endif
+
+/*****************
+ * Linux Specific
+ *****************/
+
+#if defined(TARGET_LINUX) || defined(TARGET_FREEBSD)
+#if defined(HAVE_LIBAVAHI_COMMON) && defined(HAVE_LIBAVAHI_CLIENT)
+#define HAS_ZEROCONF
+#define HAS_AVAHI
+#endif
+#define HAS_LCD
+#ifdef HAVE_DBUS
+#define HAS_DBUS
+#endif
+#define HAS_GL
+#ifdef HAVE_X11
+#define HAS_X11_WIN_EVENTS
+#endif
+#ifdef HAVE_SDL
+#define HAS_SDL
+#ifndef HAS_SDL_OPENGL
+#define HAS_SDL_OPENGL
+#endif
+#ifndef HAVE_X11
+#define HAS_SDL_WIN_EVENTS
+#endif
+#else
+#ifndef HAVE_X11
+#define HAS_LINUX_EVENTS
+#endif
+#endif
+#define HAS_LINUX_NETWORK
+#define HAS_LIRC
+#ifdef HAVE_LIBPULSE
+#define HAS_PULSEAUDIO
+#endif
+#ifdef HAVE_LIBXRANDR
+#define HAS_XRANDR
+#endif
+#ifdef HAVE_ALSA
+#define HAS_ALSA
+#endif
+#endif
+
+#ifdef HAVE_LIBSSH
+#define HAS_FILESYSTEM_SFTP
+#endif
+
+/*****************
+ * Git revision
+ *****************/
+
+//#if defined(TARGET_DARWIN)
+//#include "../git_revision.h"
+//#endif
+
+//#ifndef GIT_REV
+//#define GIT_REV "Unknown"
+//#endif
+
+#if defined(HAVE_X11)
+#define HAS_EGL
+#if !defined(HAVE_LIBGLESV2)
+#define HAS_GLX
+#endif
+#endif
+
+/****************************************
+ * Additional platform specific includes
+ ****************************************/
+
+#if defined(TARGET_WINDOWS)
+#include <windows.h>
+#define DIRECTINPUT_VERSION 0x0800
+#include "mmsystem.h"
+#include "DInput.h"
+#include "DSound.h"
+#define DSSPEAKER_USE_DEFAULT DSSPEAKER_STEREO
+#define LPDIRECTSOUND8 LPDIRECTSOUND
+#undef GetFreeSpace
+#include "PlatformInclude.h"
+#ifdef HAS_DX
+#include "D3D9.h"   // On Win32, we're always using DirectX for something, whether it be the actual rendering
+#include "D3DX9.h"  // or the reference video clock.
+#else
+#include <d3d9types.h>
+#endif
+#ifdef HAS_SDL
+#include "SDL\SDL.h"
+#endif
+#endif
+
+#if defined(TARGET_POSIX)
+#include <time.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <errno.h>
+#include "PlatformInclude.h"
+#endif
+
+#if defined(TARGET_ANDROID)
+#undef HAS_LINUX_EVENTS
+#undef HAS_LIRC
+#undef HAS_LCD
+#endif
+
+#ifdef HAVE_LIBEGL
+#define HAS_EGL
+#endif
+
+// GLES2.0 detected. Dont use GL!
+#ifdef HAVE_LIBGLESV2
+#undef HAS_GL
+#define HAS_GLES 2
+/* PLEX */
+#if defined(TARGET_RASPBERRY_PI)
+  #undef HAS_SDL_WIN_EVENTS
+  #define HAS_LINUX_EVENTS
+#endif
+/* END PLEX */
+#endif
+
+// GLES1.0 detected. Dont use GL!
+#ifdef HAVE_LIBGLES
+#undef HAS_GL
+#define HAS_GLES 1
+#endif
+
+#ifdef HAS_DVD_DRIVE
+#ifndef __PLEX__
+#define HAS_CDDA_RIPPER
+#endif
+#endif
+
+#define SAFE_DELETE(p)       do { delete (p);     (p)=NULL; } while (0)
+#define SAFE_DELETE_ARRAY(p) do { delete[] (p);   (p)=NULL; } while (0)
+#define SAFE_RELEASE(p)      do { if(p) { (p)->Release(); (p)=NULL; } } while (0)
+
+// Useful pixel colour manipulation macros
+#define GET_A(color)            ((color >> 24) & 0xFF)
+#define GET_R(color)            ((color >> 16) & 0xFF)
+#define GET_G(color)            ((color >>  8) & 0xFF)
+#define GET_B(color)            ((color >>  0) & 0xFF)
+/* PLEX */
+#if defined(TARGET_RASPBERRY_PI)
+  #undef HAS_SDL_JOYSTICK
+#endif
+/* END PLEX */
diff --git a/xbmc/windowing/WindowingFactory.h b/xbmc/windowing/WindowingFactory.h
index 38bf2a9aa2..652a32e82b 100644
--- a/xbmc/windowing/WindowingFactory.h
+++ b/xbmc/windowing/WindowingFactory.h
@@ -29,7 +29,10 @@
 #elif defined(TARGET_WINDOWS) && defined(HAS_DX)
 #include "windows/WinSystemWin32DX.h"
 
-#elif defined(TARGET_LINUX)   && defined(HAVE_X11)
+#elif defined(TARGET_LINUX)   && defined(HAVE_X11)   && defined(HAS_GLES)
+#include "X11/WinSystemX11GLESContext.h"
+
+#elif defined(TARGET_LINUX)   && defined(HAVE_X11)   && defined(HAS_GL)
 #include "X11/WinSystemX11GLContext.h"
 
 #elif defined(TARGET_LINUX)   && defined(HAS_GLES) && defined(HAS_EGL) && !defined(HAVE_X11)
diff --git a/xbmc/windowing/X11/GLContext.h b/xbmc/windowing/X11/GLContext.h
index f3efdc8130..f0b55a2385 100644
--- a/xbmc/windowing/X11/GLContext.h
+++ b/xbmc/windowing/X11/GLContext.h
@@ -21,14 +21,10 @@
 #pragma once
 
 #if defined(HAVE_X11)
-#include "GL/glx.h"
-#include "EGL/egl.h"
 #include "X11/Xlib.h"
 #include "guilib/DirtyRegion.h"
 #include <string>
 
-#define EGL_NO_CONFIG (EGLConfig)0
-
 class CGLContext
 {
 public:
@@ -36,12 +32,6 @@ public:
   {
     m_dpy = dpy;
     m_extensions = "";
-    m_glxWindow = 0;
-    m_glxContext = 0;
-    m_eglDisplay = EGL_NO_DISPLAY;
-    m_eglSurface = EGL_NO_SURFACE;
-    m_eglContext = EGL_NO_CONTEXT;
-    m_eglConfig = EGL_NO_CONFIG;
   }
   virtual ~CGLContext() {};
   virtual bool Refresh(bool force, int screen, Window glWindow, bool &newContext) = 0;
@@ -57,12 +47,6 @@ public:
   std::string m_extensions;
 
   Display *m_dpy;
-  GLXWindow m_glxWindow;
-  GLXContext m_glxContext;
-  EGLDisplay m_eglDisplay;
-  EGLSurface m_eglSurface;
-  EGLContext m_eglContext;
-  EGLConfig m_eglConfig;
 };
 
 #endif
diff --git a/xbmc/windowing/X11/GLContextEGL.cpp b/xbmc/windowing/X11/GLContextEGL.cpp
index fb00504867..c84aff3d14 100644
--- a/xbmc/windowing/X11/GLContextEGL.cpp
+++ b/xbmc/windowing/X11/GLContextEGL.cpp
@@ -17,17 +17,35 @@
  *  <http://www.gnu.org/licenses/>.
  *
  */
-
 #include "system.h"
 
-#if defined(HAVE_X11)
+#if defined(HAVE_X11) && defined(HAS_EGL)
+
+#ifdef HAS_GL
+  // always define GL_GLEXT_PROTOTYPES before include gl headers
+  #if !defined(GL_GLEXT_PROTOTYPES)
+    #define GL_GLEXT_PROTOTYPES
+  #endif
+  #include <GL/gl.h>
+  #include <GL/glu.h>
+  #include <GL/glext.h>
+#elif HAS_GLES == 2
+  #include <GLES2/gl2.h>
+  #include <GLES2/gl2ext.h>
+#endif
 
 #include "GLContextEGL.h"
 #include "utils/log.h"
 
+#define EGL_NO_CONFIG (EGLConfig)0
+
 CGLContextEGL::CGLContextEGL(Display *dpy) : CGLContext(dpy)
 {
   m_extPrefix = "EGL_";
+  m_eglDisplay = EGL_NO_DISPLAY;
+  m_eglSurface = EGL_NO_SURFACE;
+  m_eglContext = EGL_NO_CONTEXT;
+  m_eglConfig = EGL_NO_CONFIG;
 }
 
 CGLContextEGL::~CGLContextEGL()
@@ -165,7 +183,10 @@ bool CGLContextEGL::Refresh(bool force, int screen, Window glWindow, bool &newCo
     }
 #endif
 
-    m_eglConfig = getEGLConfig(m_eglDisplay, vInfo);
+    if(m_eglConfig == EGL_NO_CONFIG)
+    {
+      m_eglConfig = getEGLConfig(m_eglDisplay, vInfo);
+    }
 
     if (m_eglConfig == EGL_NO_CONFIG)
     {
@@ -364,4 +385,51 @@ bool CGLContextEGL::IsExtSupported(const char* extension)
   return m_extensions.find(name) != std::string::npos;
 }
 
+XVisualInfo* CGLContextEGL::GetVisual()
+{
+    GLint att[] =
+    {
+      EGL_RED_SIZE, 8,
+      EGL_GREEN_SIZE, 8,
+      EGL_BLUE_SIZE, 8,
+      EGL_ALPHA_SIZE, 8,
+      EGL_BUFFER_SIZE, 32,
+      EGL_DEPTH_SIZE, 24,
+      EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+      EGL_NONE
+    };
+
+    if (m_eglDisplay == EGL_NO_DISPLAY)
+    {
+      m_eglDisplay = eglGetDisplay((EGLNativeDisplayType)m_dpy);
+      if (m_eglDisplay == EGL_NO_DISPLAY)
+      {
+        CLog::Log(LOGERROR, "failed to get egl display\n");
+	return NULL;
+      }
+      if (!eglInitialize(m_eglDisplay, NULL, NULL))
+      {
+	CLog::Log(LOGERROR, "failed to initialize egl display\n");
+	return NULL;
+      }
+    }
+
+    EGLint numConfigs;
+    EGLConfig eglConfig = 0;
+    if (!eglChooseConfig(m_eglDisplay, att, &eglConfig, 1, &numConfigs) || numConfigs == 0) {
+      CLog::Log(LOGERROR, "Failed to choose a config %d\n", eglGetError());
+    }
+    m_eglConfig=eglConfig;
+
+    XVisualInfo x11_visual_info_template;
+    if (!eglGetConfigAttrib(m_eglDisplay, m_eglConfig, EGL_NATIVE_VISUAL_ID, (EGLint*)&x11_visual_info_template.visualid)) {
+      CLog::Log(LOGERROR, "Failed to query native visual id\n");
+    }
+    int num_visuals;
+    return XGetVisualInfo(m_dpy,
+                        VisualIDMask,
+			&x11_visual_info_template,
+			&num_visuals);
+}
+
 #endif
diff --git a/xbmc/windowing/X11/GLContextEGL.h b/xbmc/windowing/X11/GLContextEGL.h
index dac7075745..9e82d176a8 100644
--- a/xbmc/windowing/X11/GLContextEGL.h
+++ b/xbmc/windowing/X11/GLContextEGL.h
@@ -36,6 +36,11 @@ public:
   virtual bool SwapBuffers(const CDirtyRegionList& dirty, int &mode);
   virtual void QueryExtensions();
   virtual bool IsExtSupported(const char* extension);
+  XVisualInfo* GetVisual();
+  EGLDisplay m_eglDisplay;
+  EGLSurface m_eglSurface;
+  EGLContext m_eglContext;
+  EGLConfig m_eglConfig;
 protected:
   bool IsSuitableVisual(XVisualInfo *vInfo);
   EGLConfig getEGLConfig(EGLDisplay eglDisplay, XVisualInfo *vInfo);
diff --git a/xbmc/windowing/X11/GLContextGLX.cpp b/xbmc/windowing/X11/GLContextGLX.cpp
index 6dc3d842bc..f14e711edf 100644
--- a/xbmc/windowing/X11/GLContextGLX.cpp
+++ b/xbmc/windowing/X11/GLContextGLX.cpp
@@ -20,7 +20,7 @@
 
 #include "system_gl.h"
 
-#if defined(HAVE_X11)
+#if defined(HAVE_X11) && defined(HAS_GL)
 
 #include <GL/glx.h>
 #include "GLContextGLX.h"
@@ -29,6 +29,8 @@
 CGLContextGLX::CGLContextGLX(Display *dpy) : CGLContext(dpy)
 {
   m_extPrefix = "GLX_";
+  m_glxWindow = 0;
+  m_glxContext = 0;
 }
 
 bool CGLContextGLX::Refresh(bool force, int screen, Window glWindow, bool &newContext)
diff --git a/xbmc/windowing/X11/GLContextGLX.h b/xbmc/windowing/X11/GLContextGLX.h
index c19a257503..6ccebaaea2 100644
--- a/xbmc/windowing/X11/GLContextGLX.h
+++ b/xbmc/windowing/X11/GLContextGLX.h
@@ -35,6 +35,8 @@ public:
   virtual bool SwapBuffers(const CDirtyRegionList& dirty, int &mode);
   virtual void QueryExtensions();
   virtual bool IsExtSupported(const char* extension);
+  GLXWindow m_glxWindow;
+  GLXContext m_glxContext;
 protected:
   bool IsSuitableVisual(XVisualInfo *vInfo);
 
diff --git a/xbmc/windowing/X11/Makefile b/xbmc/windowing/X11/Makefile
index 3f002765e0..0fa153536e 100644
--- a/xbmc/windowing/X11/Makefile
+++ b/xbmc/windowing/X11/Makefile
@@ -1,5 +1,6 @@
 SRCS=WinSystemX11.cpp \
      WinSystemX11GLContext.cpp \
+     WinSystemX11GLESContext.cpp \
      GLContextEGL.cpp \
      GLContextGLX.cpp \
      XRandR.cpp \
diff --git a/xbmc/windowing/X11/WinSystemX11GLContext.cpp b/xbmc/windowing/X11/WinSystemX11GLContext.cpp
index 6510b14d46..a7a25f1752 100644
--- a/xbmc/windowing/X11/WinSystemX11GLContext.cpp
+++ b/xbmc/windowing/X11/WinSystemX11GLContext.cpp
@@ -19,12 +19,14 @@
  */
 #include "system.h"
 
-#if defined(HAVE_X11)
+#if defined(HAVE_X11) && defined(HAS_GL)
 
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
 
 #include "WinSystemX11GLContext.h"
+#include "GLContextGLX.h"
+#include "GLContextEGL.h"
 #include "utils/log.h"
 #include "utils/StringUtils.h"
 #include "guilib/GraphicContext.h"
@@ -32,8 +34,6 @@
 #include "threads/SingleLock.h"
 #include <vector>
 #include "Application.h"
-#include "GLContextEGL.h"
-#include "GLContextGLX.h"
 
 CWinSystemX11GLContext::CWinSystemX11GLContext()
 {
@@ -73,6 +73,36 @@ bool CWinSystemX11GLContext::IsExtSupported(const char* extension)
   return m_pGLContext->IsExtSupported(extension);
 }
 
+GLXWindow CWinSystemX11GLContext::GetWindow() const
+{
+  return static_cast<CGLContextGLX*>(m_pGLContext)->m_glxWindow;
+}
+
+GLXContext CWinSystemX11GLContext::GetGlxContext() const
+{
+  return static_cast<CGLContextGLX*>(m_pGLContext)->m_glxContext;
+}
+
+EGLDisplay CWinSystemX11GLContext::GetEGLDisplay() const
+{
+  return static_cast<CGLContextEGL*>(m_pGLContext)->m_eglDisplay;
+}
+
+EGLSurface CWinSystemX11GLContext::GetEGLSurface() const
+{
+  return static_cast<CGLContextEGL*>(m_pGLContext)->m_eglSurface;
+}
+
+EGLContext CWinSystemX11GLContext::GetEGLContext() const
+{
+  return static_cast<CGLContextEGL*>(m_pGLContext)->m_eglContext;
+}
+
+EGLConfig CWinSystemX11GLContext::GetEGLConfig() const
+{
+  return static_cast<CGLContextEGL*>(m_pGLContext)->m_eglConfig;
+}
+
 bool CWinSystemX11GLContext::SetWindow(int width, int height, bool fullscreen, const std::string &output, int *winstate)
 {
   int newwin = 0;
diff --git a/xbmc/windowing/X11/WinSystemX11GLContext.h b/xbmc/windowing/X11/WinSystemX11GLContext.h
index d16a823410..461f0eb26a 100644
--- a/xbmc/windowing/X11/WinSystemX11GLContext.h
+++ b/xbmc/windowing/X11/WinSystemX11GLContext.h
@@ -23,11 +23,12 @@
 #if defined(HAVE_X11)
 
 #include "WinSystemX11.h"
-#include "GLContext.h"
-#include "rendering/gl/RenderSystemGL.h"
-#include "utils/GlobalsHandling.h"
 #include "GL/glx.h"
 #include "EGL/egl.h"
+#include "rendering/gl/RenderSystemGL.h"
+#include "utils/GlobalsHandling.h"
+
+class CGLContext;
 
 class CWinSystemX11GLContext : public CWinSystemX11, public CRenderSystemGL
 {
@@ -42,12 +43,12 @@ public:
 
   virtual bool IsExtSupported(const char* extension);
 
-  GLXWindow GetWindow() { return m_pGLContext->m_glxWindow; }
-  GLXContext GetGlxContext() { return m_pGLContext->m_glxContext; }
-  EGLDisplay GetEGLDisplay() const { return m_pGLContext->m_eglDisplay; }
-  EGLSurface GetEGLSurface() const { return m_pGLContext->m_eglSurface; }
-  EGLContext GetEGLContext() const { return m_pGLContext->m_eglContext; }
-  EGLConfig GetEGLConfig() const { return m_pGLContext->m_eglConfig; }
+  GLXWindow GetWindow() const;
+  GLXContext GetGlxContext() const;
+  EGLDisplay GetEGLDisplay() const;
+  EGLSurface GetEGLSurface() const;
+  EGLContext GetEGLContext() const;
+  EGLConfig GetEGLConfig() const;
 
 protected:
   virtual bool SetWindow(int width, int height, bool fullscreen, const std::string &output, int *winstate = NULL);
diff --git a/xbmc/windowing/X11/WinSystemX11GLESContext.cpp b/xbmc/windowing/X11/WinSystemX11GLESContext.cpp
new file mode 100644
index 0000000000..92f05d4467
--- /dev/null
+++ b/xbmc/windowing/X11/WinSystemX11GLESContext.cpp
@@ -0,0 +1,167 @@
+#include "system.h"
+
+#if defined(HAVE_X11) && defined(HAS_GLES)
+
+#include "WinSystemX11GLESContext.h"
+#include "utils/log.h"
+#include "guilib/GraphicContext.h"
+#include "guilib/DispResource.h"
+#include "threads/SingleLock.h"
+#include "Application.h"
+
+CWinSystemX11GLESContext::CWinSystemX11GLESContext()
+{
+  m_pGLContext = NULL;
+}
+
+CWinSystemX11GLESContext::~CWinSystemX11GLESContext()
+{
+  delete m_pGLContext;
+}
+
+bool CWinSystemX11GLESContext::PresentRenderImpl(const CDirtyRegionList& dirty)
+{
+  m_pGLContext->SwapBuffers(dirty, m_iVSyncMode);
+  if (m_delayDispReset && m_dispResetTimer.IsTimePast())
+  {
+    m_delayDispReset = false;
+    CSingleLock lock(m_resourceSection);
+    // tell any shared resources
+    for (std::vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
+      (*i)->OnResetDevice();
+  }
+  return true;
+}
+
+void CWinSystemX11GLESContext::SetVSyncImpl(bool enable)
+{
+  m_pGLContext->SetVSync(enable, m_iVSyncMode);
+}
+
+bool CWinSystemX11GLESContext::IsExtSupported(const char* extension)
+{
+  if(strncmp(extension, m_pGLContext->ExtPrefix().c_str(), 4) != 0)
+    return CRenderSystemGLES::IsExtSupported(extension);
+
+  return m_pGLContext->IsExtSupported(extension);
+}
+
+bool CWinSystemX11GLESContext::SetWindow(int width, int height, bool fullscreen, const std::string &output, int *winstate)
+{
+  int newwin = 0;
+  CWinSystemX11::SetWindow(width, height, fullscreen, output, &newwin);
+  if (newwin)
+  {
+    CDirtyRegionList dr;
+    RefreshGLContext(m_currentOutput.compare(output) != 0);
+    XSync(m_dpy, FALSE);
+    g_graphicsContext.Clear(0);
+    g_graphicsContext.Flip(dr);
+    ResetVSync();
+
+    m_windowDirty = false;
+    m_bIsInternalXrr = false;
+
+    if (!m_delayDispReset)
+    {
+      CSingleLock lock(m_resourceSection);
+      // tell any shared resources
+      for (std::vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
+        (*i)->OnResetDevice();
+    }
+  }
+  return true;
+}
+
+bool CWinSystemX11GLESContext::CreateNewWindow(const std::string& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction)
+{
+  CLog::Log(LOGNOTICE, "CWinSystemX11GLESContext::CreateNewWindow");
+  if(!CWinSystemX11::CreateNewWindow(name, fullScreen, res, userFunction))
+    return false;
+
+  m_pGLContext->QueryExtensions();
+  return true;
+}
+
+bool CWinSystemX11GLESContext::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
+{
+  m_newGlContext = false;
+  CWinSystemX11::ResizeWindow(newWidth, newHeight, newLeft, newTop);
+  CRenderSystemGLES::ResetRenderSystem(newWidth, newHeight, false, 0);
+
+  if (m_newGlContext)
+    g_application.ReloadSkin();
+
+  return true;
+}
+
+bool CWinSystemX11GLESContext::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
+{
+  m_newGlContext = false;
+  CWinSystemX11::SetFullScreen(fullScreen, res, blankOtherDisplays);
+  CRenderSystemGLES::ResetRenderSystem(res.iWidth, res.iHeight, fullScreen, res.fRefreshRate);
+
+  if (m_newGlContext)
+    g_application.ReloadSkin();
+
+  return true;
+}
+
+bool CWinSystemX11GLESContext::DestroyWindowSystem()
+{
+  bool ret;
+  m_pGLContext->Destroy();
+  ret = CWinSystemX11::DestroyWindowSystem();
+  return ret;
+}
+
+bool CWinSystemX11GLESContext::DestroyWindow()
+{
+  bool ret;
+  m_pGLContext->Detach();
+  ret = CWinSystemX11::DestroyWindow();
+  return ret;
+}
+
+XVisualInfo* CWinSystemX11GLESContext::GetVisual()
+{
+  CLog::Log(LOGNOTICE, "CWinSystemX11GLESContext::GetVisual() m_pGLContext:%p GetVisual", m_pGLContext);
+  if(!m_pGLContext)
+  {
+    CLog::Log(LOGNOTICE, "Create new CGLContextEGL at CWinSystemX11GLESContext::CreateNewWindow, m_dpy=%p", m_dpy);
+    m_pGLContext = new CGLContextEGL(m_dpy);
+  }
+  return m_pGLContext->GetVisual();
+}
+
+bool CWinSystemX11GLESContext::RefreshGLContext(bool force)
+{
+  bool firstrun = false;
+  if (!m_pGLContext)
+  {
+    m_pGLContext = new CGLContextEGL(m_dpy);
+    firstrun = true;
+  }
+  bool ret = m_pGLContext->Refresh(force, m_nScreen, m_glWindow, m_newGlContext);
+
+  if (ret && !firstrun)
+    return ret;
+
+  std::string gpuvendor;
+  if (ret)
+  {
+    const char* vend = (const char*) glGetString(GL_VENDOR);
+    if (vend)
+      gpuvendor = vend;
+  }
+  std::transform(gpuvendor.begin(), gpuvendor.end(), gpuvendor.begin(), ::tolower);
+  if (firstrun && (!ret || gpuvendor.compare(0, 5, "intel") != 0))
+  {
+    delete m_pGLContext;
+    m_pGLContext = new CGLContextEGL(m_dpy);
+    ret = m_pGLContext->Refresh(force, m_nScreen, m_glWindow, m_newGlContext);
+  }
+  return ret;
+}
+
+#endif
diff --git a/xbmc/windowing/X11/WinSystemX11GLESContext.h b/xbmc/windowing/X11/WinSystemX11GLESContext.h
new file mode 100644
index 0000000000..e381332556
--- /dev/null
+++ b/xbmc/windowing/X11/WinSystemX11GLESContext.h
@@ -0,0 +1,62 @@
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#if defined(HAVE_X11)
+#include "WinSystemX11.h"
+#include "utils/GlobalsHandling.h"
+#include "rendering/gles/RenderSystemGLES.h"
+#include "GLContextEGL.h"
+#include "EGL/egl.h"
+
+class CWinSystemX11GLESContext : public CWinSystemX11, public CRenderSystemGLES
+{
+public:
+  CWinSystemX11GLESContext();
+  virtual ~CWinSystemX11GLESContext();
+
+  virtual bool CreateNewWindow(const std::string& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction);
+  virtual bool ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop);
+  virtual bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays);
+  virtual bool DestroyWindowSystem();
+  virtual bool DestroyWindow();
+
+  virtual bool IsExtSupported(const char* extension);
+
+  EGLDisplay GetEGLDisplay() const { return  m_pGLContext->m_eglDisplay; }
+  EGLSurface GetEGLSurface() const { return  m_pGLContext->m_eglSurface; }
+  EGLContext GetEGLContext() const { return  m_pGLContext->m_eglContext; }
+  EGLConfig GetEGLConfig() const { return  m_pGLContext->m_eglConfig; }
+
+protected:
+  virtual bool SetWindow(int width, int height, bool fullscreen, const std::string &output, int *winstate = NULL);
+  virtual bool PresentRenderImpl(const CDirtyRegionList& dirty);
+  virtual void SetVSyncImpl(bool enable);
+  virtual bool RefreshGLContext(bool force);
+  virtual XVisualInfo* GetVisual();
+
+  CGLContextEGL *m_pGLContext;
+  bool m_newGlContext;
+};
+
+#define g_Windowing XBMC_GLOBAL_USE(CWinSystemX11GLESContext)
+
+#endif

From 0f5a90c4e3c9bf33a1b42b462f7545ddd4123b37 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Wed, 22 Jul 2015 19:37:11 +0200
Subject: [PATCH 06/41] dvdplayer: fix dropped frame counter - it counted not
 all drops

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 8 +++++---
 xbmc/cores/dvdplayer/DVDPlayerVideo.h   | 1 -
 2 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index b5dfcac795..fc6d5369aa 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -769,7 +769,11 @@ void CDVDPlayerVideo::Process()
           break;
 
         // update dropping stats
-        CalcDropRequirement(pts, true);
+        int ret = CalcDropRequirement(pts, true);
+        if (ret & EOS_DROPPED)
+        {
+          m_iDroppedFrames++;
+        }
 
         // the decoder didn't need more data, flush the remaning buffer
         iDecoderState = m_pVideoCodec->Decode(NULL, 0, DVD_NOPTS_VALUE, DVD_NOPTS_VALUE);
@@ -1390,7 +1394,6 @@ int CDVDPlayerVideo::CalcDropRequirement(double pts, bool updateOnly)
     m_droppingStats.m_dropRequests = 0;
     m_droppingStats.m_lateFrames = 0;
   }
-  m_droppingStats.m_lastRenderPts = iRenderPts;
   return result;
 }
 
@@ -1399,7 +1402,6 @@ void CDroppingStats::Reset()
   m_gain.clear();
   m_totalGain = 0;
   m_lastDecoderPts = 0;
-  m_lastRenderPts = 0;
   m_lateFrames = 0;
   m_dropRequests = 0;
 }
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.h b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
index 947ac04a93..c5c4a56230 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
@@ -49,7 +49,6 @@ public:
   std::deque<CGain> m_gain;
   double m_totalGain;
   double m_lastDecoderPts;
-  double m_lastRenderPts;
   double m_lastPts;
   unsigned int m_lateFrames;
   unsigned int m_dropRequests;

From b9430eee57c739fc894f64c6959efdd5f51b21e9 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 17 Jul 2015 08:04:47 +0200
Subject: [PATCH 07/41] renderer: fix forced deinterlacing for non-render
 methods

---
 xbmc/cores/VideoRenderers/RenderManager.cpp | 21 ++++++++++++---------
 1 file changed, 12 insertions(+), 9 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 13150323f2..9e7c678df0 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -862,17 +862,20 @@ void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0L
         else if (interlacemethod == VS_INTERLACEMETHOD_IMX_FASTMOTION_DOUBLE)   presentmethod = PRESENT_METHOD_BOB;
         else                                                                    presentmethod = PRESENT_METHOD_SINGLE;
 
-        /* default to odd field if we want to deinterlace and don't know better */
-        if (deinterlacemode == VS_DEINTERLACEMODE_FORCE && sync == FS_NONE)
-          sync = FS_TOP;
-
-        /* invert present field */
-        if(invert)
+        if (presentmethod != PRESENT_METHOD_SINGLE)
         {
-          if( sync == FS_BOT )
+          /* default to odd field if we want to deinterlace and don't know better */
+          if (deinterlacemode == VS_DEINTERLACEMODE_FORCE && sync == FS_NONE)
             sync = FS_TOP;
-          else
-            sync = FS_BOT;
+
+          /* invert present field */
+          if (invert)
+          {
+            if (sync == FS_BOT)
+              sync = FS_TOP;
+            else
+              sync = FS_BOT;
+          }
         }
       }
     }

From 159dd635ad38d8e1bce612f3cfda0ee214460422 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Wed, 19 Aug 2015 13:28:31 +0200
Subject: [PATCH 08/41] make video renderer non-global

---
 xbmc/Application.cpp                       | 13 ++++++-------
 xbmc/guilib/GUIVideoControl.cpp            |  3 ---
 xbmc/video/windows/GUIWindowFullScreen.cpp | 13 -------------
 3 files changed, 6 insertions(+), 23 deletions(-)
 mode change 100755 => 100644 xbmc/Application.cpp

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
old mode 100755
new mode 100644
index 55267edbd9..df8bb832df
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -2353,6 +2353,8 @@ void CApplication::Render()
   // render video layer
   g_windowManager.RenderEx();
 
+  g_renderManager.FrameFinish();
+
   g_Windowing.EndRender();
 
   // reset our info cache - we do this at the end of Render so that it is
@@ -2396,9 +2398,6 @@ void CApplication::Render()
 
   m_lastFrameTime = XbmcThreads::SystemClockMillis();
   CTimeUtils::UpdateFrameTime(flip, vsync);
-
-  g_renderManager.UpdateResolution();
-  g_renderManager.ManageCaptures();
 }
 
 void CApplication::SetStandAlone(bool value)
@@ -3037,13 +3036,13 @@ void CApplication::FrameMove(bool processEvents, bool processGUI)
     {
       if (!m_skipGuiRender)
         g_windowManager.Process(CTimeUtils::GetFrameTime());
-#if defined(TARGET_RASPBERRY_PI) || defined(HAS_IMXVPU)
-      else if (!g_graphicsContext.IsFullScreenVideo())
-        g_renderManager.FrameMove();
-#endif
     }
     g_windowManager.FrameMove();
   }
+
+  g_renderManager.FrameMove();
+  g_renderManager.UpdateResolution();
+  g_renderManager.ManageCaptures();
 }
 
 bool CApplication::ProcessGamepad(float frameTime)
diff --git a/xbmc/guilib/GUIVideoControl.cpp b/xbmc/guilib/GUIVideoControl.cpp
index 1cb593b5ef..68e24db87a 100644
--- a/xbmc/guilib/GUIVideoControl.cpp
+++ b/xbmc/guilib/GUIVideoControl.cpp
@@ -38,8 +38,6 @@ CGUIVideoControl::~CGUIVideoControl(void)
 
 void CGUIVideoControl::Process(unsigned int currentTime, CDirtyRegionList &dirtyregions)
 {
-  g_renderManager.FrameMove();
-
   // TODO Proper processing which marks when its actually changed. Just mark always for now.
   if (g_renderManager.IsGuiLayer())
     MarkDirtyRegion();
@@ -101,7 +99,6 @@ void CGUIVideoControl::RenderEx()
 #ifdef HAS_VIDEO_PLAYBACK
   if (g_application.m_pPlayer->IsPlayingVideo() && g_renderManager.IsConfigured())
     g_renderManager.Render(false, 0, 255, false);
-  g_renderManager.FrameFinish();
 #endif
   CGUIControl::RenderEx();
 }
diff --git a/xbmc/video/windows/GUIWindowFullScreen.cpp b/xbmc/video/windows/GUIWindowFullScreen.cpp
index c55a19e660..e013a8456c 100644
--- a/xbmc/video/windows/GUIWindowFullScreen.cpp
+++ b/xbmc/video/windows/GUIWindowFullScreen.cpp
@@ -439,10 +439,6 @@ bool CGUIWindowFullScreen::OnMessage(CGUIMessage& message)
       // switch resolution
       g_graphicsContext.SetFullScreenVideo(true);
 
-#ifdef HAS_VIDEO_PLAYBACK
-      // make sure renderer is uptospeed
-      g_renderManager.Update();
-#endif
       // now call the base class to load our windows
       CGUIWindow::OnMessage(message);
 
@@ -467,12 +463,6 @@ bool CGUIWindowFullScreen::OnMessage(CGUIMessage& message)
       g_graphicsContext.SetFullScreenVideo(false);
       lock.Leave();
 
-#ifdef HAS_VIDEO_PLAYBACK
-      // make sure renderer is uptospeed
-      g_renderManager.Update();
-      g_renderManager.FrameFinish();
-#endif
-
       /* PLEX */
       deleteOverlays();
       /* END PLEX */
@@ -760,8 +750,6 @@ void CGUIWindowFullScreen::FrameMove()
     SET_CONTROL_HIDDEN(BLUE_BAR);
     SET_CONTROL_HIDDEN(CONTROL_GROUP_CHOOSER);
   }
-
-  g_renderManager.FrameMove();
 }
 
 void CGUIWindowFullScreen::Process(unsigned int currentTime, CDirtyRegionList &dirtyregion)
@@ -790,7 +778,6 @@ void CGUIWindowFullScreen::RenderEx()
   g_graphicsContext.SetRenderingResolution(g_graphicsContext.GetVideoResolution(), false);
 #ifdef HAS_VIDEO_PLAYBACK
   g_renderManager.Render(false, 0, 255, false);
-  g_renderManager.FrameFinish();
 #endif
 }
 

From 194cb3d2d1f94313d83272fef354251ad249039d Mon Sep 17 00:00:00 2001
From: Lauri Myllari <lauri.myllari@gmail.com>
Date: Mon, 4 May 2015 22:30:47 -0700
Subject: [PATCH 09/41] gl: split output stage from yuv2rgb shader

In preparation for new features, create a separate output stage that can
be attached either to yuv2rgb or convolution filter shader. This stage
will include things like color management, RGB range conversion and
dithering.
---
 system/shaders/output.glsl                             |  6 ++++++
 system/shaders/yuv2rgb_basic.glsl                      | 18 +++++++++---------
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp          |  4 +++-
 .../VideoRenderers/VideoShaders/YUV2RGBShader.cpp      | 14 +++++++++++---
 xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h |  4 ++--
 xbmc/guilib/Shader.cpp                                 | 18 ++++++++++++++++++
 xbmc/guilib/Shader.h                                   |  5 +++--
 7 files changed, 52 insertions(+), 17 deletions(-)
 create mode 100644 system/shaders/output.glsl

diff --git a/system/shaders/output.glsl b/system/shaders/output.glsl
new file mode 100644
index 0000000000..53c89935ae
--- /dev/null
+++ b/system/shaders/output.glsl
@@ -0,0 +1,6 @@
+void main()
+{
+  vec4 rgb = process();
+
+  gl_FragColor = rgb;
+}
diff --git a/system/shaders/yuv2rgb_basic.glsl b/system/shaders/yuv2rgb_basic.glsl
index 7e97046e72..c87d257bdd 100644
--- a/system/shaders/yuv2rgb_basic.glsl
+++ b/system/shaders/yuv2rgb_basic.glsl
@@ -56,11 +56,12 @@ vec2 stretch(vec2 pos)
 #endif
 }
 
-void main()
+vec4 process()
 {
+  vec4 rgb;
 #if defined(XBMC_YV12) || defined(XBMC_NV12)
 
-  vec4 yuv, rgb;
+  vec4 yuv;
   yuv.rgba = vec4( texture2D(m_sampY, stretch(m_cordY)).r
                  , texture2D(m_sampU, stretch(m_cordU)).g
                  , texture2D(m_sampV, stretch(m_cordV)).a
@@ -68,11 +69,10 @@ void main()
 
   rgb   = m_yuvmat * yuv;
   rgb.a = gl_Color.a;
-  gl_FragColor = rgb;
 
 #elif defined(XBMC_NV12_RRG)
 
-  vec4 yuv, rgb;
+  vec4 yuv;
   yuv.rgba = vec4( texture2D(m_sampY, stretch(m_cordY)).r
                  , texture2D(m_sampU, stretch(m_cordU)).r
                  , texture2D(m_sampV, stretch(m_cordV)).g
@@ -80,7 +80,6 @@ void main()
 
   rgb   = m_yuvmat * yuv;
   rgb.a = gl_Color.a;
-  gl_FragColor = rgb;
 
 #elif defined(XBMC_YUY2) || defined(XBMC_UYVY)
 
@@ -117,10 +116,11 @@ void main()
   float outY    = mix(leftY, rightY, step(0.5, f.x));
 
   vec4  yuv     = vec4(outY, outUV, 1.0);
-  vec4  rgb     = m_yuvmat * yuv;
-
-  gl_FragColor   = rgb;
-  gl_FragColor.a = gl_Color.a;
+  rgb           = m_yuvmat * yuv;
 
+  rgb.a = gl_Color.a;
 #endif
+
+  return rgb;
 }
+
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 5d06a05a00..e3266b9356 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -824,6 +824,7 @@ void CLinuxRendererGL::UpdateVideoFilter()
         break;
       }
 
+      // TODO: switch to GL_RGBA16 or GL_RGBA16F
       if (!m_fbo.fbo.CreateAndBindToTexture(GL_TEXTURE_2D, m_sourceWidth, m_sourceHeight, GL_RGBA))
       {
         CLog::Log(LOGERROR, "GL: Error creating texture and binding to FBO");
@@ -897,7 +898,8 @@ void CLinuxRendererGL::LoadShaders(int field)
       {
         // create regular progressive scan shader
         m_pYUVShader = new YUV2RGBProgressiveShader(m_textureTarget==GL_TEXTURE_RECTANGLE_ARB, m_iFlags, m_format,
-                                                    m_nonLinStretch && m_renderQuality == RQ_SINGLEPASS);
+                                                    m_nonLinStretch && m_renderQuality == RQ_SINGLEPASS,
+                                                    m_renderQuality == RQ_SINGLEPASS);
 
         CLog::Log(LOGNOTICE, "GL: Selecting Single Pass YUV 2 RGB shader");
 
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
index f45b7583a1..8060e89628 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
@@ -166,7 +166,8 @@ static void CalculateYUVMatrixGL(GLfloat      res[4][4]
 // BaseYUV2RGBGLSLShader - base class for GLSL YUV2RGB shaders
 //////////////////////////////////////////////////////////////////////
 
-BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderFormat format, bool stretch)
+BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderFormat format, bool stretch,
+                                             bool output)
 {
   m_width      = 1;
   m_height     = 1;
@@ -203,6 +204,11 @@ BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderF
   else
     m_defines += "#define XBMC_STRETCH 0\n";
 
+  if (output)
+    m_defines += "#define XBMC_OUTPUT 1\n";
+  else
+    m_defines += "#define XBMC_OUTPUT 0\n";
+
   if (m_format == RENDER_FMT_YUV420P ||
       m_format == RENDER_FMT_YUV420P10 ||
       m_format == RENDER_FMT_YUV420P16)
@@ -309,11 +315,13 @@ BaseYUV2RGBARBShader::BaseYUV2RGBARBShader(unsigned flags, ERenderFormat format)
 // Use for weave deinterlacing / progressive
 //////////////////////////////////////////////////////////////////////
 
-YUV2RGBProgressiveShader::YUV2RGBProgressiveShader(bool rect, unsigned flags, ERenderFormat format, bool stretch)
-  : BaseYUV2RGBGLSLShader(rect, flags, format, stretch)
+YUV2RGBProgressiveShader::YUV2RGBProgressiveShader(bool rect, unsigned flags, ERenderFormat format, bool stretch,
+                                                   bool output)
+  : BaseYUV2RGBGLSLShader(rect, flags, format, stretch, output)
 {
 #ifdef HAS_GL
   PixelShader()->LoadSource("yuv2rgb_basic.glsl", m_defines);
+  PixelShader()->AppendSource("output.glsl");
 #elif HAS_GLES == 2
   PixelShader()->LoadSource("yuv2rgb_basic_gles.glsl", m_defines);
 #endif
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
index f45ae0e02a..3fd28cdd97 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
@@ -70,7 +70,7 @@ namespace Shaders {
     , public CGLSLShaderProgram
   {
   public:
-    BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderFormat format, bool stretch);
+    BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderFormat format, bool stretch, bool output=true);
    ~BaseYUV2RGBGLSLShader() {}
     virtual void SetField(int field) { m_field  = field; }
     virtual void SetWidth(int w)     { m_width  = w; }
@@ -170,7 +170,7 @@ namespace Shaders {
   class YUV2RGBProgressiveShader : public BaseYUV2RGBGLSLShader
   {
   public:
-    YUV2RGBProgressiveShader(bool rect=false, unsigned flags=0, ERenderFormat format=RENDER_FMT_NONE, bool stretch = false);
+    YUV2RGBProgressiveShader(bool rect=false, unsigned flags=0, ERenderFormat format=RENDER_FMT_NONE, bool stretch = false, bool output=true);
   };
 
   class YUV2RGBBobShader : public BaseYUV2RGBGLSLShader
diff --git a/xbmc/guilib/Shader.cpp b/xbmc/guilib/Shader.cpp
index fbcaab2270..98162d7cf6 100644
--- a/xbmc/guilib/Shader.cpp
+++ b/xbmc/guilib/Shader.cpp
@@ -58,6 +58,24 @@ bool CShader::LoadSource(const string& filename, const string& prefix)
   return true;
 }
 
+bool CShader::AppendSource(const std::string& filename)
+{
+  if(filename.empty())
+    return true;
+
+  CFileStream file;
+  std::string temp;
+
+  if(!file.Open("special://xbmc/system/shaders/" + filename))
+  {
+    CLog::Log(LOGERROR, "CShader::AppendSource - failed to open file %s", filename.c_str());
+    return false;
+  }
+  getline(file, temp, '\0');
+  m_source.append(temp);
+  return true;
+}
+
 //////////////////////////////////////////////////////////////////////
 // CGLSLVertexShader
 //////////////////////////////////////////////////////////////////////
diff --git a/xbmc/guilib/Shader.h b/xbmc/guilib/Shader.h
index 852500e73e..7a323e1912 100644
--- a/xbmc/guilib/Shader.h
+++ b/xbmc/guilib/Shader.h
@@ -44,8 +44,9 @@ namespace Shaders {
     virtual bool Compile() = 0;
     virtual void Free() = 0;
     virtual GLuint Handle() = 0;
-    virtual void SetSource(const string& src) { m_source = src; }
-    virtual bool LoadSource(const string& filename, const string& prefix = "");
+    virtual void SetSource(const std::string& src) { m_source = src; }
+    virtual bool LoadSource(const std::string& filename, const std::string& prefix = "");
+    virtual bool AppendSource(const std::string& filename);
     bool OK() const { return m_compiled; }
 
   protected:

From 6ce57781b88bc8e6344d49463c6f3d32d9594def Mon Sep 17 00:00:00 2001
From: Lauri Myllari <lauri.myllari@gmail.com>
Date: Mon, 4 May 2015 22:46:56 -0700
Subject: [PATCH 10/41] gl: split output stage from convolution shaders

---
 system/shaders/convolution-4x4.glsl                          | 8 +++++---
 system/shaders/convolution-6x6.glsl                          | 8 +++++---
 xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp | 8 +++++++-
 xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h   | 2 +-
 4 files changed, 18 insertions(+), 8 deletions(-)

diff --git a/system/shaders/convolution-4x4.glsl b/system/shaders/convolution-4x4.glsl
index e7f0dd624f..8699bcffa3 100644
--- a/system/shaders/convolution-4x4.glsl
+++ b/system/shaders/convolution-4x4.glsl
@@ -82,8 +82,9 @@ half3 line (float ypos, vec4 xpos, half4 linetaps)
     pixel(xpos.a, ypos) * linetaps.a;
 }
 
-void main()
+vec4 process()
 {
+  vec4 rgb;
   vec2 pos = stretch(cord) + stepxy * 0.5;
   vec2 f = fract(pos / stepxy);
 
@@ -97,12 +98,13 @@ void main()
   vec2 xystart = (-1.5 - f) * stepxy + pos;
   vec4 xpos = vec4(xystart.x, xystart.x + stepxy.x, xystart.x + stepxy.x * 2.0, xystart.x + stepxy.x * 3.0);
 
-  gl_FragColor.rgb =
+  rgb.rgb =
     line(xystart.y                 , xpos, linetaps) * columntaps.r +
     line(xystart.y + stepxy.y      , xpos, linetaps) * columntaps.g +
     line(xystart.y + stepxy.y * 2.0, xpos, linetaps) * columntaps.b +
     line(xystart.y + stepxy.y * 3.0, xpos, linetaps) * columntaps.a;
 
-  gl_FragColor.a = gl_Color.a;
+  rgb.a = gl_Color.a;
+  return rgb;
 }
 
diff --git a/system/shaders/convolution-6x6.glsl b/system/shaders/convolution-6x6.glsl
index 196c5ee0bf..8e5e255884 100644
--- a/system/shaders/convolution-6x6.glsl
+++ b/system/shaders/convolution-6x6.glsl
@@ -84,8 +84,9 @@ half3 line (float ypos, vec3 xpos1, vec3 xpos2, half3 linetaps1, half3 linetaps2
     pixel(xpos2.b, ypos) * linetaps2.b; 
 }
 
-void main()
+vec4 process()
 {
+  vec4 rgb;
   vec2 pos = stretch(cord) + stepxy * 0.5;
   vec2 f = fract(pos / stepxy);
 
@@ -106,7 +107,7 @@ void main()
   vec3 xpos1 = vec3(xystart.x, xystart.x + stepxy.x, xystart.x + stepxy.x * 2.0);
   vec3 xpos2 = vec3(xystart.x + stepxy.x * 3.0, xystart.x + stepxy.x * 4.0, xystart.x + stepxy.x * 5.0);
 
-  gl_FragColor.rgb =
+  rgb =
    line(xystart.y                 , xpos1, xpos2, linetaps1, linetaps2) * columntaps1.r +
    line(xystart.y + stepxy.y      , xpos1, xpos2, linetaps1, linetaps2) * columntaps2.r +
    line(xystart.y + stepxy.y * 2.0, xpos1, xpos2, linetaps1, linetaps2) * columntaps1.g +
@@ -114,6 +115,7 @@ void main()
    line(xystart.y + stepxy.y * 4.0, xpos1, xpos2, linetaps1, linetaps2) * columntaps1.b +
    line(xystart.y + stepxy.y * 5.0, xpos1, xpos2, linetaps1, linetaps2) * columntaps2.b;
 
-  gl_FragColor.a = gl_Color.a;
+  rgb.a = gl_Color.a;
+  return rgb;
 }
 
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
index dcfd146f1c..9638525c7a 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
@@ -76,7 +76,7 @@ BaseVideoFilterShader::BaseVideoFilterShader()
   PixelShader()->SetSource(shaderp);
 }
 
-ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool stretch)
+ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool stretch, bool output)
 {
   m_method = method;
   m_kernelTex1 = 0;
@@ -126,6 +126,11 @@ ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool str
   else
     defines += "#define XBMC_STRETCH 0\n";
 
+  if (output)
+    defines += "#define XBMC_OUTPUT 1\n";
+  else
+    defines += "#define XBMC_OUTPUT 0\n";
+
   //tell shader if we're using a 1D texture
 #ifdef USE1DTEXTURE
   defines += "#define USE1DTEXTURE 1\n";
@@ -135,6 +140,7 @@ ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool str
 
   CLog::Log(LOGDEBUG, "GL: ConvolutionFilterShader: using %s defines:\n%s", shadername.c_str(), defines.c_str());
   PixelShader()->LoadSource(shadername, defines);
+  PixelShader()->AppendSource("output.glsl");
 }
 
 void ConvolutionFilterShader::OnCompiledAndLinked()
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h
index f451115298..0634a139e6 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h
+++ b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h
@@ -60,7 +60,7 @@ namespace Shaders {
   class ConvolutionFilterShader : public BaseVideoFilterShader
   {
   public:
-    ConvolutionFilterShader(ESCALINGMETHOD method, bool stretch);
+    ConvolutionFilterShader(ESCALINGMETHOD method, bool stretch, bool output=true);
     void OnCompiledAndLinked();
     bool OnEnabled();
     void Free();

From 761391459ddfe32a8266f0aba403e397ff03b4c6 Mon Sep 17 00:00:00 2001
From: Lauri Myllari <lauri.myllari@gmail.com>
Date: Sun, 10 May 2015 21:29:28 -0700
Subject: [PATCH 11/41] gl: GLSLOutput helper with dithering

Implement a GLSLOutput class that can be passed to shaders to implement
an output stage with RGB range conversion and dithering. Add support for
GLSLOutput in YUV2RGBShader and ConvolutionFilterShader.

Single pass rendering to full range is not optimal as the range
conversion could be done in colorspace conversion matrix. Keeping video
levels avoids banding in multipass rendering though.
---
 system/shaders/output.glsl                         |  22 +++-
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp      |   8 +-
 .../VideoRenderers/VideoShaders/GLSLOutput.cpp     | 146 +++++++++++++++++++++
 .../cores/VideoRenderers/VideoShaders/GLSLOutput.h |  63 +++++++++
 xbmc/cores/VideoRenderers/VideoShaders/Makefile    |   2 +-
 .../VideoShaders/VideoFilterShader.cpp             |  25 +++-
 .../VideoShaders/VideoFilterShader.h               |   7 +-
 .../VideoRenderers/VideoShaders/YUV2RGBShader.cpp  |  46 +++++--
 .../VideoRenderers/VideoShaders/YUV2RGBShader.h    |  16 ++-
 xbmc/cores/VideoRenderers/VideoShaders/dither.h    |  72 ++++++++++
 10 files changed, 379 insertions(+), 28 deletions(-)
 create mode 100644 xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
 create mode 100644 xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
 create mode 100644 xbmc/cores/VideoRenderers/VideoShaders/dither.h

diff --git a/system/shaders/output.glsl b/system/shaders/output.glsl
index 53c89935ae..83f77b04c0 100644
--- a/system/shaders/output.glsl
+++ b/system/shaders/output.glsl
@@ -1,6 +1,24 @@
+#if (XBMC_DITHER)
+uniform sampler2D m_dither;
+uniform float     m_ditherquant;
+uniform vec2      m_dithersize;
+#endif
+
 void main()
 {
-  vec4 rgb = process();
+  vec4 rgb        = process();
+
+#if (XBMC_FULLRANGE)
+  rgb             = clamp((rgb-(16.0/255.0)) * 255.0/219.0, 0, 1);
+#endif
+
+#if (XBMC_DITHER)
+  vec2 ditherpos  = gl_FragCoord.xy / m_dithersize;
+  // ditherval is multiplied by 65536/(dither_size^2) to make it [0,1[
+  // FIXME: scale dither values before uploading?
+  float ditherval = texture2D(m_dither, ditherpos).r * 16.0;
+  rgb             = floor(rgb * m_ditherquant + ditherval) / m_ditherquant;
+#endif
 
-  gl_FragColor = rgb;
+  gl_FragColor    = rgb;
 }
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index e3266b9356..207743b9ea 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -747,6 +747,8 @@ void CLinuxRendererGL::UpdateVideoFilter()
 
   if (m_scalingMethodGui == g_settings.m_currentVideoSettings.m_ScalingMethod && !nonLinStretchChanged)
     return;
+  else
+    m_reloadShaders = 1;
 
   //recompile YUV shader when non-linear stretch is turned on/off
   //or when it's on and the scaling method changed
@@ -824,7 +826,6 @@ void CLinuxRendererGL::UpdateVideoFilter()
         break;
       }
 
-      // TODO: switch to GL_RGBA16 or GL_RGBA16F
       if (!m_fbo.fbo.CreateAndBindToTexture(GL_TEXTURE_2D, m_sourceWidth, m_sourceHeight, GL_RGBA))
       {
         CLog::Log(LOGERROR, "GL: Error creating texture and binding to FBO");
@@ -832,7 +833,7 @@ void CLinuxRendererGL::UpdateVideoFilter()
       }
     }
 
-    m_pVideoFilterShader = new ConvolutionFilterShader(m_scalingMethod, m_nonLinStretch);
+    m_pVideoFilterShader = new ConvolutionFilterShader(m_scalingMethod, m_nonLinStretch, new GLSLOutput(3));
     if (!m_pVideoFilterShader->CompileAndLink())
     {
       CLog::Log(LOGERROR, "GL: Error compiling and linking video filter shader");
@@ -897,9 +898,10 @@ void CLinuxRendererGL::LoadShaders(int field)
       if (glCreateProgram && tryGlsl)
       {
         // create regular progressive scan shader
+        // if single pass, create GLSLOutput helper and pass it to YUV2RGB shader
         m_pYUVShader = new YUV2RGBProgressiveShader(m_textureTarget==GL_TEXTURE_RECTANGLE_ARB, m_iFlags, m_format,
                                                     m_nonLinStretch && m_renderQuality == RQ_SINGLEPASS,
-                                                    m_renderQuality == RQ_SINGLEPASS);
+                                                    (m_renderQuality == RQ_SINGLEPASS) ? new GLSLOutput(3) : NULL);
 
         CLog::Log(LOGNOTICE, "GL: Selecting Single Pass YUV 2 RGB shader");
 
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
new file mode 100644
index 0000000000..0bda799ba3
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
@@ -0,0 +1,146 @@
+/*
+ *      Copyright (c) 2007 d4rk
+ *      Copyright (C) 2007-2013 Team XBMC
+ *      Copyright (C) 2015 Lauri Myllri
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system_gl.h"
+#include "windowing/WindowingFactory.h"
+#include "utils/log.h"
+
+#include "GLSLOutput.h"
+#include "dither.h"
+
+using namespace Shaders;
+
+GLSLOutput::GLSLOutput(int texunit)
+{
+  // set member variable initial values
+  m_1stTexUnit = texunit;
+  m_uDither = m_1stTexUnit+0;
+
+  //   textures
+  m_tDitherTex  = 0;
+
+  //   shader attribute handles
+  m_hDither      = -1;
+  m_hDitherQuant = -1;
+  m_hDitherSize  = -1;
+
+  m_dither = true; // hardcode dithering for now
+  m_fullRange = !g_Windowing.UseLimitedColor();
+}
+
+std::string GLSLOutput::GetDefines()
+{
+  std::string defines = "#define XBMC_OUTPUT 1\n";
+  if (m_dither) defines += "#define XBMC_DITHER 1\n";
+  if (m_fullRange) defines += "#define XBMC_FULLRANGE 1\n";
+  return defines;
+}
+
+void GLSLOutput::OnCompiledAndLinked(GLuint programHandle)
+{
+  FreeTextures();
+
+  // get uniform locations
+  //   dithering
+  if (m_dither) {
+    m_hDither      = glGetUniformLocation(programHandle, "m_dither");
+    m_hDitherQuant = glGetUniformLocation(programHandle, "m_ditherquant");
+    m_hDitherSize  = glGetUniformLocation(programHandle, "m_dithersize");
+  }
+
+  if (m_dither) {
+    // TODO: create a dither pattern
+
+    // create a dither texture
+    glGenTextures(1, &m_tDitherTex);
+    if ( m_tDitherTex <= 0 )
+    {
+      CLog::Log(LOGERROR, "Error creating dither texture");
+      return;
+    }
+    // bind and set texture parameters
+    glActiveTexture(GL_TEXTURE0 + m_uDither);
+    glBindTexture(GL_TEXTURE_2D, m_tDitherTex);
+    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+
+    // load dither texture data
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_R16, dither_size, dither_size, 0, GL_RED, GL_UNSIGNED_SHORT, dither_matrix);
+  }
+
+  glActiveTexture(GL_TEXTURE0);
+
+  VerifyGLState();
+}
+
+bool GLSLOutput::OnEnabled()
+{
+
+  if (m_dither) {
+    // set texture units
+    glUniform1i(m_hDither, m_uDither);
+    VerifyGLState();
+
+    // bind textures
+    glActiveTexture(GL_TEXTURE0 + m_uDither);
+    glBindTexture(GL_TEXTURE_2D, m_tDitherTex);
+    glActiveTexture(GL_TEXTURE0);
+    VerifyGLState();
+
+    // dither settings
+    glUniform1f(m_hDitherQuant, 255.0); // (1<<depth)-1
+    VerifyGLState();
+    glUniform2f(m_hDitherSize, dither_size, dither_size);
+    VerifyGLState();
+  }
+
+  VerifyGLState();
+  return true;
+}
+
+void GLSLOutput::OnDisabled()
+{
+  // disable textures
+  glActiveTexture(GL_TEXTURE0 + m_uDither);
+  glDisable(GL_TEXTURE_2D);
+  glActiveTexture(GL_TEXTURE0);
+  VerifyGLState();
+}
+
+void GLSLOutput::Free()
+{
+  FreeTextures();
+}
+
+void GLSLOutput::FreeTextures()
+{
+  if (m_tDitherTex)
+  {
+    glDeleteTextures(1, &m_tDitherTex);
+    m_tDitherTex = 0;
+  }
+}
+
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
new file mode 100644
index 0000000000..a4dba4f9ce
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
@@ -0,0 +1,63 @@
+#ifndef __GLSLOUTPUT_H__
+#define __GLSLOUTPUT_H__
+
+/*
+ *      Copyright (C) 2007-2013 Team XBMC
+ *      Copyright (C) 2015 Lauri Myllri
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#include "utils/GLUtils.h"
+
+namespace Shaders {
+
+  class GLSLOutput
+  {
+  public:
+    // take the 1st available texture unit as a parameter
+    GLSLOutput(int texunit);
+    std::string GetDefines();
+    void OnCompiledAndLinked(GLuint programHandle);
+    bool OnEnabled();
+    void OnDisabled();
+    void Free();
+
+  private:
+    void FreeTextures();
+
+    bool m_dither;
+    bool m_fullRange;
+    // first texture unit available to us
+    int m_1stTexUnit;
+    int m_uDither;
+
+    // defines
+
+    // attribute locations
+    GLint m_hDither;
+    GLint m_hDitherQuant;
+    GLint m_hDitherSize;
+
+    // textures
+    GLuint m_tDitherTex;
+
+
+  };
+}
+#endif // __GLSLOUTPUT_H__
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/Makefile b/xbmc/cores/VideoRenderers/VideoShaders/Makefile
index 402963f29a..6897a40bea 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/Makefile
+++ b/xbmc/cores/VideoRenderers/VideoShaders/Makefile
@@ -1,4 +1,4 @@
-SRCS=YUV2RGBShader.cpp VideoFilterShader.cpp ConvolutionKernels.cpp
+SRCS=YUV2RGBShader.cpp VideoFilterShader.cpp ConvolutionKernels.cpp GLSLOutput.cpp
 
 LIB=VideoShaders.a
 
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
index 9638525c7a..d193126de1 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.cpp
@@ -76,7 +76,7 @@ BaseVideoFilterShader::BaseVideoFilterShader()
   PixelShader()->SetSource(shaderp);
 }
 
-ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool stretch, bool output)
+ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool stretch, GLSLOutput *output)
 {
   m_method = method;
   m_kernelTex1 = 0;
@@ -126,10 +126,11 @@ ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool str
   else
     defines += "#define XBMC_STRETCH 0\n";
 
-  if (output)
-    defines += "#define XBMC_OUTPUT 1\n";
-  else
-    defines += "#define XBMC_OUTPUT 0\n";
+  // get defines from the output stage if used
+  m_glslOutput = output;
+  if (m_glslOutput) {
+    defines += m_glslOutput->GetDefines();
+  }
 
   //tell shader if we're using a 1D texture
 #ifdef USE1DTEXTURE
@@ -143,6 +144,11 @@ ConvolutionFilterShader::ConvolutionFilterShader(ESCALINGMETHOD method, bool str
   PixelShader()->AppendSource("output.glsl");
 }
 
+ConvolutionFilterShader::~ConvolutionFilterShader()
+{
+  delete m_glslOutput;
+}
+
 void ConvolutionFilterShader::OnCompiledAndLinked()
 {
   // obtain shader attribute handles on successfull compilation
@@ -201,6 +207,8 @@ void ConvolutionFilterShader::OnCompiledAndLinked()
   glActiveTexture(GL_TEXTURE0);
 
   VerifyGLState();
+
+  if (m_glslOutput) m_glslOutput->OnCompiledAndLinked(ProgramHandle());
 }
 
 bool ConvolutionFilterShader::OnEnabled()
@@ -215,14 +223,21 @@ bool ConvolutionFilterShader::OnEnabled()
   glUniform2f(m_hStepXY, m_stepX, m_stepY);
   glUniform1f(m_hStretch, m_stretch);
   VerifyGLState();
+  if (m_glslOutput) m_glslOutput->OnEnabled();
   return true;
 }
 
+void ConvolutionFilterShader::OnDisabled()
+{
+  if (m_glslOutput) m_glslOutput->OnDisabled();
+}
+
 void ConvolutionFilterShader::Free()
 {
   if (m_kernelTex1)
     glDeleteTextures(1, &m_kernelTex1);
   m_kernelTex1 = 0;
+  if (m_glslOutput) m_glslOutput->Free();
   BaseVideoFilterShader::Free();
 }
 
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h
index 0634a139e6..570495826c 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h
+++ b/xbmc/cores/VideoRenderers/VideoShaders/VideoFilterShader.h
@@ -29,6 +29,7 @@
 
 #include "guilib/Shader.h"
 #include "settings/VideoSettings.h"
+#include "GLSLOutput.h"
 
 namespace Shaders {
 
@@ -60,9 +61,11 @@ namespace Shaders {
   class ConvolutionFilterShader : public BaseVideoFilterShader
   {
   public:
-    ConvolutionFilterShader(ESCALINGMETHOD method, bool stretch, bool output=true);
+    ConvolutionFilterShader(ESCALINGMETHOD method, bool stretch, GLSLOutput *output=NULL);
+    ~ConvolutionFilterShader();
     void OnCompiledAndLinked();
     bool OnEnabled();
+    void OnDisabled();
     void Free();
 
     virtual bool GetTextureFilter(GLint& filter) { filter = GL_NEAREST; return true; }
@@ -77,6 +80,8 @@ namespace Shaders {
     ESCALINGMETHOD m_method;
     bool           m_floattex; //if float textures are supported
     GLint          m_internalformat;
+
+    Shaders::GLSLOutput *m_glslOutput;
   };
 
   class StretchFilterShader : public BaseVideoFilterShader
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
index 8060e89628..14538b48ab 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
@@ -94,7 +94,8 @@ void CalculateYUVMatrix(TransformMatrix &matrix
                         , unsigned int  flags
                         , ERenderFormat format
                         , float         black
-                        , float         contrast)
+                        , float         contrast
+                        , bool          limited)
 {
   TransformMatrix coef;
 
@@ -107,8 +108,7 @@ void CalculateYUVMatrix(TransformMatrix &matrix
       coef.m[row][col] = conv[col][row];
   coef.identity = false;
 
-
-  if(g_Windowing.UseLimitedColor())
+  if(g_Windowing.UseLimitedColor() || limited)
   {
     matrix *= TransformMatrix::CreateTranslation(+ 16.0f / 255
                                                , + 16.0f / 255
@@ -147,10 +147,11 @@ static void CalculateYUVMatrixGL(GLfloat      res[4][4]
                                , unsigned int flags
                                , ERenderFormat format
                                , float        black
-                               , float        contrast)
+                               , float        contrast
+                               , bool         limited)
 {
   TransformMatrix matrix;
-  CalculateYUVMatrix(matrix, flags, format, black, contrast);
+  CalculateYUVMatrix(matrix, flags, format, black, contrast, limited);
 
   for(int row = 0; row < 3; row++)
     for(int col = 0; col < 4; col++)
@@ -167,7 +168,7 @@ static void CalculateYUVMatrixGL(GLfloat      res[4][4]
 //////////////////////////////////////////////////////////////////////
 
 BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderFormat format, bool stretch,
-                                             bool output)
+                                             GLSLOutput *output)
 {
   m_width      = 1;
   m_height     = 1;
@@ -204,10 +205,11 @@ BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderF
   else
     m_defines += "#define XBMC_STRETCH 0\n";
 
-  if (output)
-    m_defines += "#define XBMC_OUTPUT 1\n";
-  else
-    m_defines += "#define XBMC_OUTPUT 0\n";
+  // get defines from the output stage if used
+  m_glslOutput = output;
+  if (m_glslOutput) {
+    m_defines += m_glslOutput->GetDefines();
+  }
 
   if (m_format == RENDER_FMT_YUV420P ||
       m_format == RENDER_FMT_YUV420P10 ||
@@ -249,6 +251,11 @@ BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderF
   CLog::Log(LOGDEBUG, "GL: BaseYUV2RGBGLSLShader: defines:\n%s", m_defines.c_str());
 }
 
+BaseYUV2RGBGLSLShader::~BaseYUV2RGBGLSLShader()
+{
+  delete m_glslOutput;
+}
+
 void BaseYUV2RGBGLSLShader::OnCompiledAndLinked()
 {
 #if HAS_GLES == 2
@@ -267,6 +274,8 @@ void BaseYUV2RGBGLSLShader::OnCompiledAndLinked()
   m_hStretch = glGetUniformLocation(ProgramHandle(), "m_stretch");
   m_hStep    = glGetUniformLocation(ProgramHandle(), "m_step");
   VerifyGLState();
+
+  if (m_glslOutput) m_glslOutput->OnCompiledAndLinked(ProgramHandle());
 }
 
 bool BaseYUV2RGBGLSLShader::OnEnabled()
@@ -279,7 +288,8 @@ bool BaseYUV2RGBGLSLShader::OnEnabled()
   glUniform2f(m_hStep, 1.0 / m_width, 1.0 / m_height);
 
   GLfloat matrix[4][4];
-  CalculateYUVMatrixGL(matrix, m_flags, m_format, m_black, m_contrast);
+  // keep video levels
+  CalculateYUVMatrixGL(matrix, m_flags, m_format, m_black, m_contrast, true);
 
   glUniformMatrix4fv(m_hMatrix, 1, GL_FALSE, (GLfloat*)matrix);
 #if HAS_GLES == 2
@@ -288,9 +298,19 @@ bool BaseYUV2RGBGLSLShader::OnEnabled()
   glUniform1f(m_hAlpha, m_alpha);
 #endif
   VerifyGLState();
+  if (m_glslOutput) m_glslOutput->OnEnabled();
   return true;
 }
 
+void BaseYUV2RGBGLSLShader::OnDisabled()
+{
+  if (m_glslOutput) m_glslOutput->OnDisabled();
+}
+
+void BaseYUV2RGBGLSLShader::Free()
+{
+  if (m_glslOutput) m_glslOutput->Free();
+}
 //////////////////////////////////////////////////////////////////////
 // BaseYUV2RGBGLSLShader - base class for GLSL YUV2RGB shaders
 //////////////////////////////////////////////////////////////////////
@@ -316,7 +336,7 @@ BaseYUV2RGBARBShader::BaseYUV2RGBARBShader(unsigned flags, ERenderFormat format)
 //////////////////////////////////////////////////////////////////////
 
 YUV2RGBProgressiveShader::YUV2RGBProgressiveShader(bool rect, unsigned flags, ERenderFormat format, bool stretch,
-                                                   bool output)
+                                                   GLSLOutput *output)
   : BaseYUV2RGBGLSLShader(rect, flags, format, stretch, output)
 {
 #ifdef HAS_GL
@@ -412,7 +432,7 @@ void YUV2RGBProgressiveShaderARB::OnCompiledAndLinked()
 bool YUV2RGBProgressiveShaderARB::OnEnabled()
 {
   GLfloat matrix[4][4];
-  CalculateYUVMatrixGL(matrix, m_flags, m_format, m_black, m_contrast);
+  CalculateYUVMatrixGL(matrix, m_flags, m_format, m_black, m_contrast, false);
 
   for(int i=0;i<4;i++)
     glProgramLocalParameter4fARB(GL_FRAGMENT_PROGRAM_ARB, i
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
index 3fd28cdd97..c2c8b894c6 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
@@ -24,6 +24,8 @@
 #include "guilib/TransformMatrix.h"
 #include "cores/VideoRenderers/RenderFormats.h"
 
+#include "GLSLOutput.h"
+
 void CalculateYUVMatrix(TransformMatrix &matrix
                         , unsigned int  flags
                         , ERenderFormat format
@@ -70,8 +72,8 @@ namespace Shaders {
     , public CGLSLShaderProgram
   {
   public:
-    BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderFormat format, bool stretch, bool output=true);
-   ~BaseYUV2RGBGLSLShader() {}
+    BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderFormat format, bool stretch, GLSLOutput *output=NULL);
+   ~BaseYUV2RGBGLSLShader();
     virtual void SetField(int field) { m_field  = field; }
     virtual void SetWidth(int w)     { m_width  = w; }
     virtual void SetHeight(int h)    { m_height = h; }
@@ -92,6 +94,8 @@ namespace Shaders {
   protected:
     void OnCompiledAndLinked();
     bool OnEnabled();
+    void OnDisabled();
+    void Free();
 
     unsigned m_flags;
     ERenderFormat m_format;
@@ -105,6 +109,8 @@ namespace Shaders {
 
     std::string m_defines;
 
+    Shaders::GLSLOutput *m_glslOutput;
+
     // shader attribute handles
     GLint m_hYTex;
     GLint m_hUTex;
@@ -170,7 +176,11 @@ namespace Shaders {
   class YUV2RGBProgressiveShader : public BaseYUV2RGBGLSLShader
   {
   public:
-    YUV2RGBProgressiveShader(bool rect=false, unsigned flags=0, ERenderFormat format=RENDER_FMT_NONE, bool stretch = false, bool output=true);
+    YUV2RGBProgressiveShader(bool rect=false,
+                             unsigned flags=0,
+                             ERenderFormat format=RENDER_FMT_NONE,
+                             bool stretch = false,
+                             GLSLOutput *output=NULL);
   };
 
   class YUV2RGBBobShader : public BaseYUV2RGBGLSLShader
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/dither.h b/xbmc/cores/VideoRenderers/VideoShaders/dither.h
new file mode 100644
index 0000000000..d9a6bd736f
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/VideoShaders/dither.h
@@ -0,0 +1,72 @@
+// Generated with https://git.fruit.je/src?a=blob;f=dither/dither.c;h=913d06c11f8d7cbd24121ecd772396b7c10f4826;hb=HEAD
+
+#include <stdint.h>
+
+static const int dither_size = 64;
+static const int dither_size2 = 4096;
+static const uint16_t dither_matrix[] = {
+	   3, 2603,  743, 2361,  199, 2711,  806, 3181, 2113, 3820,  988, 3485, 1560, 2650,  327, 3063, 1660, 3340,  356, 1055, 2218, 2796, 3278,  528, 2104, 2909, 1465, 4076,  911, 3358, 1586, 3039,   41, 4038,  690, 3493,  155, 3754,  636, 3403,  271, 1355, 2973, 1816, 1287, 3908, 1095, 2549, 4086,  984, 3452,  357, 3560, 1662,   39, 1362, 2954, 1538,  552, 2823, 1871,  319, 2964,  792, 
+	3590, 1799, 4095, 1197, 3302, 2009, 3974, 1602,  475, 1433, 2801, 2059,  551, 4067, 1916,  914, 3887, 1308, 2969, 1817, 3780,  790, 1262, 1828, 3421,  802, 2454,  126, 3006, 2212,  536, 2513, 1029, 2142, 2920, 1641, 3178, 1902, 2848,  966, 2579, 3567, 2252,  142, 2798,  388, 3014, 2005,  216, 2285, 1583, 2994, 1091, 2813, 2002, 3712,  856, 4069, 2292, 1256, 3682, 2405, 1359, 3225, 
+	1046, 2855,  404, 2646, 1698,  545, 1138, 2982, 1985, 3610,  133, 3256, 1794,  971, 3167, 2251,  483, 2613,  668, 3468,   75, 3156, 2398, 3838,  201, 2690, 1060, 3599, 1820, 1168, 3890, 1743, 3564, 1487,  372, 2617, 1078,  462, 2193, 3915, 1659,  567, 1123, 3806, 1897, 3623,  849, 1483, 3513, 2857,  777, 2164, 3993,  584, 3338,  461, 2748, 1806,  206, 3264,  729, 1993, 3925,  492, 
+	2269, 1508, 3497,  927, 3743, 2109, 3469,  248, 2697, 1041, 2404, 1260, 3741, 2162,   52, 3526, 1214, 3722, 2085, 1449, 2557, 1938,  442, 1418, 2987, 1612, 3232, 2139,  654, 2884,  245, 2754,  621, 3060, 3858, 1341, 3698, 2948, 1436,   64, 3194, 2025, 3092, 1506,  595, 2216, 3252, 2632,  484, 1239, 3625,  122, 1864, 2589, 1475, 2360, 1195, 3588, 2536, 1010, 2890,  110, 2628, 1735, 
+	3110,  217, 1939, 2913,  101, 2483, 1274, 3124, 1636, 3791,  810, 3049,  417, 2828, 1416, 2515, 1992,  219, 3088,  844, 3343, 1171, 3632, 2201,  637, 3939,  354, 1330, 3800, 1943, 3284, 1390, 2347,  947, 2047,  200, 2128,  739, 3511, 2707, 1177, 4051,  336, 2501, 3472, 1316,   17, 2087, 3801, 1892, 2466, 1409, 3241, 1031, 3844,  152, 3123,  631, 1485, 3835, 1664, 3396, 1181, 3569, 
+	 890, 3790, 2353, 1098, 3229,  820, 3910,  448, 2319,  579, 2618, 1903, 3502,  873, 3988,  585, 3015, 1639, 2261, 4055,  292, 2809,  894, 3168, 1959,  995, 2627, 3128, 2282,  506, 1050, 3986,  125, 3537, 2804, 1533, 3291, 2523, 1860,  539, 2328,  829, 2866, 1965,  941, 2718, 4021, 1444,  877, 3210,  695, 3755,  391, 2980,  839, 3378, 1739, 2217, 3031,  351, 2334,  760, 2468,  413, 
+	2833, 1382,  553, 4013, 1886, 2660, 1512, 2092, 3541, 1391, 3950,  202, 1543, 2705, 1734, 3312,  990, 3765,  607, 1317, 2458, 1813, 3906,  134, 2390, 3415, 1671,   38, 1218, 3668, 2535, 1552, 2657, 1883,  518, 4094, 1028,  304, 3884, 1303, 3557, 1680, 3406,  203, 3717, 1854,  422, 2304, 2944,  249, 2651, 1757, 2297, 1576, 2706, 2014,  524, 3970, 1139, 2063, 3639, 1417, 4053, 1763, 
+	2150, 3450, 2616, 1247,  334, 3355,  650, 2955,   20, 3187,  885, 2178, 3352,  507, 2351,  162, 2735, 1492, 3254, 2030, 3544,  565, 1575, 2921, 1376,  547, 4037, 2017, 3337, 1730,  287, 3247,  660, 3048, 1201, 2383, 1935, 3138, 1594, 2902,  132, 2758, 1358, 2279,  763, 3203, 1574, 3527, 1157, 3938,  958, 3383, 1130, 4012,  234, 3545, 1335, 2558,   27, 3206,  651, 2949,  209, 3170, 
+	 977,   50, 1647, 3087, 2189, 1733, 3768, 1331, 2012, 2470, 1484, 2999,  979, 3863, 1288, 3603, 2147,  447, 2876,    6, 1122, 2673, 3368,  837, 3769, 2529,  965, 2699,  575, 2914, 2149,  954, 3693, 1635, 3441,   11, 3725,  780, 2425,  953, 3797, 2171,  677, 3957, 2587, 1108, 2849,  656, 2129, 1650, 2881,   63, 2612,  735, 2348,  951, 3106, 1614, 3490, 1834, 1223, 2597, 1523, 2306, 
+	3851, 1983, 3714,  599, 3524,  179, 2408,  904, 4050,  688, 3427,  369, 2671, 1994, 2931,  645, 1686, 3931, 1221, 2553, 3842, 2071,  305, 2276, 1829,  221, 3227, 1452, 3552, 1096, 3956, 1472, 2438,  335, 2187, 2889, 1428, 2746,  415, 3224, 1851, 1086, 2957,  350, 1764, 3393,  116, 2516, 3662,  398, 2209, 3716, 1310, 3464, 1480, 3762,  381, 2853,  772, 2374, 3943,  487, 3542,  616, 
+	1302, 2963,  925, 2731, 1148, 2869, 1414, 3026,  310, 2740, 1744, 3699, 1573,   76, 1126, 3300, 2493,  878, 3438, 1849,  785, 1478, 3653, 2765, 1085, 3605, 2246,  383, 1878, 2479,  106, 2841,  801, 3901, 1842,  610, 3518, 1104, 3996, 2270,  549, 3492, 2105, 3640,  931, 2224, 3916, 1866,  816, 3193, 1024, 1845, 3161,  502, 2990, 1942, 2475, 1035, 3673,  243, 1977, 3097, 1679, 2121, 
+	3318,  363, 2287, 1590, 3989,  500, 3453, 1796, 3659, 1240, 2331,  834, 3115, 2537, 4070, 2050,  212, 3079, 2267,  371, 2834, 3223, 1270,  527, 3130, 2052,  938, 2757, 3775,  740, 3471, 1656, 3281, 1062, 3102, 1349, 2512, 2090,  173, 1577, 3100, 1412,   40, 1931, 3152,  520, 1253, 2906, 1467, 2366, 4081,  254, 2089, 2522, 1174,  123, 4040, 2205, 1557, 3196, 1076, 2686,  103, 3920, 
+	 850, 2585, 3651,  147, 1909, 2562,  989, 2275,  761, 3235,  186, 3852, 1212, 1888,  603, 1399, 3749, 1561,  711, 3969, 2138,  158, 1997, 4079, 1615,   65, 3913, 1778, 1301, 3072, 2083,  394, 2599, 1990,  154, 3818,  480, 3351, 1827, 3665,  853, 2734, 4066, 1128, 2538, 1619, 3257,  192, 3606,  557, 1625, 2793,  867, 3894, 1791, 3366, 1384,  472, 2779,  843, 3802, 1332, 2434, 1453, 
+	2867, 1807, 1198, 2181, 3244, 1311, 3823,   81, 2649, 1381, 2776, 2046,  449, 3574, 2161, 3237, 1067, 2118, 2996, 1700, 1044, 3696, 2654,  759, 2455, 2966,  707, 3157,  256, 2362,  920, 4058,  671, 3601, 2263, 1528, 2976,  922, 2630,  373, 2432, 1971,  580, 3385,  289, 3770, 1960, 2598,  992, 2160, 3069, 1131, 3240,  370, 2745,  899, 3036, 1863, 3575, 2268,  399, 2953,  724, 3270, 
+	 314, 3516,  658, 3795,  412, 2997,  809, 3349, 1771, 3999,  702, 3449, 1657, 2621,  280, 2795,  512, 3615,   66, 2531, 3420,  477, 1568, 3357, 1250, 2100, 3508, 1001, 2006, 3727, 1397, 2988, 1812, 1135, 2800,  812, 1922, 3587, 1395, 3935, 1167, 3055, 1554, 2231, 2858, 1203,  773, 3964, 1703, 3433,    5, 3812, 1918, 2393, 1457, 3778,  664, 2569,   53, 1468, 3387, 1727, 4077, 2222, 
+	1037, 1966, 3089, 1367, 2762, 1694, 2355, 1087, 2837,  328, 2373, 1286, 3126,  961, 3928, 1746, 2430, 1230, 3177,  857, 1435, 2888, 2198,  264, 3777,  456, 1539, 2578, 3371,  592, 2655,   36, 2173, 3345,  297, 4010, 2397,   73, 2832,  661, 3310,  168, 3830,  691, 1420, 3547, 2305,  387, 2912,  742, 2643, 1544,  614, 3619,  164, 2172, 3316, 1259, 3978, 2042,  613, 2743,  210, 1413, 
+	3680, 2637,   13, 2316,  709, 4059,  220, 3670, 1569, 3285,  903, 3786,   31, 2293, 1354, 3342,  738, 4033, 2221, 1877, 3879,  728, 3246, 1926, 1141, 2821, 4006,  156, 1193, 1907, 3231, 1507, 3753,  948, 3083, 1667,  718, 3142, 1780, 2278, 1338, 2747, 1716, 3139, 2136,   94, 3085, 1978, 1356, 3723, 1065, 2101, 3008, 1300, 2831, 1899,  455, 3113,  939, 2898, 3608, 1097, 2126, 3147, 
+	 532, 1527, 3911, 1769, 3322, 1296, 2656, 2078,  563, 2000, 2586, 1714, 2926,  782, 2677,  181, 2938, 1535,  396, 2840,  197, 2435, 1032, 3626, 2542,  653, 2235, 1800, 2875, 3872,  353, 2456,  644, 2606, 1351, 2132, 3514, 1100, 3857,  324, 3451,  796, 2526,  419, 3747, 1766,  981, 3362, 2400,  187, 2728, 4023,  416, 3499,  881, 3849, 1521, 2431, 1841,  333, 2299, 1567, 3831,  964, 
+	2402, 3411, 1068, 2543,  340, 3109,  907, 3460, 1372, 3942,  259, 3408, 1103, 3631, 1632, 3813, 1049, 2043, 3581, 1344, 3332, 1604, 2983,   21, 1663, 3305, 1272, 3664,  519, 2208, 1048, 3555, 2029, 3949,  465, 2896,  228, 2623, 1579, 2478, 1450, 4045, 1147, 3326,  909, 2573, 4003,  513, 1249, 3532, 1775,  910, 2340, 1717, 2610,  624, 3391,  194, 3912, 2704,  765, 3243,  108, 2919, 
+	1689,  291, 2959,  826, 3779, 1626, 2250,   74, 2694,  847, 3013, 1460, 2401,  382, 2864,  627, 2463, 3140,  797, 2666,  515, 3990,  824, 2156, 3846,  341, 2911,  932, 2723, 1638, 3080, 1387,  149, 1748, 3266, 1202, 3711,  942, 3248,  744, 2970,   24, 2344, 1910, 2977,  232, 2107, 2892, 1850, 3047,  343, 2037, 3402,   85, 3220, 1278, 2200, 2854,  905, 1430, 3746, 1975, 2506,  686, 
+	3997, 2247, 1255, 3484, 2152,  544, 3034, 3870, 1520, 3528, 2180,  606, 4090, 1781, 2123, 3354, 1591,   80, 3767, 1955, 1245, 2363, 1750, 3165, 1089, 2472, 1566, 3455,   83, 4085,  692, 2685, 3475, 2356,  741, 2769, 1693, 2314,  395, 3637, 2070, 1658, 3467,  481, 1407, 3660, 1531,  753, 3819, 1047, 2532, 3902, 1161, 2491, 1621, 4065,  433, 1676, 3573, 2226,  490, 1189, 3091, 1790, 
+	 944, 3309, 1920,  135, 1440, 2799, 1859, 1115, 2427,  443, 1847, 2816,  993, 3041,  238, 1199, 3981, 2254,  949, 2900, 3456,  237, 3658,  548, 1961, 3024,  708, 2313, 1976, 1178, 3301, 2084,  556, 1321, 3880, 2015,   90, 4016, 1914, 2680,  970, 3118, 1194, 3930, 2508,  937, 3282, 2439,   57, 2777, 1578,  510, 3127,  769, 2939,  957, 2041, 3238,   28, 3019, 1890, 3389,  263, 3676, 
+	2076,  474, 3067, 2450, 4043,  800, 3556,  250, 3365, 1306, 3841,  107, 3419, 1410, 3570, 2197,  499, 3093, 1831,  425, 1550, 2652,  924, 2414, 4030,  190, 3546, 1007, 3708, 2645,  290, 1607, 3728, 2591,  358, 3205, 1162, 2863, 1346,  633, 3874,  279, 2766,  766, 2082, 3025,  438, 1946, 3629,  808, 3473, 2307, 1343, 3796,  265, 2415, 3729, 1323, 2473,  793, 3836, 1350, 2782, 1070, 
+	2624, 3860,  864, 1741,  437, 3098,  985, 2607, 1934, 2933,  828, 2703, 1889,  466, 2572, 1493, 2794, 1136, 3643, 2056, 3914, 1172, 3412, 1826, 1327, 3146, 1651, 2530,  440, 1486, 3073, 2242, 1033, 1815, 2972, 1515, 3463,  489, 2469, 3347, 1454, 2311, 1726, 3197,  124, 1622, 4091, 1156, 2170, 2946, 1835,  167, 2700, 1968, 3320, 1227,  469, 3121, 1018, 2727, 1761,  428, 1969, 3265, 
+	  60, 1524, 2301, 3593, 2683, 1269, 2207, 3891,  593, 1564, 3633, 1176, 2375, 3745,  967, 3904,  752, 3313,  180, 2452,  701, 2820,   59, 2923,  467, 2163,  866, 3941, 1898, 3392,  657, 3991,    2, 3592,  831, 2378,  982, 3798, 2099,  140, 3062,  876, 3737, 1279, 3548, 2376,  725, 3344,  301, 1318, 3961, 1107, 3562,  578, 1517, 2861, 2184, 1643, 3922,  193, 3479, 2309, 4088,  840, 
+	2487, 3498, 1235,  272, 2031, 3707,   33, 1394, 3148, 2120,  225, 3290,  731, 2044, 3208,    8, 2349, 1691, 2715, 1371, 3162, 1631, 2233, 3821, 1079, 3481, 2806,  112, 2929, 1054, 2420, 1446, 2847, 1933, 3180,  223, 2736, 1879, 1211, 3582, 1773, 2441,  424, 2648,  588, 1927, 2788, 1500, 3117, 2447,  602, 2880, 2190, 1856, 4015,   96, 3628,  604, 1913, 2882, 1319,  628, 1466, 3027, 
+	1688,  564, 2732, 3236,  715, 1613, 3306, 2273,  430, 3980, 2548, 1627, 2865,  348, 1722, 2958, 1309, 3690,  860, 4072,  397, 3561,  634, 1438, 2674, 1870,  663, 2377, 1295, 3825,  274, 3487, 1173,  550, 2169, 4060,  756, 3263,  367, 2611,  623, 4032, 2067, 3356, 1064, 3885,  178, 3645,  818, 1809, 3377, 1456,  375, 3137,  859, 2682, 1073, 3400, 2437,  913, 3242, 2604, 3638,  325, 
+	2206, 3898, 1982, 1084, 4018, 2521, 1020, 2856, 1832, 1234,  886, 3480, 1277, 4046, 2215, 1045, 3428,  283, 3021, 2027, 1284, 2642, 1912, 3262,  257, 3917, 1601, 3595, 2065,  716, 3212, 1633, 2687, 3703, 1021, 1674, 3029, 1378, 3896, 1609, 3018, 1365,   43, 1708, 2829, 1553, 2514, 1266, 2300, 3829,   14, 2525, 3720, 1292, 2380, 1718, 3050, 1464,  303, 3994, 2055,  114, 1923, 1142, 
+	3184, 1353,  145, 3001, 2102,  313, 3517,  679, 3685, 2016, 2915,   95, 2459,  641, 3163,  454, 2600, 1767, 2277,  586, 3444,  163, 3764,  962, 2429, 1140, 3191,  320, 2981, 1753, 2564,  845, 2054,  307, 3304, 2232,   79, 2659,  827, 2294, 1026, 3489, 2560, 3804,  361, 3287,  687, 3053,  408, 1375, 2985, 1774,  778, 3272,  262, 3900,  517, 2103, 3151,  726, 1565, 3759, 2502, 3520, 
+	 784, 2324, 3740, 1758,  955, 3131, 1546, 2413,  195, 3211,  786, 3757, 1785, 3535, 1434, 2049, 3882, 1124, 3735, 1459, 2554, 2079, 1505, 3040,  751, 2752, 1419, 2329,  972, 3736,  131, 3104, 3973, 1290, 2770,  672, 3448, 1762, 3694,  231, 3222,  521, 1963,  855, 2326, 1160, 3979, 1697, 3509, 2066,  617, 4052, 2290, 1600, 2810, 1158, 2570, 3549,  998, 2288, 2993, 1237,  503, 1777, 
+	2860,  414, 2726,  570, 3649, 2256,  841, 3862, 1322, 2561, 1652, 2280, 1069, 2583,  170, 2886,  673, 2443,   68, 3334,  734, 3953,  364, 2214, 3677,   32, 4063,  573, 3279, 1469, 2407, 1911,  511, 2343, 1504, 3807, 1053, 2381, 1297, 2785, 1653, 2417, 3646, 1445, 3169, 1996,  113, 2771,  999, 2546, 3253, 1188,  153, 3641,  591, 3414, 1900,   46, 1782, 3814,  240, 2196, 3417,  969, 
+	4047, 2114, 1481, 3381, 1952,   87, 2952, 2053, 3360,  589, 4022,  337, 3380,  833, 3960, 1603, 3293,  963, 3046, 1981, 2802,  991, 3174, 1824, 1164, 3132, 1620, 2676, 2081,  378, 3883, 1094, 2960, 3580,  174, 2034, 2878,  379, 3315,  612, 3983, 1238,  160, 2842,  562, 3404, 2399,  798, 3731,  269, 1562, 2907, 1973, 2631, 1403, 2320,  926, 3683, 2764, 1133, 3195, 1443, 2667, 1872, 
+	   0, 3099, 1027, 2462, 1191, 3982, 1617,  365, 1118, 3077, 1389, 2713, 1811, 2995, 2127,  482, 2011, 3598, 1655,  470, 1369, 3565, 2332,  649, 2850, 1930,  794, 3572, 1120, 3394,  887, 2609, 1587,  733, 1846, 3228,  836, 3888, 2010, 2688,  945, 2956, 2143, 1677, 3704, 1282, 1855, 2968, 1431, 2308, 3919,  453, 3386,  720, 3972,  345, 3221, 2001,  431, 2426,  667, 3893,  377, 3617, 
+	2039,  746, 3832,  296, 3286,  615, 2357, 3613, 1940, 2262,   37, 3578,  568, 1326, 3721, 1153, 2789,  270, 2541, 4035, 2203,  146, 1534, 3375,  306, 3871, 2186,  214, 2556, 1893, 3071,   56, 3350, 2074, 4089, 1186, 2626, 1491,   19, 1713, 3470,  390, 3803,  722, 2566,  299, 4075,  497, 3437, 1102, 1802, 2580, 1144, 1862, 2852, 1580, 2485, 1271, 4073, 1729, 2870, 1222, 2339,  872, 
+	3297, 2551, 1294, 2897, 1737, 2719, 1313, 3042,  771, 3810, 1490, 2411, 1949, 2664,  130, 3116, 1494, 3787, 1246,  598, 3260, 1848, 3773, 1112, 2480,  946, 2941, 1532, 4009,  611, 1682, 3824, 1226, 2729,  285, 3028,  534, 3531, 2509, 3150, 1265, 2385, 1405, 3329, 1768, 3108, 1190, 1987, 2724,   54, 3577,  842, 3808, 2219,  119, 3751,  700, 2986,  884, 3482,  100, 3215, 1408, 2759, 
+	1593,  478, 3558, 2062,  817, 3734,  207, 1797, 2581,  468, 3158,  815, 3945,  980, 3486, 2259,  770, 1788, 3185, 2370, 1030, 2903,  748, 2708, 1805, 3602,  530, 3218, 1248, 2238, 2894,  486, 2396,  851, 3622, 1666, 2354, 1137, 1947,  712, 4031,  902, 3009,   78, 2317,  803, 3533, 2486,  879, 3143, 2115, 3017,  317, 3209, 1244, 2058, 3407,  253, 2266, 1526, 2517,  767, 3657,  196, 
+	4011, 1861, 2346,  109, 3086, 1011, 2112, 4061, 1229, 3447, 1683, 2767,  282, 2891, 1843,  494, 3372, 2639,   16, 1951, 3705,  312, 2068, 4002,   70, 1455, 2756, 2003,  157, 3454, 1117, 3687, 1366, 3207, 2144,  674, 3869,  182, 3671, 2188,  277, 2684, 1598, 3881, 1061, 2822,  198, 1616, 3760, 1393,  569, 1673, 2712, 1522, 3591,  861, 2575, 1752, 3288, 1025, 3948, 1814, 2134, 3038, 
+	 933, 3239, 1213, 3897, 1582, 2423, 3182,  626, 2681,  136, 2327, 1127, 3612, 2179, 1182, 4093, 2095,  935, 3895,  697, 2528, 1597, 3033, 1152, 2359, 3325, 1016, 3799, 1756, 2593,  342, 2008, 2817,  121, 1497, 3280, 1760, 2786, 1285, 3084, 1732, 3597,  576, 1917, 3426, 1357, 3940, 2091,  376, 3335, 2013, 3877,  819, 2440,  401, 3070, 1345, 3866,  541, 2797,  288, 3333,  574, 1529, 
+	2457,  405, 2846,  659, 3395,  346, 1184, 3483, 1595, 3853,  901, 3275, 1755,  680, 3056,  229, 1581, 2975, 1348, 3330, 1233, 3609,  485, 3435,  705, 2048,  322, 2461,  736, 3944, 1545, 3341,  936, 4017, 2614,  402, 2428,  776, 3348,  488, 2584, 1228, 2158, 3061,  318, 2391,  632, 3022, 2453, 1043, 2778,  141, 2961, 1175, 4044, 1919,   25, 2159, 3145, 1624, 2336, 1225, 2629, 3840, 
+	1106, 3501, 2148, 1479, 2641, 1830, 2922, 1998,  504, 2096, 3005,  432, 2488, 3826, 1402, 2448, 3692,  366, 2225, 2772,  175, 2140, 2826, 1334, 2608, 3739, 1571, 3495, 2108, 1232, 2678,  559, 2325, 1905, 1145, 3503, 1360, 3955, 2124,  994, 3855,  151, 3370, 1013, 2737, 1709, 3630, 1462,  783, 4020, 1801, 1307, 3689, 2274,  629, 2670, 3538,  787, 1289, 3585,  917, 3742, 1684,   51, 
+	3002, 1712,  218, 3642,  749, 3954,   26, 3600, 1000, 2721, 1361, 3656, 1210,   58, 3153,  640, 1974, 3213,  898, 1819, 4026,  928, 1779, 3839,  139, 1056, 2989,  525, 3234,   10, 3553, 1648, 3792,  258, 3101,  699, 2838,   49, 1474, 2945, 1772, 2412, 1547, 4062,  822, 3245,    7, 2035, 3135,  298, 3384, 2192,  498, 1838, 3364, 1038, 1556, 3023, 2444,  177, 2716,  501, 2905, 2061, 
+	 883, 4084, 2602, 1200, 2386, 1392, 2812, 2248, 1728, 4027,  242, 1875, 2873, 2166, 1644, 3554, 1080, 2524, 3772,  505, 2369, 3160,  434, 2286, 3192, 1882, 2392, 1363, 2720, 1970, 1003, 2918,  895, 2763, 2106, 3730, 1585, 2379, 3589,  418, 3259,  669, 2773,  352, 2291, 1092, 2691, 3724, 1170, 2661,  952, 2862, 1518, 3043,  222, 2518, 3905,  360, 1692, 4019, 1936, 3432,  973, 3258, 
+	2245,  555, 1925, 3074,  444, 3319, 1066,  392, 3204,  813, 2358, 3461,  865, 3976,  458, 2644, 1839,  127, 1514, 2917, 1163, 2028, 3519, 1220,  642, 4068,  278, 3604,  605, 3975, 2503,  406, 3359, 1793, 1264,  471, 3328, 1059, 1921, 2672, 1254, 3794, 1364, 3621, 1789, 3488, 1563,  652, 2337, 1695, 3822,   82, 3465, 1231, 3672, 2045,  940, 2223, 3120,  685, 1320, 2367, 1784,  326, 
+	3766, 1519, 3424,  923, 3706, 1867, 2155, 3783, 1451, 2937, 1608,  543, 2596, 1477, 3336,  960, 3899, 2032, 3425,  863, 3661,   44, 1589, 2893, 2135, 1511, 3064, 1759, 2310, 1293, 1833, 3761, 2227,  102, 4078, 2033, 2702,  239, 3984,  732, 2228,   98, 2992,  713, 2590,  233, 2433, 3992,  384, 2965,  755, 2477, 1881,  681, 2775,  529, 1804, 3373, 1155, 2550, 3793,  148, 3507, 2693, 
+	1057, 2924,   93, 2714, 1588,  204, 2971,  694, 2544,  104, 3892, 1958, 3250,  189, 2130, 3003,  355, 3122,  648, 2582, 1740, 2213, 3932,  331, 3331,  891, 2533,  781, 3176,  185, 3004,  721, 1180, 3125, 2333,  908, 1654, 3096, 1421, 3431, 2825, 1736, 2125, 3339, 1423, 3058,  805, 1932, 3226, 1386, 3571, 1105, 4092, 2167, 1548, 3771, 2899,   69, 3607,  464, 1724, 3045, 1204, 1964, 
+	2389,  706, 3971, 1132, 2449, 3859, 1166, 3369, 1280, 3476,  930, 2422, 1268, 3718,  745, 1705, 2717, 1379, 2271, 3847,  450, 2814, 1022, 2692, 1315, 3647,   89, 3845, 1052, 3536, 1584, 2157, 3652, 1510,  682, 2868, 3624,  538, 2489, 1006,  362, 3876, 1051,  435, 3774, 1146, 3543, 1005, 2237,  191, 2023, 2636,  410, 3200,  183, 2321,  889, 2133, 1488, 2874, 2234,  643, 4041,  389, 
+	3594, 1642, 2094, 3295,  523, 2040, 2675,  359, 2295, 1853, 3051,  316, 2824, 1002, 2500, 4071, 1114, 3529,  211, 1304, 3075, 1441, 3382,  693, 2387, 1665, 2901, 1263, 2445, 1915,  581, 3308,  329, 2481, 3834,  188, 2165, 1217, 3750, 1876, 3283, 1470, 2725, 2281, 1702, 2815,   77, 2594, 3929, 1629, 3324,  906, 2940, 1267, 3523, 1388, 4008, 2662,  762, 3702, 1063, 2749, 1525, 3159, 
+	 852, 2998,  261, 2739, 1822,  976, 3550, 1672, 4057,  554, 1374, 3828, 1894, 3202,    4, 2220,  572, 1884, 3198, 2119,  723, 3618,  176, 2036, 3968,  427, 2183, 3401,  368, 4036, 2871, 1324, 2709, 1880, 1072, 3149, 1723, 2811,   23, 2394,  757, 2984,  159, 3966,  582, 2093, 3268, 1463,  618, 2859,  463, 3715, 1725, 2283,  655, 3068,  386, 1675, 3011,  266, 1986, 3410,   12, 2073, 
+	2474, 1216, 3732,  900, 3924, 2364,   47, 2830,  871, 2605, 3255, 2191,  597, 1610, 3443, 1406, 3655, 2555,  875, 3995, 1570, 2471, 1731, 3000,  804, 3230,  975, 1798, 2620,  897, 2211,   48, 3923,  835, 3446, 2257,  583, 3311, 1549, 4054, 2098, 1273, 3405, 1967, 1340, 3663,  862, 2007, 3748, 1219, 1924, 2416,   30, 3861, 1165, 2467, 1929, 3379, 1121, 3952, 2567,  915, 1787, 3909, 
+	 509, 3442, 1501, 2563,  457, 1559, 3353, 1352, 3654, 2060,  150, 1125, 3579, 2574, 1039, 2962,  323, 1628, 3010,   88, 2753,  535, 3713, 1040, 2663, 1891, 3811,  213, 3616, 1429, 3439, 1715, 2117, 2932,  380, 1385, 3889, 1110, 2592,  608, 3094,  411, 2547,  807, 3119,  338, 2315, 3037,  224, 3398, 2710, 1017, 3103, 1516, 3292,  236, 3744,  719, 2382, 1555,  537, 3522, 2647, 1305, 
+	2774, 2024,  128, 3190, 1945, 2947,  646, 2510,  421, 1236, 3936, 2698, 1792,  284, 3756,  832, 2322, 3867, 1090, 2241, 3323, 1333, 2137, 3141,   22, 1299, 2803, 2080,  768, 2835,  452, 3066,  639, 1243, 3679, 2635, 2019,  321, 3627, 1312, 1989, 3726, 1489, 3551, 2122, 1605, 4064, 1081, 1770, 2204,  666, 3998, 1858,  540, 2111, 2668, 1427, 2936,   97, 3129, 1895, 2210,  241, 3719, 
+	1009, 3307, 1810,  934, 3634, 1119, 3959, 1719, 3445, 2916, 1599,  533, 3179, 2365, 1447, 2844, 1953,  526, 3430, 1887,  789, 3815,  347, 1513, 4082, 2460,  542, 3172, 1670, 2260, 3987, 1368, 3510, 2240, 1808,  115, 3035, 1618, 2146, 3361,  184, 2335,  662, 2783,   42, 2925,  596, 2571, 3596,  956, 2877,  295, 2552, 3494,  987, 3926,  893, 1840, 3667, 1241, 3856, 1083, 3216,  727, 
+	2342,  409, 4080, 2436,  300, 2741, 2185,  171, 2026,  683, 2230, 3738, 1339,  747, 4005,  138, 3219, 1502, 2565,  255, 3076, 1699, 2368, 3418,  638, 1747, 3500, 1113, 3763,  120, 1023, 2689,  252, 2792,  774, 4025, 1008, 3217,  791, 2665, 1150, 4004, 1837,  997, 3850, 1437, 3413, 1984,  129, 3171, 1606, 3688, 1206, 2244, 1803,  429, 3112, 2418,  811, 2696,  344, 2496, 1749, 2967, 
+	1377, 2839, 1099, 2077, 3271,  838, 1442, 3583, 2679, 1034, 3054,   62, 2069, 3267, 1852, 2519, 1205, 3695,  869, 4024, 2176, 1101, 2974,  918, 2151, 2843,  267, 2406, 1496, 2951, 2174, 1690, 3817, 1143, 3299, 1979, 2495,  476, 3868, 1498, 2979,  493, 3134, 2490, 1937,  445, 2350,  854, 3946, 1169, 2341,  775, 3007,   84, 2805, 3563, 2097,  215, 3294, 1640, 3477,  870, 4014,   71, 
+	3678, 1711, 3504,  670, 1623, 3864, 2883,  546, 1645, 4034, 1396, 3457, 2634,  473, 1015, 3559,  423, 2202, 2887, 1611,  558, 3374,  137, 1896, 3644, 1075, 3937,  825, 3458,  460, 3691,  590, 2075, 3081,  439, 1337, 3440, 1742, 2318,   67, 1954, 3491, 1401,  230, 3648, 2751, 1328, 3012, 1687, 2658,  374, 3314, 1704, 4074, 1448,  620, 1329, 3958, 1999,  560, 2088, 2791, 1257, 2284, 
+	 821, 2492,  227, 3057, 2540,   29, 1258, 2239, 3016,  273, 2424,  635, 1251, 3684, 2255, 1681, 3105, 1432,   45, 3506, 2619, 1261, 3886, 2484,  436, 3107, 1701, 2625, 1380, 2352, 1551, 3199,  929, 2410, 1865, 3781,  246, 2942, 1185, 3681, 2588,  912, 2264, 3269, 1208,  714, 3752,  268, 3466,  730, 3837, 1242, 2722,  919, 2372, 3416, 2615,  880, 2851, 1476, 3788,  286, 3289, 1668, 
+	3399, 1314, 3921, 1795, 1036, 3478, 1948, 3697,  921, 3397, 1707, 3878, 2004, 2943,  166, 2733,  814, 3918, 2086,  978, 1957, 3155,  622, 1461, 2750, 2064,   61, 3346,  676, 3032,  205, 1821, 3977,    1, 2819,  892, 2442,  754, 3233,  566, 1537, 3963,  678, 1696, 2895, 1904, 2465, 1458, 2131, 2904, 1776, 2298,  226, 3710, 1988,  308, 1630, 3636,   34, 3095, 1116, 2464,  703, 2638, 
+	 385, 2781,  600, 2323, 3175,  764, 2808,  403, 1825, 2695, 1082, 2845,  339, 1499, 4087, 1179, 3376,  459, 2827, 3758,  294, 2345, 1818, 3409,  959, 3784, 1276, 1857, 4042, 1149, 3534, 2520, 1209, 3363, 1422, 3525, 1634, 4083, 2194, 1823, 3082,  293, 2633, 3530,   99, 3927,  531, 3114, 1058,    9, 3620,  874, 3277,  684, 3052, 1215, 3188, 1908, 2265,  758, 3434, 1885, 3967,  968, 
+	3701, 2022, 3459, 1503,  332, 4001, 1473, 2168, 3833,  117, 2338,  779, 3173, 2153,  609, 2576, 1637, 2409,  846, 1542, 3321, 1077, 4056,  169, 2978,  561, 3214, 2253,  400, 2807, 1928,  495, 2991,  689, 2177,  420, 2885, 1088,  172, 2761, 1281, 3422, 1991, 1109, 2388,  943, 3317, 1669, 4029, 2653, 1398, 2497, 1540, 2818, 1836, 3865,  522,  983, 4049, 2601, 1536,  165, 2182, 3164, 
+	1572,   92, 1183, 2927, 1873, 2451, 1093, 3201,  888, 3044, 1439, 3789, 1151, 3512, 1783, 3650,  251, 3274, 1868, 2669,  710, 2872, 1370, 2446, 2038, 1646, 2577, 1012, 3635, 2145,  974, 3805, 2272, 1738, 3933, 2527, 1342, 3303, 1944, 3843,  514, 2296,  788, 3709, 1592, 2780, 2020,  281, 2249,  665, 3462,  315, 3985, 1074,  111, 2534, 2018, 2930, 1411,  441, 3576, 2836, 1347,  508, 
+	2744, 2243, 3951,  696, 3666,  161, 3521,  516, 2494, 1962, 3436,  491, 2476,   15, 2760,  868, 2258, 1291, 3875,   91, 3700, 2141,  393, 3611,  750, 3903,  275, 3296, 1596,  105, 3144, 1541,  260, 3183, 1042,  118, 3686,  594, 2384,  996, 3539, 1710, 3133,  235, 3030,  587, 3785, 1154, 3020, 1941, 1196, 3154, 1720, 2236, 3474, 1325, 3614,  247, 3249, 1844, 2229, 1014, 3776, 1869, 
+	3515,  986, 1956, 2545, 1336, 3078, 2051, 1649, 4048,  309, 1192, 2787, 1721, 3388, 1426, 3965, 2928,  496, 2175, 3111, 1019, 1745, 3065, 1482, 3186, 1252, 2879,  698, 2507, 3947,  896, 2742, 3586, 1400, 2110, 2934, 1706, 2738, 1383, 2950,   35, 2482, 1425, 4039, 1187, 2505, 1509, 3390,  479, 3873, 2395,  848, 2768,  407, 2910,  619, 1754, 2755, 1207, 3816,  717, 3059,  276, 2498, 
+	 647, 2908,  311, 3166,  571, 2303,  916, 2935, 1283, 3276, 1874, 3907,  823, 2302,  577, 1995, 1129, 3566, 1415,  601, 2539, 3540,  858, 2595,   18, 2330, 1751, 3505, 1111, 1906, 2403,  625, 2199,  446, 3782,  799, 3367,  349, 4007,  830, 3251, 1071, 2730,  426, 1972, 3568,   72, 2154, 2790, 1404,  144, 3674, 1471, 3854, 1004, 2072, 3934,  882, 2419,   86, 2640, 1685, 3298, 1530, 
+	3848, 1373, 3429, 1661, 3809, 1424, 3584,   55, 2622,  675, 2421,  208, 3090, 1224, 3675, 2504,  143, 2057, 2701, 4028, 1558,  244, 1980, 3962, 1159, 3669,  451, 2021, 2784,  302, 3733, 1298, 3261, 1786, 2568, 1275, 2289, 1495, 2499, 1765, 2116, 3827,  704, 3423, 2371,  795, 3189, 1678,  630, 3136, 1901, 2559,  737, 2195, 3273, 2511,  330, 3327, 1950, 3496,  950, 4000, 1134, 2312, 
+};

From 1421935d4ca5fc18e082d4acdc57c65056400115 Mon Sep 17 00:00:00 2001
From: Lauri Myllari <lauri.myllari@gmail.com>
Date: Fri, 26 Jun 2015 22:21:58 -0700
Subject: [PATCH 12/41] gl: disable dither texture after rendering only when
 dithering is used

---
 xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
index 0bda799ba3..5bcb326298 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
@@ -124,8 +124,10 @@ bool GLSLOutput::OnEnabled()
 void GLSLOutput::OnDisabled()
 {
   // disable textures
-  glActiveTexture(GL_TEXTURE0 + m_uDither);
-  glDisable(GL_TEXTURE_2D);
+  if (m_dither) {
+    glActiveTexture(GL_TEXTURE0 + m_uDither);
+    glDisable(GL_TEXTURE_2D);
+  }
   glActiveTexture(GL_TEXTURE0);
   VerifyGLState();
 }

From d269a27af94b52dbd789e69b51b650d3e9e324d4 Mon Sep 17 00:00:00 2001
From: Lauri Myllari <lauri.myllari@gmail.com>
Date: Sun, 17 May 2015 21:50:21 -0700
Subject: [PATCH 13/41] settings: add video dither

---
 language/English/strings.po                           | 10 ++++++++++
 plex/Owned/GUISettings.cpp                            |  4 ++++
 xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp |  5 +++--
 xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h   |  1 +
 xbmc/windowing/WinSystem.cpp                          | 18 ++++++++++++++++++
 xbmc/windowing/WinSystem.h                            |  3 +++
 6 files changed, 39 insertions(+), 2 deletions(-)

diff --git a/language/English/strings.po b/language/English/strings.po
index 97dc4d858c..03244a5c76 100644
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -11570,6 +11570,16 @@ msgstr ""
 
 #empty strings from id 36047 to 36098
 
+#: system/settings/settings.xml
+msgctxt "#36099"
+msgid "Dithering"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#36100"
+msgid "Dither depth"
+msgstr ""
+
 msgctxt "#36434"
 msgid "Allow hardware acceleration - MMAL"
 msgstr ""
diff --git a/plex/Owned/GUISettings.cpp b/plex/Owned/GUISettings.cpp
index 55a4234b82..34c9506b06 100644
--- a/plex/Owned/GUISettings.cpp
+++ b/plex/Owned/GUISettings.cpp
@@ -640,6 +640,10 @@ void CGUISettings::Initialize()
 #else
   AddBool(NULL, "videoscreen.limitedrange", 36042, false);
 #endif
+#if defined(HAS_GL)
+  AddBool(advs, "videoscreen.dither", 36099, true);
+  AddInt(advs, "videoscreen.ditherdepth", 36100, 8, 2, 1, 8, SPIN_CONTROL_INT);
+#endif
 #if defined(HAS_LCD)
   AddBool(advs, "videoscreen.haslcd", 4501, false);
 #endif
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
index 5bcb326298..6ec66d3962 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
@@ -43,7 +43,8 @@ GLSLOutput::GLSLOutput(int texunit)
   m_hDitherQuant = -1;
   m_hDitherSize  = -1;
 
-  m_dither = true; // hardcode dithering for now
+  m_dither = g_Windowing.UseDithering();
+  m_ditherDepth = g_Windowing.DitherDepth();
   m_fullRange = !g_Windowing.UseLimitedColor();
 }
 
@@ -111,7 +112,7 @@ bool GLSLOutput::OnEnabled()
     VerifyGLState();
 
     // dither settings
-    glUniform1f(m_hDitherQuant, 255.0); // (1<<depth)-1
+    glUniform1f(m_hDitherQuant, (1<<m_ditherDepth)-1.0);
     VerifyGLState();
     glUniform2f(m_hDitherSize, dither_size, dither_size);
     VerifyGLState();
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
index a4dba4f9ce..4119923d9c 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
@@ -42,6 +42,7 @@ namespace Shaders {
     void FreeTextures();
 
     bool m_dither;
+    unsigned m_ditherDepth;
     bool m_fullRange;
     // first texture unit available to us
     int m_1stTexUnit;
diff --git a/xbmc/windowing/WinSystem.cpp b/xbmc/windowing/WinSystem.cpp
index 984be52712..12f41ad6c4 100644
--- a/xbmc/windowing/WinSystem.cpp
+++ b/xbmc/windowing/WinSystem.cpp
@@ -259,6 +259,24 @@ bool CWinSystemBase::UseLimitedColor()
 #endif
 }
 
+bool CWinSystemBase::UseDithering()
+{
+#if defined(HAS_GL)
+  return g_guiSettings.GetBool("videoscreen.dither");
+#else
+  return false;
+#endif
+}
+
+unsigned CWinSystemBase::DitherDepth()
+{
+#if defined(HAS_GL)
+  return g_guiSettings.GetInt("videoscreen.ditherdepth");
+#else
+  return 8;
+#endif
+}
+
 std::string CWinSystemBase::GetClipboardText(void)
 {
   return "";
diff --git a/xbmc/windowing/WinSystem.h b/xbmc/windowing/WinSystem.h
index 2d0165152d..8b682f8de4 100644
--- a/xbmc/windowing/WinSystem.h
+++ b/xbmc/windowing/WinSystem.h
@@ -77,6 +77,9 @@ public:
   //does the output expect limited color range (ie 16-235)
   virtual bool UseLimitedColor();
 
+  virtual bool UseDithering();
+  virtual unsigned DitherDepth();
+
   virtual bool Minimize() { return false; }
   virtual bool Restore() { return false; }
   virtual bool Hide() { return false; }

From 797165be24a79c88b5ace30125df462755e23376 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 26 Jul 2015 17:21:44 +0200
Subject: [PATCH 14/41] renderer: fix HasFrame

---
 xbmc/cores/VideoRenderers/RenderManager.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 9e7c678df0..c63e69e873 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -426,7 +426,8 @@ void CXBMCRenderManager::FrameWait(int ms)
 bool CXBMCRenderManager::HasFrame()
 {
   CSingleLock lock(m_presentlock);
-  if (m_presentstep == PRESENT_FRAME || m_presentstep == PRESENT_FRAME2)
+  if (m_presentstep == PRESENT_READY ||
+      m_presentstep == PRESENT_FRAME || m_presentstep == PRESENT_FRAME2)
     return true;
   else
     return false;

From 254dbb165c39f086f9ef4bd1215e4c5e17f3dfc4 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 7 Sep 2015 16:03:12 +0100
Subject: [PATCH 15/41] [gles] Fix build with gles. GL_RED is not defined

---
 xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
index 6ec66d3962..2eee50f63e 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
@@ -88,8 +88,10 @@ void GLSLOutput::OnCompiledAndLinked(GLuint programHandle)
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
 
+#if HAS_GLES != 2
     // load dither texture data
     glTexImage2D(GL_TEXTURE_2D, 0, GL_R16, dither_size, dither_size, 0, GL_RED, GL_UNSIGNED_SHORT, dither_matrix);
+#endif
   }
 
   glActiveTexture(GL_TEXTURE0);

From 3fa552bd5dad493cd45210a258ce68df26dbd71c Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 7 Sep 2015 15:42:55 +0100
Subject: [PATCH 16/41] [GLES] Fix build with VideoPlayer

---
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp | 4 +---
 xbmc/cores/VideoRenderers/LinuxRendererGLES.h   | 2 +-
 2 files changed, 2 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index 97b93fa6d8..ea0206a32f 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -533,7 +533,7 @@ void CLinuxRendererGLES::FlipPage(int source)
   return;
 }
 
-unsigned int CLinuxRendererGLES::PreInit()
+void CLinuxRendererGLES::PreInit()
 {
   CSingleLock lock(g_graphicsContext);
   m_bConfigured = false;
@@ -559,8 +559,6 @@ unsigned int CLinuxRendererGLES::PreInit()
 
   // setup the background colour
   m_clearColour = (float)(g_advancedSettings.m_videoBlackBarColour & 0xff) / 0xff;
-
-  return true;
 }
 
 void CLinuxRendererGLES::UpdateVideoFilter()
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
index d778fdeab2..d21370022d 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
@@ -130,7 +130,7 @@ public:
   virtual int          GetImage(YV12Image *image, int source = AUTOSOURCE, bool readonly = false);
   virtual void         ReleaseImage(int source, bool preserve = false);
   virtual void         FlipPage(int source);
-  virtual unsigned int PreInit();
+  virtual void         PreInit();
   virtual void         UnInit();
   virtual void         Reset(); /* resets renderer after seek for example */
   virtual void         Flush();

From cd41996d4db7e6e86ab83e577e1d4f880d76b6bb Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 7 Sep 2015 15:40:53 +0100
Subject: [PATCH 17/41] [MMAL] Update to support VideoPlayer renderer

---
 xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.cpp |  7 +++----
 xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.h   | 14 +++++++-------
 xbmc/cores/VideoRenderers/RenderManager.cpp            |  2 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp     |  4 +++-
 4 files changed, 14 insertions(+), 13 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.cpp b/xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.cpp
index fd14207e69..28460eeff0 100644
--- a/xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.cpp
@@ -252,8 +252,9 @@ CMMALRenderer::~CMMALRenderer()
   UnInit();
 }
 
-void CMMALRenderer::AddProcessor(CMMALVideoBuffer *buffer, int index)
+void CMMALRenderer::AddVideoPictureHW(DVDVideoPicture& pic, int index)
 {
+  CMMALVideoBuffer *buffer = pic.MMALBuffer;
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
     CLog::Log(LOGDEBUG, "%s::%s - %p (%p) %i", CLASSNAME, __func__, buffer, buffer->mmal_buffer, index);
 
@@ -517,7 +518,7 @@ void CMMALRenderer::FlipPage(int source)
   m_iYV12RenderBuffer = source;
 }
 
-unsigned int CMMALRenderer::PreInit()
+void CMMALRenderer::PreInit()
 {
   CSingleLock lock(m_sharedSection);
   m_bConfigured = false;
@@ -539,8 +540,6 @@ unsigned int CMMALRenderer::PreInit()
   memset(m_buffers, 0, sizeof m_buffers);
   m_iYV12RenderBuffer = 0;
   m_NumYV12Buffers = NUM_BUFFERS;
-
-  return 0;
 }
 
 void CMMALRenderer::ReleaseBuffers()
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.h b/xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.h
index a71e645263..7cbe3d1c1d 100644
--- a/xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.h
+++ b/xbmc/cores/VideoRenderers/HwDecRender/MMALRenderer.h
@@ -21,14 +21,13 @@
  */
 
 #include "guilib/GraphicContext.h"
-#include "RenderFlags.h"
-#include "RenderFormats.h"
-#include "BaseRenderer.h"
-#include "RenderCapture.h"
+#include "../RenderFlags.h"
+#include "../RenderFormats.h"
+#include "../BaseRenderer.h"
+#include "../RenderCapture.h"
 #include "settings/VideoSettings.h"
 #include "cores/dvdplayer/DVDStreamInfo.h"
 #include "guilib/Geometry.h"
-#include "BaseRenderer.h"
 
 #include <interface/mmal/mmal.h>
 #include <interface/mmal/util/mmal_util.h>
@@ -77,14 +76,15 @@ public:
   virtual void         ReleaseImage(int source, bool preserve = false);
   virtual void         ReleaseBuffer(int idx);
   virtual void         FlipPage(int source);
-  virtual unsigned int PreInit();
+  virtual void         PreInit();
   virtual void         UnInit();
   virtual void         Reset(); /* resets renderer after seek for example */
   virtual void         Flush();
   virtual bool         IsConfigured() { return m_bConfigured; }
-  virtual void         AddProcessor(CMMALVideoBuffer *buffer, int index);
+  virtual void         AddVideoPictureHW(DVDVideoPicture& pic, int index);
   virtual CRenderInfo GetRenderInfo();
 
+  virtual bool         SupportsMultiPassRendering() { return false; };
   virtual bool         Supports(ERENDERFEATURE feature);
   virtual bool         Supports(EDEINTERLACEMODE mode);
   virtual bool         Supports(EINTERLACEMETHOD method);
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index c63e69e873..3be7e990b1 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -44,7 +44,7 @@
 #include "HwDecRender/RendererVDA.h"
 #endif
 #elif defined(HAS_MMAL)
-  #include "MMALRenderer.h"
+  #include "HwDecRender/MMALRenderer.h"
 #elif HAS_GLES == 2
   #include "LinuxRendererGLES.h"
 #elif defined(HAS_DX)
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
index 2c6d26dea1..c5e1518282 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
@@ -816,7 +816,9 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
        if (iSize == 0)
        {
          EDEINTERLACEMODE deinterlace_request = g_settings.m_currentVideoSettings.m_DeinterlaceMode;
-         EINTERLACEMETHOD interlace_method = g_renderManager.AutoInterlaceMethod(g_settings.m_currentVideoSettings.m_InterlaceMethod);
+         EINTERLACEMETHOD interlace_method = g_settings.m_currentVideoSettings.m_InterlaceMethod;
+         if (interlace_method == VS_INTERLACEMETHOD_AUTO)
+           interlace_method = VS_INTERLACEMETHOD_MMAL_ADVANCED;
          bool deinterlace = m_interlace_mode != MMAL_InterlaceProgressive;
 
          // we don't keep up when running at 60fps in the background so switch to half rate

From a2b813c34e246034a5d81553477c94d35856c814 Mon Sep 17 00:00:00 2001
From: Memphiz <memphis@machzwo.de>
Date: Sun, 13 Sep 2015 21:19:12 +0200
Subject: [PATCH 18/41] [shader] - fix compilation of glsl shaders for gles

---
 xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
index 2eee50f63e..d2605f5b63 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
@@ -82,7 +82,9 @@ void GLSLOutput::OnCompiledAndLinked(GLuint programHandle)
     glActiveTexture(GL_TEXTURE0 + m_uDither);
     glBindTexture(GL_TEXTURE_2D, m_tDitherTex);
     glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+#if HAS_GLES != 2
     glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
+#endif
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

From 3168cbbb9cdc82210c062d79edf39a3ccfe3bc55 Mon Sep 17 00:00:00 2001
From: Memphiz <memphis@machzwo.de>
Date: Sun, 13 Sep 2015 21:50:49 +0200
Subject: [PATCH 19/41] [shader] - use GLSLOutput object on gles platforms
 aswell

---
 xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
index 14538b48ab..4050d71624 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
@@ -188,6 +188,12 @@ BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderF
   m_hStretch = -1;
   m_hStep    = -1;
 
+  // get defines from the output stage if used
+  m_glslOutput = output;
+  if (m_glslOutput) {
+    m_defines += m_glslOutput->GetDefines();
+  }
+
 #ifdef HAS_GL
   if(rect)
     m_defines += "#define XBMC_texture_rectangle 1\n";
@@ -205,12 +211,6 @@ BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderF
   else
     m_defines += "#define XBMC_STRETCH 0\n";
 
-  // get defines from the output stage if used
-  m_glslOutput = output;
-  if (m_glslOutput) {
-    m_defines += m_glslOutput->GetDefines();
-  }
-
   if (m_format == RENDER_FMT_YUV420P ||
       m_format == RENDER_FMT_YUV420P10 ||
       m_format == RENDER_FMT_YUV420P16)

From 02a9cef6fb969d90d3c42d9518155a33c59249a7 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 17 Sep 2015 10:55:12 +0200
Subject: [PATCH 20/41] RenderManager - cleanup CreateRenderer

---
 xbmc/cores/VideoRenderers/RenderManager.cpp | 44 +++++++++++++++++++++--------
 1 file changed, 33 insertions(+), 11 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 3be7e990b1..1d20b2e372 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -43,10 +43,11 @@
 #if defined(TARGET_DARWIN_OSX)
 #include "HwDecRender/RendererVDA.h"
 #endif
-#elif defined(HAS_MMAL)
-  #include "HwDecRender/MMALRenderer.h"
 #elif HAS_GLES == 2
   #include "LinuxRendererGLES.h"
+#if defined(HAS_MMAL)
+#include "HwDecRender/MMALRenderer.h"
+#endif
 #elif defined(HAS_DX)
   #include "WinRenderer.h"
 #elif defined(HAS_SDL)
@@ -126,7 +127,7 @@ static std::string GetRenderFormatName(ERenderFormat format)
 
 CXBMCRenderManager::CXBMCRenderManager()
 {
-  m_pRenderer = NULL;
+  m_pRenderer = nullptr;
   m_renderState = STATE_UNCONFIGURED;
 
   m_presentstep = PRESENT_IDLE;
@@ -626,14 +627,6 @@ void CXBMCRenderManager::CreateRenderer()
 {
   if (!m_pRenderer)
   {
-#if defined(HAS_MMAL)
-    m_pRenderer = new CMMALRenderer();
-#elif HAS_GLES == 2
-    m_pRenderer = new CLinuxRendererGLES();
-#elif defined(HAS_DX)
-    m_pRenderer = new CWinRenderer();
-#endif
-#if defined(HAS_GL)
     if (m_format == RENDER_FMT_VAAPI || m_format == RENDER_FMT_VAAPINV12)
     {
 #if defined(HAVE_LIBVA)
@@ -652,13 +645,42 @@ void CXBMCRenderManager::CreateRenderer()
       m_pRenderer = new CRendererVDA;
 #endif
     }
+    else if (m_format == RENDER_FMT_MMAL)
+    {
+#if defined(HAS_MMAL)
+      m_pRenderer = new CMMALRenderer;
+#endif
+    }
+    else if (m_format == RENDER_FMT_OMXEGL)
+    {
+#if defined(HAVE_LIBOPENMAX)
+      m_pRenderer = new CRendererOMX;
+#endif
+    }
+    else if (m_format == RENDER_FMT_DXVA)
+    {
+#if defined(HAS_DX)
+      m_pRenderer = new CWinRenderer();
+#endif
+    }
     else if (m_format != RENDER_FMT_NONE)
     {
+#if defined(HAS_GL)
       m_pRenderer = new CLinuxRendererGL;
+#elif HAS_GLES == 2
+      m_pRenderer = new CLinuxRendererGLES;
+#elif defined(HAS_DX)
+      m_pRenderer = new CWinRenderer();
+#endif
     }
+#if defined(HAS_MMAL)
+    if (!m_pRenderer)
+      m_pRenderer = new CMMALRenderer;
 #endif
     if (m_pRenderer)
       m_pRenderer->PreInit();
+    else
+      CLog::Log(LOGERROR, "RenderManager::CreateRenderer: failed to create renderer");
   }
 }
 

From 3d5930e9eebce908b5d261ff3c34ac8b3353463d Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 5 Dec 2015 15:59:16 +0100
Subject: [PATCH 21/41] VideoPlayer: reqork dithering

---
 .../VideoRenderers/HwDecRender/RendererVDPAU.cpp   |  1 +
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp      | 12 ++++++--
 xbmc/cores/VideoRenderers/LinuxRendererGL.h        |  5 +++-
 .../VideoRenderers/VideoShaders/GLSLOutput.cpp     | 33 +++++++++++++---------
 .../cores/VideoRenderers/VideoShaders/GLSLOutput.h | 17 ++++-------
 .../VideoRenderers/VideoShaders/WinVideoFilter.cpp |  2 +-
 .../VideoRenderers/VideoShaders/YUV2RGBShader.h    | 13 ++++-----
 xbmc/windowing/WinSystem.cpp                       | 18 ------------
 xbmc/windowing/WinSystem.h                         |  3 --
 9 files changed, 46 insertions(+), 58 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp
index 799e0b45fb..61c9e548d0 100644
--- a/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp
+++ b/xbmc/cores/VideoRenderers/HwDecRender/RendererVDPAU.cpp
@@ -153,6 +153,7 @@ bool CRendererVDPAU::LoadShadersHook()
   {
     CLog::Log(LOGNOTICE, "GL: Using VDPAU render method");
     m_renderMethod = RENDER_VDPAU;
+    m_fullRange = false;
     return true;
   }
   return false;
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 207743b9ea..2e47950a87 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -134,6 +134,9 @@ CLinuxRendererGL::CLinuxRendererGL()
   m_pVideoFilterShader = NULL;
   m_scalingMethod = VS_SCALINGMETHOD_LINEAR;
   m_scalingMethodGui = (ESCALINGMETHOD)-1;
+  m_useDithering = g_guiSettings.GetBool("videoscreen.dither");
+  m_ditherDepth = g_guiSettings.GetInt("videoscreen.ditherdepth");
+  m_fullRange = !g_Windowing.UseLimitedColor();
 
   m_rgbBuffer = NULL;
   m_rgbBufferSize = 0;
@@ -833,7 +836,9 @@ void CLinuxRendererGL::UpdateVideoFilter()
       }
     }
 
-    m_pVideoFilterShader = new ConvolutionFilterShader(m_scalingMethod, m_nonLinStretch, new GLSLOutput(3));
+    GLSLOutput *out;
+    out = new GLSLOutput(3, m_useDithering, m_ditherDepth, m_fullRange);
+    m_pVideoFilterShader = new ConvolutionFilterShader(m_scalingMethod, m_nonLinStretch, out);
     if (!m_pVideoFilterShader->CompileAndLink())
     {
       CLog::Log(LOGERROR, "GL: Error compiling and linking video filter shader");
@@ -899,9 +904,12 @@ void CLinuxRendererGL::LoadShaders(int field)
       {
         // create regular progressive scan shader
         // if single pass, create GLSLOutput helper and pass it to YUV2RGB shader
+        GLSLOutput *out = nullptr;
+        if (m_renderQuality == RQ_SINGLEPASS)
+          out = new GLSLOutput(3, m_useDithering, m_ditherDepth, m_fullRange);
         m_pYUVShader = new YUV2RGBProgressiveShader(m_textureTarget==GL_TEXTURE_RECTANGLE_ARB, m_iFlags, m_format,
                                                     m_nonLinStretch && m_renderQuality == RQ_SINGLEPASS,
-                                                    (m_renderQuality == RQ_SINGLEPASS) ? new GLSLOutput(3) : NULL);
+                                                    out);
 
         CLog::Log(LOGNOTICE, "GL: Selecting Single Pass YUV 2 RGB shader");
 
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.h b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
index cf827d2b07..7d25982a05 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
@@ -259,10 +259,13 @@ protected:
 
   void GetPlaneTextureSize(YUVPLANE& plane);
 
-  Shaders::BaseYUV2RGBShader     *m_pYUVShader;
+  Shaders::BaseYUV2RGBShader *m_pYUVShader;
   Shaders::BaseVideoFilterShader *m_pVideoFilterShader;
   ESCALINGMETHOD m_scalingMethod;
   ESCALINGMETHOD m_scalingMethodGui;
+  bool m_useDithering;
+  unsigned int m_ditherDepth;
+  bool m_fullRange;
 
   // clear colour for "black" bars
   float m_clearColour;
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
index d2605f5b63..182a893e3d 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
@@ -1,6 +1,6 @@
 /*
  *      Copyright (c) 2007 d4rk
- *      Copyright (C) 2007-2013 Team XBMC
+ *      Copyright (C) 2007-2015 Team XBMC
  *      Copyright (C) 2015 Lauri Myllri
  *      http://xbmc.org
  *
@@ -21,7 +21,6 @@
  */
 
 #include "system_gl.h"
-#include "windowing/WindowingFactory.h"
 #include "utils/log.h"
 
 #include "GLSLOutput.h"
@@ -29,7 +28,7 @@
 
 using namespace Shaders;
 
-GLSLOutput::GLSLOutput(int texunit)
+GLSLOutput::GLSLOutput(int texunit, bool useDithering, unsigned int ditherDepth, bool fullrange)
 {
   // set member variable initial values
   m_1stTexUnit = texunit;
@@ -43,16 +42,18 @@ GLSLOutput::GLSLOutput(int texunit)
   m_hDitherQuant = -1;
   m_hDitherSize  = -1;
 
-  m_dither = g_Windowing.UseDithering();
-  m_ditherDepth = g_Windowing.DitherDepth();
-  m_fullRange = !g_Windowing.UseLimitedColor();
+  m_dither = useDithering;
+  m_ditherDepth = ditherDepth;
+  m_fullRange = fullrange;
 }
 
 std::string GLSLOutput::GetDefines()
 {
   std::string defines = "#define XBMC_OUTPUT 1\n";
-  if (m_dither) defines += "#define XBMC_DITHER 1\n";
-  if (m_fullRange) defines += "#define XBMC_FULLRANGE 1\n";
+  if (m_dither)
+    defines += "#define XBMC_DITHER 1\n";
+  if (m_fullRange)
+    defines += "#define XBMC_FULLRANGE 1\n";
   return defines;
 }
 
@@ -62,13 +63,15 @@ void GLSLOutput::OnCompiledAndLinked(GLuint programHandle)
 
   // get uniform locations
   //   dithering
-  if (m_dither) {
-    m_hDither      = glGetUniformLocation(programHandle, "m_dither");
+  if (m_dither)
+  {
+    m_hDither = glGetUniformLocation(programHandle, "m_dither");
     m_hDitherQuant = glGetUniformLocation(programHandle, "m_ditherquant");
-    m_hDitherSize  = glGetUniformLocation(programHandle, "m_dithersize");
+    m_hDitherSize = glGetUniformLocation(programHandle, "m_dithersize");
   }
 
-  if (m_dither) {
+  if (m_dither)
+  {
     // TODO: create a dither pattern
 
     // create a dither texture
@@ -104,7 +107,8 @@ void GLSLOutput::OnCompiledAndLinked(GLuint programHandle)
 bool GLSLOutput::OnEnabled()
 {
 
-  if (m_dither) {
+  if (m_dither)
+  {
     // set texture units
     glUniform1i(m_hDither, m_uDither);
     VerifyGLState();
@@ -129,7 +133,8 @@ bool GLSLOutput::OnEnabled()
 void GLSLOutput::OnDisabled()
 {
   // disable textures
-  if (m_dither) {
+  if (m_dither)
+  {
     glActiveTexture(GL_TEXTURE0 + m_uDither);
     glDisable(GL_TEXTURE_2D);
   }
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
index 4119923d9c..8df84fba54 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.h
@@ -1,8 +1,5 @@
-#ifndef __GLSLOUTPUT_H__
-#define __GLSLOUTPUT_H__
-
 /*
- *      Copyright (C) 2007-2013 Team XBMC
+ *      Copyright (C) 2007-2015 Team XBMC
  *      Copyright (C) 2015 Lauri Myllri
  *      http://xbmc.org
  *
@@ -21,17 +18,18 @@
  *  <http://www.gnu.org/licenses/>.
  *
  */
+#pragma once
 
 #include "system.h"
 #include "utils/GLUtils.h"
 
-namespace Shaders {
-
+namespace Shaders
+{
   class GLSLOutput
   {
   public:
     // take the 1st available texture unit as a parameter
-    GLSLOutput(int texunit);
+    GLSLOutput(int texunit, bool useDithering, unsigned int ditherDepth, bool fullrange);
     std::string GetDefines();
     void OnCompiledAndLinked(GLuint programHandle);
     bool OnEnabled();
@@ -42,7 +40,7 @@ namespace Shaders {
     void FreeTextures();
 
     bool m_dither;
-    unsigned m_ditherDepth;
+    unsigned int m_ditherDepth;
     bool m_fullRange;
     // first texture unit available to us
     int m_1stTexUnit;
@@ -57,8 +55,5 @@ namespace Shaders {
 
     // textures
     GLuint m_tDitherTex;
-
-
   };
 }
-#endif // __GLSLOUTPUT_H__
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/WinVideoFilter.cpp b/xbmc/cores/VideoRenderers/VideoShaders/WinVideoFilter.cpp
index 09821fd749..6ef93b6f04 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/WinVideoFilter.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/WinVideoFilter.cpp
@@ -68,7 +68,7 @@ D3DXMATRIX* CYUV2RGBMatrix::Matrix()
   if (m_NeedRecalc)
   {
     TransformMatrix matrix;
-    CalculateYUVMatrix(matrix, m_flags, m_format, m_blacklevel, m_contrast);
+    CalculateYUVMatrix(matrix, m_flags, m_format, m_blacklevel, m_contrast, true);
 
     m_mat._11 = matrix.m[0][0];
     m_mat._12 = matrix.m[1][0];
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
index c2c8b894c6..a4d42ad7c7 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
@@ -1,9 +1,6 @@
-#ifndef __YUV2RGB_SHADERS_H__
-#define __YUV2RGB_SHADERS_H__
-
 /*
- *      Copyright (C) 2007-2012 Team XBMC
- *      http://www.xbmc.org
+ *      Copyright (C) 2007-2015 Team XBMC
+ *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -20,6 +17,7 @@
  *  <http://www.gnu.org/licenses/>.
  *
  */
+#pragma once
 
 #include "guilib/TransformMatrix.h"
 #include "cores/VideoRenderers/RenderFormats.h"
@@ -30,7 +28,8 @@ void CalculateYUVMatrix(TransformMatrix &matrix
                         , unsigned int  flags
                         , ERenderFormat format
                         , float         black
-                        , float         contrast);
+                        , float         contrast
+                        , bool          limited);
 
 #if defined(HAS_GL) || HAS_GLES == 2
 
@@ -201,5 +200,3 @@ namespace Shaders {
 #pragma warning( pop )
 #endif
 #endif
-
-#endif //__YUV2RGB_SHADERS_H__
diff --git a/xbmc/windowing/WinSystem.cpp b/xbmc/windowing/WinSystem.cpp
index 12f41ad6c4..984be52712 100644
--- a/xbmc/windowing/WinSystem.cpp
+++ b/xbmc/windowing/WinSystem.cpp
@@ -259,24 +259,6 @@ bool CWinSystemBase::UseLimitedColor()
 #endif
 }
 
-bool CWinSystemBase::UseDithering()
-{
-#if defined(HAS_GL)
-  return g_guiSettings.GetBool("videoscreen.dither");
-#else
-  return false;
-#endif
-}
-
-unsigned CWinSystemBase::DitherDepth()
-{
-#if defined(HAS_GL)
-  return g_guiSettings.GetInt("videoscreen.ditherdepth");
-#else
-  return 8;
-#endif
-}
-
 std::string CWinSystemBase::GetClipboardText(void)
 {
   return "";
diff --git a/xbmc/windowing/WinSystem.h b/xbmc/windowing/WinSystem.h
index 8b682f8de4..2d0165152d 100644
--- a/xbmc/windowing/WinSystem.h
+++ b/xbmc/windowing/WinSystem.h
@@ -77,9 +77,6 @@ public:
   //does the output expect limited color range (ie 16-235)
   virtual bool UseLimitedColor();
 
-  virtual bool UseDithering();
-  virtual unsigned DitherDepth();
-
   virtual bool Minimize() { return false; }
   virtual bool Restore() { return false; }
   virtual bool Hide() { return false; }

From 155c5a71288200ac4e7e8384413b5e99ea569fa3 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 22 Sep 2015 10:03:01 +0200
Subject: [PATCH 22/41] set desired resolution before start of playback

---
 xbmc/cores/VideoRenderers/RenderManager.cpp | 24 +++++++++---
 xbmc/cores/VideoRenderers/RenderManager.h   |  3 +-
 xbmc/cores/dvdplayer/DVDPlayer.cpp          | 57 +++++++++++++++++++++++++++--
 xbmc/cores/dvdplayer/DVDPlayer.h            |  9 ++++-
 xbmc/guilib/DispResource.h                  |  2 -
 xbmc/guilib/GraphicContext.cpp              | 15 --------
 6 files changed, 81 insertions(+), 29 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 1d20b2e372..5ceb910cba 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -133,7 +133,7 @@ CXBMCRenderManager::CXBMCRenderManager()
   m_presentstep = PRESENT_IDLE;
   m_rendermethod = 0;
   m_presentsource = 0;
-  m_bReconfigured = false;
+  m_bTriggerUpdateResolution = false;
   m_hasCaptures = false;
   m_displayLatency = 0.0f;
   m_presentcorr = 0.0;
@@ -381,7 +381,7 @@ bool CXBMCRenderManager::Configure()
 
     m_bRenderGUI = true;
     m_waitForBufferCount = 0;
-    m_bReconfigured = true;
+    m_bTriggerUpdateResolution = true;
     m_presentstep = PRESENT_IDLE;
     m_presentpts = DVD_NOPTS_VALUE;
     m_sleeptime = 1.0;
@@ -1096,19 +1096,31 @@ void CXBMCRenderManager::UpdateDisplayLatency()
 
 void CXBMCRenderManager::UpdateResolution()
 {
-  if (m_bReconfigured)
+  if (m_bTriggerUpdateResolution)
   {
     CRetakeLock<CExclusiveLock> lock(m_sharedSection);
     if (g_graphicsContext.IsFullScreenVideo() && g_graphicsContext.IsFullScreenRoot())
     {
-      RESOLUTION res = GetResolution();
-      g_graphicsContext.SetVideoResolution(res);
+      if (g_guiSettings.GetInt("videoplayer.adjustrefreshrate") != ADJUST_REFRESHRATE_OFF && m_fps > 0.0f)
+      {
+        RESOLUTION res = GetResolution();
+        g_graphicsContext.SetVideoResolution(res);
+        UpdateDisplayLatency();
+      }
     }
-    m_bReconfigured = false;
+    m_bTriggerUpdateResolution = false;
     g_dataCacheCore.SignalVideoInfoChange();
   }
 }
 
+void CXBMCRenderManager::TriggerUpdateResolution(float fps, int width, int flags)
+{
+  m_fps = fps;
+  m_width = width;
+  m_flags = flags;
+  m_bTriggerUpdateResolution = true;
+}
+
 // Get renderer info, can be called before configure
 CRenderInfo CXBMCRenderManager::GetRenderInfo()
 {
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index 8736429d2a..5b0685afb9 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -66,6 +66,7 @@ public:
   bool IsVideoLayer();
   RESOLUTION GetResolution();
   void UpdateResolution();
+  void TriggerUpdateResolution(float fps, int width, int flags);
   void SetViewMode(int iViewMode);
   void Recover(); // called after resolution switch if something special is needed
   void PreInit();
@@ -182,7 +183,7 @@ protected:
   CBaseRenderer *m_pRenderer;
   OVERLAY::CRenderer m_overlays;
   CSharedSection m_sharedSection;
-  bool m_bReconfigured;
+  bool m_bTriggerUpdateResolution;
   bool m_bRenderGUI;
   int m_waitForBufferCount;
   int m_rendermethod;
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index e41b3ece07..881bf025d4 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -48,6 +48,7 @@
 #include "DVDDemuxers/DVDDemuxCC.h"
 #ifdef HAS_VIDEO_PLAYBACK
 #include "cores/VideoRenderers/RenderManager.h"
+#include "cores/VideoRenderers/RenderFlags.h"
 #endif
 #ifdef HAS_PERFORMANCE_SAMPLE
 #include "xbmc/utils/PerformanceSample.h"
@@ -83,6 +84,8 @@
 #include "cores/omxplayer/OMXHelper.h"
 #endif
 #include "DVDPlayerAudio.h"
+#include "windowing/WindowingFactory.h"
+#include "DVDCodecs/DVDCodecUtils.h"
 
 /* PLEX */
 #include "FileSystem/PlexDirectory.h"
@@ -534,10 +537,19 @@ CDVDPlayer::CDVDPlayer(IPlayerCallback& callback)
 #endif
 
   CreatePlayers();
+
+  m_displayLost = false;
+#ifndef HAS_DX
+  g_Windowing.Register(this);
+#endif
 }
 
 CDVDPlayer::~CDVDPlayer()
 {
+#ifndef HAS_DX
+  g_Windowing.Unregister(this);
+#endif
+
   CloseFile();
   DestroyPlayers();
 }
@@ -1253,6 +1265,17 @@ void CDVDPlayer::Process()
         m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), true, true, true, true, true));
     }
 #endif
+
+    // check display lost
+    {
+      CSingleLock lock(m_StateSection);
+      if (m_displayLost)
+      {
+        Sleep(50);
+        continue;
+      }
+    }
+
     // handle messages send to this thread, like seek or demuxer reset requests
     HandleMessages();
 
@@ -2566,7 +2589,7 @@ void CDVDPlayer::HandleMessages()
           SAFE_DELETE(m_pDemuxer);
           m_playSpeed = DVD_PLAYSPEED_NORMAL;
 #ifdef HAS_VIDEO_PLAYBACK
-          // when using fast channel switching some shortcuts are taken which 
+          // when using fast channel switching some shortcuts are taken which
           // means we'll have to update the view mode manually
           g_renderManager.SetViewMode(g_settings.m_currentVideoSettings.m_ViewMode);
 #endif
@@ -2624,7 +2647,7 @@ void CDVDPlayer::HandleMessages()
 
               g_infoManager.SetDisplayAfterSeek();
 #ifdef HAS_VIDEO_PLAYBACK
-              // when using fast channel switching some shortcuts are taken which 
+              // when using fast channel switching some shortcuts are taken which
               // means we'll have to update the view mode manually
               g_renderManager.SetViewMode(g_settings.m_currentVideoSettings.m_ViewMode);
 #endif
@@ -2848,7 +2871,7 @@ void CDVDPlayer::Seek(bool bPlus, bool bLargeStep, bool bChapterOverride)
   else
     seek = bPlus ? g_advancedSettings.m_videoTimeSeekForward : g_advancedSettings.m_videoTimeSeekBackward;
   seek *= 1000;
-  
+
   // if we are over movie length, then just move one sec before the end
   // that's the maximum seek offset DVDPlayer will take into account.
   if (seek + GetTime() > GetTotalTimeInMsec())
@@ -3517,6 +3540,17 @@ bool CDVDPlayer::OpenVideoStream(CDVDStreamInfo& hint, bool reset)
   if(hint.flags & AV_DISPOSITION_ATTACHED_PIC)
     return false;
 
+  // set desired refresh rate
+  if (m_PlayerOptions.fullscreen && g_graphicsContext.IsFullScreenRoot() &&
+      hint.fpsrate != 0 && hint.fpsscale != 0)
+  {
+    if (g_guiSettings.GetInt("videoplayer.adjustrefreshrate") != ADJUST_REFRESHRATE_OFF)
+    {
+      float framerate = DVD_TIME_BASE / CDVDCodecUtils::NormalizeFrameduration((double)DVD_TIME_BASE * hint.fpsscale / hint.fpsrate);
+      g_renderManager.TriggerUpdateResolution(framerate, hint.width, RenderManager::GetStereoModeFlags(hint.stereo_mode));
+    }
+  }
+
   if(!OpenStreamPlayer(m_CurrentVideo, hint, reset))
     return false;
 
@@ -4641,7 +4675,7 @@ bool CDVDPlayer::GetStreamDetails(CStreamDetails &details)
     bool result = CDVDFileInfo::DemuxerToStreamDetails(m_pInputStream, m_pDemuxer, details);
     if (result && details.GetStreamCount(CStreamDetail::VIDEO) > 0) // this is more correct (dvds in particular)
     {
-      /* 
+      /*
        * We can only obtain the aspect & duration from dvdplayer when the Process() thread is running
        * and UpdatePlayState() has been called at least once. In this case dvdplayer duration/AR will
        * return 0 and we'll have to fallback to the (less accurate) info from the demuxer.
@@ -4695,6 +4729,21 @@ bool CDVDPlayer::CachePVRStream(void) const
       g_advancedSettings.m_bPVRCacheInDvdPlayer;
 }
 
+// IDispResource interface
+void CDVDPlayer::OnLostDevice()
+{
+  CLog::Log(LOGNOTICE, "CDVDPlayer: OnLostDevice received");
+  CSingleLock lock(m_StateSection);
+  m_displayLost = true;
+}
+
+void CDVDPlayer::OnResetDevice()
+{
+  CLog::Log(LOGNOTICE, "CDVDPlayer: OnResetDevice received");
+  CSingleLock lock(m_StateSection);
+  m_displayLost = false;
+}
+
 /* PLEX */
 int CDVDPlayer::GetStreamPlexID(StreamType type)
 {
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.h b/xbmc/cores/dvdplayer/DVDPlayer.h
index 59650bb82a..da67d2fdb0 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.h
+++ b/xbmc/cores/dvdplayer/DVDPlayer.h
@@ -35,6 +35,7 @@
 #include "threads/SystemClock.h"
 #include "threads/Thread.h"
 #include "utils/StreamDetails.h"
+#include "guilib/DispResource.h"
 
 #ifdef HAS_OMXPLAYER
 #include "OMXCore.h"
@@ -214,7 +215,7 @@ public:
 #define DVDPLAYER_SUBTITLE 3
 #define DVDPLAYER_TELETEXT 4
 
-class CDVDPlayer : public IPlayer, public CThread, public IDVDPlayer
+class CDVDPlayer : public IPlayer, public CThread, public IDVDPlayer, public IDispResource
 {
 public:
   CDVDPlayer(IPlayerCallback& callback);
@@ -292,6 +293,10 @@ public:
   virtual bool SwitchChannel(const PVR::CPVRChannelPtr &channel);
   virtual bool CachePVRStream(void) const;
 
+  // IDispResource interface
+  virtual void OnLostDevice();
+  virtual void OnResetDevice();
+
   enum ECacheState
   { CACHESTATE_DONE = 0
   , CACHESTATE_FULL     // player is filling up the demux queue
@@ -580,6 +585,8 @@ protected:
 
   bool m_DemuxerPausePending;
 
+  bool m_displayLost;
+
   // omxplayer variables
   struct SOmxPlayerState m_OmxPlayerState;
   bool m_omxplayer_mode;            // using omxplayer acceleration
diff --git a/xbmc/guilib/DispResource.h b/xbmc/guilib/DispResource.h
index 93587484a9..a32dc24d30 100644
--- a/xbmc/guilib/DispResource.h
+++ b/xbmc/guilib/DispResource.h
@@ -20,7 +20,6 @@
 
 #pragma once
 
-#if defined(HAS_GLX) || defined(HAS_EGL) || defined(TARGET_DARWIN)
 class IDispResource
 {
 public:
@@ -29,4 +28,3 @@ public:
   virtual void OnResetDevice() {};
 };
 
-#endif
diff --git a/xbmc/guilib/GraphicContext.cpp b/xbmc/guilib/GraphicContext.cpp
index 72ac57f4fe..a7a0c44d24 100644
--- a/xbmc/guilib/GraphicContext.cpp
+++ b/xbmc/guilib/GraphicContext.cpp
@@ -392,21 +392,6 @@ void CGraphicContext::SetVideoResolutionInternal(RESOLUTION res, bool forceUpdat
     return;
   }
 
-  //only pause when switching monitor resolution/refreshrate,
-  //not when switching between fullscreen and windowed or when resizing the window
-  if ((res != RES_DESKTOP && res != RES_WINDOW) || (lastRes != RES_DESKTOP && lastRes != RES_WINDOW))
-  {
-    //pause the player during the refreshrate change
-    int delay = g_guiSettings.GetInt("videoplayer.pauseafterrefreshchange");
-    if (delay > 0 && g_guiSettings.GetInt("videoplayer.adjustrefreshrate") != ADJUST_REFRESHRATE_OFF && g_application.m_pPlayer->IsPlayingVideo() && !g_application.m_pPlayer->IsPausedPlayback())
-    {
-      g_application.m_pPlayer->Pause();
-      ThreadMessage msg = {TMSG_MEDIA_UNPAUSE};
-      CDelayedMessage* pauseMessage = new CDelayedMessage(msg, delay * 100);
-      pauseMessage->Create(true);
-    }
-  }
-
   if (res >= RES_DESKTOP)
   {
     g_advancedSettings.m_fullScreen = true;

From b4348f88e4c1457d788c8b6cd344a4550237d5c0 Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Thu, 1 Oct 2015 14:26:37 +0200
Subject: [PATCH 23/41] Advancedsettings: Remove blackbarcolour and set it
 automatically

---
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp   | 2 +-
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp | 2 +-
 xbmc/cores/VideoRenderers/WinRenderer.cpp       | 2 +-
 xbmc/settings/AdvancedSettings.cpp              | 2 --
 xbmc/settings/AdvancedSettings.h                | 1 -
 5 files changed, 3 insertions(+), 6 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 2e47950a87..7f904fc8fb 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -721,7 +721,7 @@ void CLinuxRendererGL::PreInit()
   m_formats.push_back(RENDER_FMT_UYVY422);
 
   // setup the background colour
-  m_clearColour = (float)(g_advancedSettings.m_videoBlackBarColour & 0xff) / 0xff;
+  m_clearColour = g_Windowing.UseLimitedColor() ? (16.0f / 0xff) : 0.0f;
 }
 
 void CLinuxRendererGL::UpdateVideoFilter()
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index ea0206a32f..04a22c829c 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -558,7 +558,7 @@ void CLinuxRendererGLES::PreInit()
 #endif
 
   // setup the background colour
-  m_clearColour = (float)(g_advancedSettings.m_videoBlackBarColour & 0xff) / 0xff;
+  m_clearColour = g_Windowing.UseLimitedColor() ? (16.0f / 0xff) : 0.0f;
 }
 
 void CLinuxRendererGLES::UpdateVideoFilter()
diff --git a/xbmc/cores/VideoRenderers/WinRenderer.cpp b/xbmc/cores/VideoRenderers/WinRenderer.cpp
index ea25f93d05..3222f840e8 100644
--- a/xbmc/cores/VideoRenderers/WinRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/WinRenderer.cpp
@@ -402,7 +402,7 @@ void CWinRenderer::PreInit()
     m_resolution = RES_DESKTOP;
 
   // setup the background colour
-  m_clearColour = (g_advancedSettings.m_videoBlackBarColour & 0xff) * 0x010101;
+  m_clearColour = g_Windowing.UseLimitedColor() ? (16 * 0x010101) : 0;
 
   g_Windowing.Get3DDevice()->GetDeviceCaps(&m_deviceCaps);
 
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 3122e2f8c0..009df050bf 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -93,7 +93,6 @@ void CAdvancedSettings::Initialize()
   m_videoPercentSeekForwardBig = 10;
   m_videoPercentSeekBackwardBig = -10;
 
-  m_videoBlackBarColour = 0;
   m_videoPPFFmpegDeint = "linblenddeint";
   m_videoPPFFmpegPostProc = "ha:128:7,va,dr";
   m_videoDefaultPlayer = "dvdplayer";
@@ -529,7 +528,6 @@ void CAdvancedSettings::ParseSettingsFile(const CStdString &file)
     XMLUtils::GetString(pElement, "stereoscopicregextab", m_stereoscopicregex_tab);
     XMLUtils::GetFloat(pElement, "subsdelayrange", m_videoSubsDelayRange, 10, 600);
     XMLUtils::GetFloat(pElement, "audiodelayrange", m_videoAudioDelayRange, 10, 600);
-    XMLUtils::GetInt(pElement, "blackbarcolour", m_videoBlackBarColour, 0, 255);
     XMLUtils::GetString(pElement, "defaultplayer", m_videoDefaultPlayer);
     XMLUtils::GetString(pElement, "defaultdvdplayer", m_videoDefaultDVDPlayer);
     XMLUtils::GetBoolean(pElement, "fullscreenonmoviestart", m_fullScreenOnMovieStart);
diff --git a/xbmc/settings/AdvancedSettings.h b/xbmc/settings/AdvancedSettings.h
index 91807aef6d..72b1b0b6b0 100644
--- a/xbmc/settings/AdvancedSettings.h
+++ b/xbmc/settings/AdvancedSettings.h
@@ -145,7 +145,6 @@ class CAdvancedSettings
     int m_musicPercentSeekBackward;
     int m_musicPercentSeekForwardBig;
     int m_musicPercentSeekBackwardBig;
-    int m_videoBlackBarColour;
     int m_videoIgnoreSecondsAtStart;
     float m_videoIgnorePercentAtEnd;
     float m_audioApplyDrc;

From 64a4533ed204b3134d6aec9efd49114616355573 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 2 Oct 2015 19:07:14 +0200
Subject: [PATCH 24/41] vaapi: do not disassociate egl context

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index 716ae8dd26..9a89364bb0 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -2447,7 +2447,7 @@ bool COutput::DestroyEGLContext()
   if (m_eglContext)
   {
     glFinish();
-    eglMakeCurrent(m_eglContext, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    //eglMakeCurrent(m_eglContext, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
     eglDestroyContext(m_eglDisplay, m_eglContext);
   }
   m_eglContext = EGL_NO_CONTEXT;

From d552252c92b2b2274b9ba745883e1534a7759871 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Mon, 5 Oct 2015 17:29:33 +0200
Subject: [PATCH 25/41] VideoRenderer: fix state after flush

---
 xbmc/cores/VideoRenderers/RenderManager.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 5ceb910cba..23f90910ca 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -503,7 +503,8 @@ void CXBMCRenderManager::FrameFinish()
   /* wait for this present to be valid */
   SPresent& m = m_Queue[m_presentsource];
 
-  if(g_graphicsContext.IsFullScreenVideo())
+  if(g_graphicsContext.IsFullScreenVideo() &&
+     (m_presentstep == PRESENT_FRAME || m_presentstep == PRESENT_FRAME2))
   {
     CSingleExit lock(g_graphicsContext);
     WaitPresentTime(m.timestamp);
@@ -618,6 +619,7 @@ bool CXBMCRenderManager::Flush()
   m_discard.clear();
   m_free.clear();
   m_presentsource = 0;
+  m_presentstep = PRESENT_IDLE;
   for (int i = 1; i < m_QueueSize; i++)
     m_free.push_back(i);
 

From c43e3041eca24a53f0c4cf04b645cc559556f432 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 5 Dec 2015 16:14:09 +0100
Subject: [PATCH 26/41] VideoPlayer: reslotion fixes

---
 xbmc/cores/VideoRenderers/OverlayRenderer.cpp | 4 ++--
 xbmc/cores/VideoRenderers/RenderManager.cpp   | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/OverlayRenderer.cpp b/xbmc/cores/VideoRenderers/OverlayRenderer.cpp
index 4fad83910e..f0099292dc 100644
--- a/xbmc/cores/VideoRenderers/OverlayRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/OverlayRenderer.cpp
@@ -273,7 +273,7 @@ void CRenderer::Render(COverlay* o, float adjust_height)
     {
       if(align == COverlay::ALIGN_SUBTITLE)
       {
-        RESOLUTION_INFO res = g_graphicsContext.GetResInfo(g_renderManager.GetResolution());
+        RESOLUTION_INFO res = g_graphicsContext.GetResInfo(g_graphicsContext.GetVideoResolution());
         state.x += rv.x1 + rv.Width() * 0.5f;
         state.y += rv.y1  + (res.iSubtitles - res.Overscan.top);
       }
@@ -353,7 +353,7 @@ COverlay* CRenderer::Convert(CDVDOverlaySSA* o, double pts)
   else if (subalign == SUBTITLE_ALIGN_MANUAL && g_advancedSettings.m_videoAssFixedWorks)
   {
     RESOLUTION_INFO res;
-    res = g_graphicsContext.GetResInfo(g_renderManager.GetResolution());
+    res = g_graphicsContext.GetResInfo(g_graphicsContext.GetVideoResolution());
     position = 100.0 - (res.iSubtitles - res.Overscan.top) * 100 / res.iHeight;
   }
   else
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 23f90910ca..1a5a8d67bc 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -1109,8 +1109,8 @@ void CXBMCRenderManager::UpdateResolution()
         g_graphicsContext.SetVideoResolution(res);
         UpdateDisplayLatency();
       }
+      m_bTriggerUpdateResolution = false;
     }
-    m_bTriggerUpdateResolution = false;
     g_dataCacheCore.SignalVideoInfoChange();
   }
 }

From b4794c9eb0839ed26f8f1197a11082eb8a473a5d Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 3 Oct 2015 20:12:49 +0100
Subject: [PATCH 27/41] [omxplayer] Ensure MMAL renderer is used in BYPASS mode

---
 xbmc/cores/VideoRenderers/RenderManager.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 1a5a8d67bc..f41930e5fe 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -667,7 +667,9 @@ void CXBMCRenderManager::CreateRenderer()
     }
     else if (m_format != RENDER_FMT_NONE)
     {
-#if defined(HAS_GL)
+#if defined(HAS_MMAL)
+      m_pRenderer = new CMMALRenderer;
+#elif defined(HAS_GL)
       m_pRenderer = new CLinuxRendererGL;
 #elif HAS_GLES == 2
       m_pRenderer = new CLinuxRendererGLES;

From 3eafe97708c01de54442067e268fa66a1f86848d Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Wed, 14 Oct 2015 20:15:46 +0200
Subject: [PATCH 28/41] vaapi: cope with comtinuous get_buffer errors

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp | 15 +++++++++------
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h   |  2 +-
 2 files changed, 10 insertions(+), 7 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index 9a89364bb0..a0c9fef33b 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -458,7 +458,7 @@ CDecoder::CDecoder() : m_vaapiOutput(&m_inMsgEvent)
   m_vaapiConfig.contextId = VA_INVALID_ID;
   m_vaapiConfig.configId = VA_INVALID_ID;
   m_avctx = NULL;
-  m_getBufferError = false;
+  m_getBufferError = 0;
 }
 
 CDecoder::~CDecoder()
@@ -521,6 +521,7 @@ bool CDecoder::Open(AVCodecContext* avctx, AVCodecContext* mainctx, const enum P
   m_DisplayState = VAAPI_OPEN;
   m_vaapiConfigured = false;
   m_presentPicture = 0;
+  m_getBufferError = 0;
 
   VAProfile profile;
   switch (avctx->codec_id)
@@ -709,10 +710,12 @@ int CDecoder::FFGetBuffer(AVCodecContext *avctx, AVFrame *pic, int flags)
     va->m_bufferStats.Get(decoded, processed, render, vpp);
     CLog::Log(LOGWARNING, "VAAPI::FFGetBuffer - no surface available - dec: %d, render: %d",
                          decoded, render);
-    va->m_getBufferError = true;
+    va->m_getBufferError++;
     return -1;
   }
 
+  va->m_getBufferError = 0;
+
   pic->data[1] = pic->data[2] = NULL;
   pic->data[0] = (uint8_t*)(uintptr_t)surf;
   pic->data[3] = (uint8_t*)(uintptr_t)surf;
@@ -746,8 +749,6 @@ void CDecoder::FFReleaseBuffer(uint8_t *data)
 
 int CDecoder::Decode(AVCodecContext* avctx, AVFrame* pFrame)
 {
-  m_getBufferError = false;
-
   int result = Check(avctx);
   if (result)
     return result;
@@ -907,7 +908,7 @@ int CDecoder::Check(AVCodecContext* avctx)
       return VC_ERROR;
   }
 
-  if (m_getBufferError)
+  if (m_getBufferError > 0 && m_getBufferError < 5)
   {
     // if there is no other error, sleep for a short while
     // in order not to drain player's message queue
@@ -917,7 +918,6 @@ int CDecoder::Check(AVCodecContext* avctx)
     ret |= VC_NOBUFFER;
   }
 
-  m_getBufferError = false;
   return ret;
 }
 
@@ -954,7 +954,10 @@ void CDecoder::Reset()
       m_DisplayState = VAAPI_ERROR;
     }
     else
+    {
       m_bufferStats.Reset();
+      m_getBufferError = 0;
+    }
   }
   else
   {
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
index 18769fe968..b3ec89b9f4 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
@@ -457,7 +457,7 @@ protected:
   CVideoSurfaces m_videoSurfaces;
   vaapi_context m_hwContext;
   AVCodecContext* m_avctx;
-  bool m_getBufferError;
+  int m_getBufferError;
 
   COutput m_vaapiOutput;
   CVaapiBufferStats m_bufferStats;

From f5b8e922cb94ce2a2ae330992dc711c375e8a1f1 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 4 Dec 2015 20:08:34 +0100
Subject: [PATCH 29/41] RenderSystem: reduce video latency during video
 playback - GL part

---
 xbmc/Application.cpp                 |  8 ++++++--
 xbmc/rendering/RenderSystem.h        |  1 +
 xbmc/rendering/gl/RenderSystemGL.cpp | 12 ++++++++++++
 xbmc/rendering/gl/RenderSystemGL.h   |  3 +++
 4 files changed, 22 insertions(+), 2 deletions(-)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index df8bb832df..38d65c4db9 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -2353,8 +2353,6 @@ void CApplication::Render()
   // render video layer
   g_windowManager.RenderEx();
 
-  g_renderManager.FrameFinish();
-
   g_Windowing.EndRender();
 
   // reset our info cache - we do this at the end of Render so that it is
@@ -2372,6 +2370,12 @@ void CApplication::Render()
 
   lock.Leave();
 
+  if (g_graphicsContext.IsFullScreenVideo())
+  {
+    g_Windowing.FinishPipeline();
+  }
+  g_renderManager.FrameFinish();
+
   //when nothing has been rendered for m_guiDirtyRegionNoFlipTimeout milliseconds,
   //we don't call g_graphicsContext.Flip() anymore, this saves gpu and cpu usage
   bool flip;
diff --git a/xbmc/rendering/RenderSystem.h b/xbmc/rendering/RenderSystem.h
index 95c26d1384..c756fa1f5b 100644
--- a/xbmc/rendering/RenderSystem.h
+++ b/xbmc/rendering/RenderSystem.h
@@ -108,6 +108,7 @@ public:
 
   virtual void SetVSync(bool vsync) = 0;
   bool GetVSync() { return m_bVSync; }
+  virtual void FinishPipeline() {};
 
   virtual void SetViewPort(CRect& viewPort) = 0;
   virtual void GetViewPort(CRect& viewPort) = 0;
diff --git a/xbmc/rendering/gl/RenderSystemGL.cpp b/xbmc/rendering/gl/RenderSystemGL.cpp
index eb4eb45510..6253c64faf 100644
--- a/xbmc/rendering/gl/RenderSystemGL.cpp
+++ b/xbmc/rendering/gl/RenderSystemGL.cpp
@@ -40,6 +40,7 @@ CRenderSystemGL::CRenderSystemGL() : CRenderSystemBase()
   m_enumRenderingSystem = RENDERING_SYSTEM_OPENGL;
   m_glslMajor = 0;
   m_glslMinor = 0;
+  m_latencyCounter = 0;
 }
 
 CRenderSystemGL::~CRenderSystemGL()
@@ -331,6 +332,7 @@ bool CRenderSystemGL::PresentRender(const CDirtyRegionList& dirty)
   }
 
   bool result = PresentRenderImpl(dirty);
+  m_latencyCounter++;
 
   if (m_iVSyncMode && m_iSwapRate != 0)
   {
@@ -399,6 +401,16 @@ void CRenderSystemGL::SetVSync(bool enable)
     CLog::Log(LOGINFO, "GL: Selected vsync mode %d", m_iVSyncMode);
 }
 
+void CRenderSystemGL::FinishPipeline()
+{
+  // GL implementations are free to queue an undefined number of frames internally
+  // as a result video latency can be very high which is bad for a/v sync
+  // calling glFinish reduces latency to the number of back buffers
+  // in order to keep some elasticity, we call glFinish only every other cycle
+  if (m_latencyCounter & 0x01)
+    glFinish();
+}
+
 void CRenderSystemGL::CaptureStateBlock()
 {
   if (!m_bRenderCreated)
diff --git a/xbmc/rendering/gl/RenderSystemGL.h b/xbmc/rendering/gl/RenderSystemGL.h
index 790ab489b6..7e6d401bea 100644
--- a/xbmc/rendering/gl/RenderSystemGL.h
+++ b/xbmc/rendering/gl/RenderSystemGL.h
@@ -45,6 +45,7 @@ public:
 
   virtual void SetVSync(bool vsync);
   virtual void ResetVSync() { m_bVsyncInit = false; }
+  virtual void FinishPipeline();
 
   virtual void SetViewPort(CRect& viewPort);
   virtual void GetViewPort(CRect& viewPort);
@@ -90,6 +91,8 @@ protected:
   int        m_glslMinor;
   
   GLint      m_viewPort[4];
+
+  uint8_t m_latencyCounter;
 };
 
 #endif // RENDER_SYSTEM_H

From 853a4461b99d15d7d52d8971367626c93686abc6 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 7 Sep 2015 15:39:28 +0100
Subject: [PATCH 30/41] [omxplayer] Update to support VideoPlayer renderer

---
 xbmc/cores/omxplayer/OMXPlayerVideo.cpp | 17 ++++++++++++-----
 1 file changed, 12 insertions(+), 5 deletions(-)

diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
index bc89e3ba50..f0bb87a10a 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
@@ -286,8 +286,8 @@ std::string OMXPlayerVideo::GetStereoMode()
 
 void OMXPlayerVideo::Output(double pts, bool bDropPacket)
 {
-  if (!g_renderManager.IsStarted()) {
-    CLog::Log(LOGINFO, "%s - renderer not started", __FUNCTION__);
+  if (!g_renderManager.IsConfigured()) {
+    CLog::Log(LOGINFO, "%s - renderer not configured", __FUNCTION__);
     return;
   }
 
@@ -758,9 +758,16 @@ void OMXPlayerVideo::ResolutionUpdateCallBack(uint32_t width, uint32_t height, f
   CLog::Log(LOGDEBUG,"%s - change configuration. video:%dx%d. framerate: %4.2f. %dx%d format: BYPASS",
       __FUNCTION__, video_width, video_height, m_fFrameRate, iDisplayWidth, iDisplayHeight);
 
-  if(!g_renderManager.Configure(width, height,
-        iDisplayWidth, iDisplayHeight, m_fFrameRate, flags, format, 0,
-        m_hints.orientation, 3))
+  DVDVideoPicture picture;
+  memset(&picture, 0, sizeof(DVDVideoPicture));
+
+  picture.iWidth = width;
+  picture.iHeight = height;
+  picture.iDisplayWidth = iDisplayWidth;
+  picture.iDisplayHeight = iDisplayHeight;
+  picture.format = format;
+
+  if(!g_renderManager.Configure(picture, m_fFrameRate, flags, m_hints.orientation, 3))
   {
     CLog::Log(LOGERROR, "%s - failed to configure renderer", __FUNCTION__);
     return;

From 3e0cc64d0f01859322d9976c82576b1f481877a4 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 28 Sep 2014 13:52:11 +0200
Subject: [PATCH 31/41] pthreads: use mutex protocol PTHREAD_PRIO_INHERIT

---
 xbmc/threads/platform/pthreads/Implementation.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/threads/platform/pthreads/Implementation.cpp b/xbmc/threads/platform/pthreads/Implementation.cpp
index 3a0f8c5f66..7eab3565e5 100644
--- a/xbmc/threads/platform/pthreads/Implementation.cpp
+++ b/xbmc/threads/platform/pthreads/Implementation.cpp
@@ -38,6 +38,9 @@ namespace XbmcThreads
       {
         pthread_mutexattr_init(&recursiveAttr);
         pthread_mutexattr_settype(&recursiveAttr,PTHREAD_MUTEX_RECURSIVE);
+#if !defined(__arm__) && !defined(TARGET_ANDROID)
+        pthread_mutexattr_setprotocol(&recursiveAttr,PTHREAD_PRIO_INHERIT);
+#endif
         alreadyCalled = true;
       }
       return true; // note, we never call destroy.

From 1cf49b504e9c6752e37ddf685350c5cb35dfb232 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Mon, 7 Dec 2015 18:37:31 +0100
Subject: [PATCH 32/41] gfx: fix toggle fullscreen when playing video

---
 xbmc/cores/VideoRenderers/RenderManager.cpp | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index f41930e5fe..70bf7cd779 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -1119,9 +1119,12 @@ void CXBMCRenderManager::UpdateResolution()
 
 void CXBMCRenderManager::TriggerUpdateResolution(float fps, int width, int flags)
 {
-  m_fps = fps;
-  m_width = width;
-  m_flags = flags;
+  if (width)
+  {
+    m_fps = fps;
+    m_width = width;
+    m_flags = flags;
+  }
   m_bTriggerUpdateResolution = true;
 }
 

From cb400cd81848dc603e73eb3741a18a065854850f Mon Sep 17 00:00:00 2001
From: fritsch <Peter.Fruehberger@gmail.com>
Date: Sat, 19 Dec 2015 20:13:03 +0100
Subject: [PATCH 33/41] LinuxRenderGL: function ptr is never null

---
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 7f904fc8fb..92297d6483 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -900,7 +900,7 @@ void CLinuxRendererGL::LoadShaders(int field)
       
       case RENDER_METHOD_GLSL:
       // Try GLSL shaders if supported and user requested auto or GLSL.
-      if (glCreateProgram && tryGlsl)
+      if (tryGlsl)
       {
         // create regular progressive scan shader
         // if single pass, create GLSLOutput helper and pass it to YUV2RGB shader
@@ -2804,7 +2804,7 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
 
 bool CLinuxRendererGL::SupportsMultiPassRendering()
 {
-  return g_Windowing.IsExtSupported("GL_EXT_framebuffer_object") && glCreateProgram;
+  return g_Windowing.IsExtSupported("GL_EXT_framebuffer_object");
 }
 
 bool CLinuxRendererGL::Supports(EDEINTERLACEMODE mode)

From b6eaca927eb6893ea6f59b7120fe4d511775aea5 Mon Sep 17 00:00:00 2001
From: Memphiz <memphis@machzwo.de>
Date: Sun, 3 Jan 2016 15:19:01 +0100
Subject: [PATCH 34/41] [VideoRendererGles] - render video with full color
 range on gles systems

---
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp          | 1 +
 xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp | 2 +-
 xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h   | 5 +++++
 3 files changed, 7 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index 04a22c829c..aa0ecf2619 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -926,6 +926,7 @@ void CLinuxRendererGLES::RenderSinglePass(int index, int field)
     pYUVShader->SetField(0);
 
   pYUVShader->SetMatrices(glMatrixProject.Get(), glMatrixModview.Get());
+  pYUVShader->SetForceLimitedColorRange(false);
   pYUVShader->Enable();
 
   GLubyte idx[4] = {0, 1, 3, 2};        //determines order of triangle strip
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
index 4050d71624..5ebd4ca23c 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
@@ -289,7 +289,7 @@ bool BaseYUV2RGBGLSLShader::OnEnabled()
 
   GLfloat matrix[4][4];
   // keep video levels
-  CalculateYUVMatrixGL(matrix, m_flags, m_format, m_black, m_contrast, true);
+  CalculateYUVMatrixGL(matrix, m_flags, m_format, m_black, m_contrast, m_forceLimitedColorRange);
 
   glUniformMatrix4fv(m_hMatrix, 1, GL_FALSE, (GLfloat*)matrix);
 #if HAS_GLES == 2
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
index a4d42ad7c7..8751cba9cf 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
@@ -46,6 +46,7 @@ namespace Shaders {
     : virtual public CShaderProgram
   {
   public:
+    BaseYUV2RGBShader() : m_forceLimitedColorRange(true) {};
     virtual ~BaseYUV2RGBShader()      {};
     virtual void SetField(int field)  {};
     virtual void SetWidth(int width)  {};
@@ -63,6 +64,10 @@ namespace Shaders {
     virtual void SetMatrices(GLfloat *p, GLfloat *m) {};
     virtual void SetAlpha(GLfloat alpha)             {};
 #endif
+    void SetForceLimitedColorRange(bool forceLimitedColorRange) { m_forceLimitedColorRange = forceLimitedColorRange; }
+
+  protected:
+    bool  m_forceLimitedColorRange;
   };
 
 

From c900d23a3b3d15773dca50a7763b53e2ac3c8b60 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 5 Jan 2016 14:25:14 +0100
Subject: [PATCH 35/41] VideoPlayer: fix double call of preinit and missing
 render formats for sw decoder

---
 xbmc/cores/VideoRenderers/RenderManager.cpp | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 70bf7cd779..9f9e957d5a 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -348,8 +348,6 @@ bool CXBMCRenderManager::Configure()
     CreateRenderer();
     if (!m_pRenderer)
       return false;
-    else
-      m_pRenderer->PreInit();
   }
 
   bool result = m_pRenderer->Configure(m_width, m_height, m_dwidth, m_dheight, m_fps, m_flags, m_format, m_extended_format, m_orientation);
@@ -552,7 +550,7 @@ void CXBMCRenderManager::PreInit()
 
   if (!m_pRenderer)
   {
-    m_format = RENDER_FMT_NONE;
+    m_format = RENDER_FMT_YUV420P;
     CreateRenderer();
   }
 

From ac0ca1f65349f11f994a3c1ac98eb4487f996a0d Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 14 Jan 2016 20:48:54 +0100
Subject: [PATCH 36/41] VideoPlayer: optimze configure of renderer

---
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp   | 5 ++++-
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp | 4 +++-
 xbmc/cores/VideoRenderers/RenderManager.cpp     | 6 ++++++
 3 files changed, 13 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 92297d6483..63660c481e 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -531,9 +531,12 @@ void CLinuxRendererGL::Flush()
 
 void CLinuxRendererGL::Update()
 {
-  if (!m_bConfigured) return;
+  if (!m_bConfigured)
+    return;
   ManageDisplay();
   m_scalingMethodGui = (ESCALINGMETHOD)-1;
+
+  ValidateRenderTarget();
 }
 
 void CLinuxRendererGL::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index aa0ecf2619..f41044a342 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -427,8 +427,10 @@ void CLinuxRendererGLES::Flush()
 
 void CLinuxRendererGLES::Update()
 {
-  if (!m_bConfigured) return;
+  if (!m_bConfigured)
+    return;
   ManageDisplay();
+  ValidateRenderTarget();
 }
 
 void CLinuxRendererGLES::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 9f9e957d5a..d6a9a532ed 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -315,6 +315,10 @@ bool CXBMCRenderManager::Configure(DVDVideoPicture& picture, float fps, unsigned
     m_NumberBuffers  = buffers;
     m_renderState = STATE_CONFIGURING;
     m_stateEvent.Reset();
+
+    CSingleLock lock2(m_presentlock);
+    m_presentstep = PRESENT_READY;
+    m_presentevent.notifyAll();
   }
 
   if (!m_stateEvent.WaitMSec(1000))
@@ -444,6 +448,8 @@ void CXBMCRenderManager::FrameMove()
     if (!Configure())
       return;
 
+    FrameWait(50);
+
     if (m_flags & CONF_FLAGS_FULLSCREEN)
     {
       CApplicationMessenger::Get().SwitchToFullscreen();

From 349a9cfb15fc698fccf818cbd2a4cfa31cd726d0 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Mon, 18 Jan 2016 20:17:12 +0100
Subject: [PATCH 37/41] VideoPlayer: check state of renderer FrameFinish

---
 xbmc/cores/VideoRenderers/RenderManager.cpp | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index d6a9a532ed..ae6ccf031f 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -504,6 +504,12 @@ void CXBMCRenderManager::FrameMove()
 
 void CXBMCRenderManager::FrameFinish()
 {
+  {
+    CSharedLock lock(m_sharedSection);
+    if (m_renderState != STATE_CONFIGURED)
+      return;
+  }
+
   /* wait for this present to be valid */
   SPresent& m = m_Queue[m_presentsource];
 
@@ -565,6 +571,7 @@ void CXBMCRenderManager::PreInit()
   m_QueueSize   = 2;
   m_QueueSkip   = 0;
   m_presentstep = PRESENT_IDLE;
+  m_format = RENDER_FMT_NONE;
 }
 
 void CXBMCRenderManager::UnInit()

From 3bde4dea860c83c08a7031d3b157d1682ac96c2e Mon Sep 17 00:00:00 2001
From: fritsch <fritsch@xbmc.org>
Date: Thu, 14 Apr 2016 15:10:57 +0200
Subject: [PATCH 38/41] LinuxRendererGL/LinuxRendererGLES: Use av_malloc for
 sws_scale interaction

---
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp   | 8 ++++----
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp | 8 ++++----
 2 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 63660c481e..c771c135a2 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -169,7 +169,7 @@ CLinuxRendererGL::~CLinuxRendererGL()
   }
   else
   {
-    delete [] m_rgbBuffer;
+    av_free(m_rgbBuffer);
     m_rgbBuffer = NULL;
   }
 
@@ -1010,7 +1010,7 @@ void CLinuxRendererGL::UnInit()
   }
   else
   {
-    delete [] m_rgbBuffer;
+    av_free(m_rgbBuffer);
     m_rgbBuffer = NULL;
   }
   m_rgbBufferSize = 0;
@@ -2594,7 +2594,7 @@ void CLinuxRendererGL::SetupRGBBuffer()
   m_rgbBufferSize = m_sourceWidth * m_sourceHeight * 4;
 
   if (!m_rgbPbo)
-    delete [] m_rgbBuffer;
+    av_free(m_rgbBuffer);
 
   if (m_pboSupported)
   {
@@ -2623,7 +2623,7 @@ void CLinuxRendererGL::SetupRGBBuffer()
   }
 
   if (!m_rgbPbo)
-    m_rgbBuffer = new BYTE[m_rgbBufferSize];
+    m_rgbBuffer = (BYTE*) av_malloc(m_rgbBufferSize);
 }
 
 bool CLinuxRendererGL::UploadRGBTexture(int source)
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index f41044a342..393ca6620f 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -127,7 +127,7 @@ CLinuxRendererGLES::~CLinuxRendererGLES()
   UnInit();
 
   if (m_rgbBuffer != NULL) {
-    delete [] m_rgbBuffer;
+    av_free(m_rgbBuffer);
     m_rgbBuffer = NULL;
   }
 
@@ -765,7 +765,7 @@ void CLinuxRendererGLES::UnInit()
 
   if (m_rgbBuffer != NULL)
   {
-    delete [] m_rgbBuffer;
+    av_free(m_rgbBuffer);
     m_rgbBuffer = NULL;
   }
   m_rgbBufferSize = 0;
@@ -1461,9 +1461,9 @@ void CLinuxRendererGLES::UploadYV12Texture(int source)
   {
     if(m_rgbBufferSize < m_sourceWidth * m_sourceHeight * 4)
     {
-      delete [] m_rgbBuffer;
+      av_free(m_rgbBuffer);
       m_rgbBufferSize = m_sourceWidth*m_sourceHeight*4;
-      m_rgbBuffer = new BYTE[m_rgbBufferSize];
+      m_rgbBuffer = (BYTE*) av_malloc(m_rgbBufferSize);
     }
 
 #if defined(__ARM_NEON__)

From 770f1cde87f4544ed63a12cd0fa6e104ddc19b65 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 28 Apr 2016 08:45:08 +0200
Subject: [PATCH 39/41] VideoPlayer: move limited/full range conversion to
 matrix for single pass

---
 system/shaders/output.glsl                            | 6 +++---
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp         | 3 ++-
 xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp | 6 +++---
 3 files changed, 8 insertions(+), 7 deletions(-)

diff --git a/system/shaders/output.glsl b/system/shaders/output.glsl
index 83f77b04c0..ecaa30d9da 100644
--- a/system/shaders/output.glsl
+++ b/system/shaders/output.glsl
@@ -1,4 +1,4 @@
-#if (XBMC_DITHER)
+#if defined(XBMC_DITHER)
 uniform sampler2D m_dither;
 uniform float     m_ditherquant;
 uniform vec2      m_dithersize;
@@ -8,11 +8,11 @@ void main()
 {
   vec4 rgb        = process();
 
-#if (XBMC_FULLRANGE)
+#if defined(XBMC_FULLRANGE)
   rgb             = clamp((rgb-(16.0/255.0)) * 255.0/219.0, 0, 1);
 #endif
 
-#if (XBMC_DITHER)
+#if defined(XBMC_DITHER)
   vec2 ditherpos  = gl_FragCoord.xy / m_dithersize;
   // ditherval is multiplied by 65536/(dither_size^2) to make it [0,1[
   // FIXME: scale dither values before uploading?
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index c771c135a2..6b1156f90b 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -909,10 +909,11 @@ void CLinuxRendererGL::LoadShaders(int field)
         // if single pass, create GLSLOutput helper and pass it to YUV2RGB shader
         GLSLOutput *out = nullptr;
         if (m_renderQuality == RQ_SINGLEPASS)
-          out = new GLSLOutput(3, m_useDithering, m_ditherDepth, m_fullRange);
+          out = new GLSLOutput(3, m_useDithering, m_ditherDepth, false);
         m_pYUVShader = new YUV2RGBProgressiveShader(m_textureTarget==GL_TEXTURE_RECTANGLE_ARB, m_iFlags, m_format,
                                                     m_nonLinStretch && m_renderQuality == RQ_SINGLEPASS,
                                                     out);
+        m_pYUVShader->SetForceLimitedColorRange(false);
 
         CLog::Log(LOGNOTICE, "GL: Selecting Single Pass YUV 2 RGB shader");
 
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
index 182a893e3d..b6cd2e2f5b 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/GLSLOutput.cpp
@@ -49,11 +49,11 @@ GLSLOutput::GLSLOutput(int texunit, bool useDithering, unsigned int ditherDepth,
 
 std::string GLSLOutput::GetDefines()
 {
-  std::string defines = "#define XBMC_OUTPUT 1\n";
+  std::string defines;
   if (m_dither)
-    defines += "#define XBMC_DITHER 1\n";
+    defines += "#define XBMC_DITHER\n";
   if (m_fullRange)
-    defines += "#define XBMC_FULLRANGE 1\n";
+    defines += "#define XBMC_FULLRANGE\n";
   return defines;
 }
 

From ebe8afe96336506f9cff592111316f83c9ae707c Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Mon, 2 May 2016 11:34:54 +0200
Subject: [PATCH 40/41] VideoPlayer: fix color range conversion for multi pass

---
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp      |  5 +++--
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp    |  2 +-
 .../VideoRenderers/VideoShaders/YUV2RGBShader.cpp  |  7 +++----
 .../VideoRenderers/VideoShaders/YUV2RGBShader.h    | 23 +++++++++++-----------
 4 files changed, 18 insertions(+), 19 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 6b1156f90b..df705781ba 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -840,7 +840,7 @@ void CLinuxRendererGL::UpdateVideoFilter()
     }
 
     GLSLOutput *out;
-    out = new GLSLOutput(3, m_useDithering, m_ditherDepth, m_fullRange);
+    out = new GLSLOutput(3, m_useDithering, m_ditherDepth, false);
     m_pVideoFilterShader = new ConvolutionFilterShader(m_scalingMethod, m_nonLinStretch, out);
     if (!m_pVideoFilterShader->CompileAndLink())
     {
@@ -913,7 +913,7 @@ void CLinuxRendererGL::LoadShaders(int field)
         m_pYUVShader = new YUV2RGBProgressiveShader(m_textureTarget==GL_TEXTURE_RECTANGLE_ARB, m_iFlags, m_format,
                                                     m_nonLinStretch && m_renderQuality == RQ_SINGLEPASS,
                                                     out);
-        m_pYUVShader->SetForceLimitedColorRange(false);
+        m_pYUVShader->SetConvertFullColorRange(m_fullRange);
 
         CLog::Log(LOGNOTICE, "GL: Selecting Single Pass YUV 2 RGB shader");
 
@@ -941,6 +941,7 @@ void CLinuxRendererGL::LoadShaders(int field)
 
         // create regular progressive scan shader
         m_pYUVShader = new YUV2RGBProgressiveShaderARB(m_textureTarget==GL_TEXTURE_RECTANGLE_ARB, m_iFlags, m_format);
+        m_pYUVShader->SetConvertFullColorRange(m_fullRange);
         CLog::Log(LOGNOTICE, "GL: Selecting Single Pass ARB YUV2RGB shader");
 
         if (m_pYUVShader && m_pYUVShader->CompileAndLink())
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index 393ca6620f..25986c760c 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -928,7 +928,7 @@ void CLinuxRendererGLES::RenderSinglePass(int index, int field)
     pYUVShader->SetField(0);
 
   pYUVShader->SetMatrices(glMatrixProject.Get(), glMatrixModview.Get());
-  pYUVShader->SetForceLimitedColorRange(false);
+  pYUVShader->SetConvertFullColorRange(!g_Windowing.UseLimitedColor());
   pYUVShader->Enable();
 
   GLubyte idx[4] = {0, 1, 3, 2};        //determines order of triangle strip
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
index 5ebd4ca23c..daa322b6db 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
@@ -24,7 +24,6 @@
 #include "YUV2RGBShader.h"
 #include "settings/AdvancedSettings.h"
 #include "guilib/TransformMatrix.h"
-#include "windowing/WindowingFactory.h"
 #include "utils/log.h"
 #if defined(HAS_GL) || defined(HAS_GLES)
 #include "utils/GLUtils.h"
@@ -108,7 +107,7 @@ void CalculateYUVMatrix(TransformMatrix &matrix
       coef.m[row][col] = conv[col][row];
   coef.identity = false;
 
-  if(g_Windowing.UseLimitedColor() || limited)
+  if (limited)
   {
     matrix *= TransformMatrix::CreateTranslation(+ 16.0f / 255
                                                , + 16.0f / 255
@@ -289,7 +288,7 @@ bool BaseYUV2RGBGLSLShader::OnEnabled()
 
   GLfloat matrix[4][4];
   // keep video levels
-  CalculateYUVMatrixGL(matrix, m_flags, m_format, m_black, m_contrast, m_forceLimitedColorRange);
+  CalculateYUVMatrixGL(matrix, m_flags, m_format, m_black, m_contrast, !m_convertFullRange);
 
   glUniformMatrix4fv(m_hMatrix, 1, GL_FALSE, (GLfloat*)matrix);
 #if HAS_GLES == 2
@@ -432,7 +431,7 @@ void YUV2RGBProgressiveShaderARB::OnCompiledAndLinked()
 bool YUV2RGBProgressiveShaderARB::OnEnabled()
 {
   GLfloat matrix[4][4];
-  CalculateYUVMatrixGL(matrix, m_flags, m_format, m_black, m_contrast, false);
+  CalculateYUVMatrixGL(matrix, m_flags, m_format, m_black, m_contrast, !m_convertFullRange);
 
   for(int i=0;i<4;i++)
     glProgramLocalParameter4fARB(GL_FRAGMENT_PROGRAM_ARB, i
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
index 8751cba9cf..e390ce1bae 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
@@ -42,19 +42,18 @@ void CalculateYUVMatrix(TransformMatrix &matrix
 
 namespace Shaders {
 
-  class BaseYUV2RGBShader
-    : virtual public CShaderProgram
+  class BaseYUV2RGBShader : virtual public CShaderProgram
   {
   public:
-    BaseYUV2RGBShader() : m_forceLimitedColorRange(true) {};
-    virtual ~BaseYUV2RGBShader()      {};
-    virtual void SetField(int field)  {};
-    virtual void SetWidth(int width)  {};
+    BaseYUV2RGBShader() : m_convertFullRange(false) {};
+    virtual ~BaseYUV2RGBShader() {};
+    virtual void SetField(int field) {};
+    virtual void SetWidth(int width) {};
     virtual void SetHeight(int width) {};
 
-    virtual void SetBlack(float black)          {};
-    virtual void SetContrast(float contrast)    {};
-    virtual void SetNonLinStretch(float stretch){};
+    virtual void SetBlack(float black) {};
+    virtual void SetContrast(float contrast) {};
+    virtual void SetNonLinStretch(float stretch) {};
 #if HAS_GLES == 2
     virtual GLint GetVertexLoc() { return 0; };
     virtual GLint GetYcoordLoc() { return 0; };
@@ -62,12 +61,12 @@ namespace Shaders {
     virtual GLint GetVcoordLoc() { return 0; };
 
     virtual void SetMatrices(GLfloat *p, GLfloat *m) {};
-    virtual void SetAlpha(GLfloat alpha)             {};
+    virtual void SetAlpha(GLfloat alpha) {};
 #endif
-    void SetForceLimitedColorRange(bool forceLimitedColorRange) { m_forceLimitedColorRange = forceLimitedColorRange; }
+    void SetConvertFullColorRange(bool convertFullRange) { m_convertFullRange = convertFullRange; }
 
   protected:
-    bool  m_forceLimitedColorRange;
+    bool m_convertFullRange;
   };
 
 

From 4331d84a5f4da64b2aecf0159b8b7ad07a318ed7 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Tue, 5 Jul 2016 07:34:05 +0200
Subject: [PATCH 41/41] Fix windows build

---
 xbmc/cores/VideoRenderers/HwDecRender/DXVA.cpp         | 2 +-
 xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.cpp       | 2 +-
 xbmc/cores/VideoRenderers/VideoShaders/CMakeLists.txt  | 3 +++
 xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h | 4 ++--
 xbmc/cores/VideoRenderers/WinRenderer.h                | 4 ++--
 5 files changed, 9 insertions(+), 6 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/HwDecRender/DXVA.cpp b/xbmc/cores/VideoRenderers/HwDecRender/DXVA.cpp
index 7a8590d2e9..cd8eb48e7e 100644
--- a/xbmc/cores/VideoRenderers/HwDecRender/DXVA.cpp
+++ b/xbmc/cores/VideoRenderers/HwDecRender/DXVA.cpp
@@ -33,7 +33,7 @@
 #include "utils/StringUtils.h"
 #include "settings/AdvancedSettings.h"
 #include "cores/VideoRenderers/RenderManager.h"
-#include "RenderFlags.h"
+#include "../RenderFlags.h"
 #include "win32/WIN32Util.h"
 #include "utils/Log.h"
 
diff --git a/xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.cpp b/xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.cpp
index 4d0ddfae0e..201424c014 100644
--- a/xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.cpp
+++ b/xbmc/cores/VideoRenderers/HwDecRender/DXVAHD.cpp
@@ -37,7 +37,7 @@
 #include "utils/StringUtils.h"
 #include "settings/AdvancedSettings.h"
 #include "cores/VideoRenderers/RenderManager.h"
-#include "RenderFlags.h"
+#include "../RenderFlags.h"
 #include "win32/WIN32Util.h"
 #include "utils/Log.h"
 
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/CMakeLists.txt b/xbmc/cores/VideoRenderers/VideoShaders/CMakeLists.txt
index fa5b14086e..5dd17d7a3a 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/CMakeLists.txt
+++ b/xbmc/cores/VideoRenderers/VideoShaders/CMakeLists.txt
@@ -2,4 +2,7 @@ find_all_sources(. shaders_SRCS)
 if(NOT TARGET_WIN32)
 	list(REMOVE_ITEM shaders_SRCS ./WinVideoFilter.cpp)
 endif()
+if(TARGET_WIN32)
+	list(REMOVE_ITEM shaders_SRCS ./GLSLOutput.cpp)
+endif()
 add_sources(${shaders_SRCS})
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
index e390ce1bae..2b65f22c85 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.h
@@ -22,8 +22,6 @@
 #include "guilib/TransformMatrix.h"
 #include "cores/VideoRenderers/RenderFormats.h"
 
-#include "GLSLOutput.h"
-
 void CalculateYUVMatrix(TransformMatrix &matrix
                         , unsigned int  flags
                         , ERenderFormat format
@@ -33,6 +31,8 @@ void CalculateYUVMatrix(TransformMatrix &matrix
 
 #if defined(HAS_GL) || HAS_GLES == 2
 
+#include "GLSLOutput.h"
+
 #ifndef __GNUC__
 #pragma warning( push )
 #pragma warning( disable : 4250 )
diff --git a/xbmc/cores/VideoRenderers/WinRenderer.h b/xbmc/cores/VideoRenderers/WinRenderer.h
index a80395c1db..22f49325f0 100644
--- a/xbmc/cores/VideoRenderers/WinRenderer.h
+++ b/xbmc/cores/VideoRenderers/WinRenderer.h
@@ -27,8 +27,8 @@
 #include "guilib/D3DResource.h"
 #include "RenderCapture.h"
 #include "settings/VideoSettings.h"
-#include "DXVA.h"
-#include "DXVAHD.h"
+#include "HwDecRender/DXVA.h"
+#include "HwDecRender/DXVAHD.h"
 
 #define ALIGN(value, alignment) (((value)+((alignment)-1))&~((alignment)-1))
 #define CLAMP(a, min, max) ((a) > (max) ? (max) : ( (a) < (min) ? (min) : a ))
